var ms = Object.defineProperty;
var bs = (t, o, e) => o in t ? ms(t, o, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[o] = e;
var je = (t, o, e) => (bs(t, typeof o != "symbol" ? o + "" : o, e), e);
import { computed as h, toValue as xe, ref as H, shallowRef as Ca, watch as de, getCurrentScope as uo, onScopeDispose as co, shallowReadonly as Tt, unref as s, isRef as ys, toRef as T, readonly as Oe, customRef as gs, onMounted as He, nextTick as Ne, getCurrentInstance as Bt, reactive as _l, watchEffect as Et, defineComponent as G, mergeModels as be, useModel as we, onBeforeUnmount as Qa, openBlock as b, createElementBlock as O, Fragment as pe, createElementVNode as ae, renderSlot as V, createBlock as L, Teleport as _t, mergeProps as J, normalizeClass as W, normalizeStyle as ze, createTextVNode as ce, toDisplayString as oe, createCommentVNode as ne, render as fo, h as Ie, inject as Ve, provide as We, onActivated as hs, Transition as el, withCtx as R, useAttrs as Lt, resolveDynamicComponent as fe, createVNode as ge, useSlots as De, withDirectives as dt, normalizeProps as _e, guardReactiveProps as Se, vShow as Kt, renderList as ke, TransitionGroup as vo, vModelCheckbox as Bs, vModelRadio as _s, vModelSelect as ws, withModifiers as xt, createSlots as tl, onUnmounted as Cs, withKeys as Zt } from "vue";
const Xt = (t) => h(() => {
  const o = xe(t);
  return o ? `justify-content-${o}` : "";
}), ka = (t, o) => h(() => {
  const e = xe(t), l = xe(o);
  return e === !0 ? "true" : typeof e == "string" ? e : l === !1 ? "true" : e === !1 ? "false" : void 0;
});
class ut {
  constructor(o, e = {}) {
    je(this, "cancelable", !0);
    je(this, "componentId", null);
    je(this, "_defaultPrevented", !1);
    je(this, "eventType", "");
    je(this, "nativeEvent", null);
    je(this, "_preventDefault");
    je(this, "relatedTarget", null);
    je(this, "target", null);
    if (!o)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, ut.Defaults, e, { eventType: o }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(o) {
    this._defaultPrevented = o;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(o) {
    this._preventDefault = o;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class wt extends ut {
  constructor(e, l = {}) {
    super(e, l);
    je(this, "trigger", null);
    Object.assign(this, ut.Defaults, l, { eventType: e });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class po extends ut {
  constructor(e, l) {
    super(e, l);
    je(this, "from");
    je(this, "to");
    je(this, "direction");
    Object.assign(this, ut.Defaults, l, { eventType: e });
    const { from: a, direction: n, to: r } = l;
    this.from = a, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const ks = (t, o = {}) => {
  const e = (a = []) => {
    const { activeElement: n } = document;
    return n && !a.some((r) => r === n) ? n : null;
  }, l = (a) => a === e();
  try {
    t.focus(o);
  } catch (a) {
    console.error(a);
  }
  return l(t);
}, Pe = (t) => ((t == null ? void 0 : t()) ?? []).length === 0, Ts = (t) => {
  if (t.getAttribute("display") === "none")
    return !1;
  const o = t.getBoundingClientRect();
  return !!(o && o.height > 0 && o.width > 0);
}, La = (t) => {
  const o = window.getComputedStyle(t), e = o.transitionDelay.split(",")[0] || "", l = o.transitionDuration.split(",")[0] || "", a = Number(e.slice(0, -1)) * 1e3, n = Number(l.slice(0, -1)) * 1e3;
  return a + n;
}, al = typeof window < "u" && typeof document < "u" && typeof navigator < "u", Ss = (t) => (() => {
  let e = !1;
  if (al)
    try {
      const l = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      WINDOW.addEventListener("test", l, l), WINDOW.removeEventListener("test", l, l);
    } catch {
      e = !1;
    }
  return e;
})() ? typeof t == "object" ? t : { capture: !!t || !1 } : typeof t == "object" ? t.capture : t, xs = (t, o, e, l) => {
  t && t.addEventListener && t.addEventListener(o, e, Ss(l));
}, $s = (t, o, e, l) => {
  t && t.removeEventListener && t.removeEventListener(o, e, l);
}, wl = (t, o) => {
  (t ? xs : $s)(...o);
}, As = ["TD", "TH", "TR"], Vs = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Jt = (t) => {
  if (!t || !t.target)
    return !1;
  const o = t.target;
  if ("disabled" in o && o.disabled || As.indexOf(o.tagName) !== -1)
    return !1;
  if (o.closest(".dropdown-menu"))
    return !0;
  const e = o.tagName === "LABEL" ? o : o.closest("label");
  if (e) {
    const l = e.getAttribute("for"), a = l ? document.getElementById(l) : e.querySelector("input, select, textarea");
    if (a && !a.disabled)
      return !0;
  }
  return o.matches(Vs);
}, mo = ["top", "right", "bottom", "left"], Cl = ["start", "end"], kl = /* @__PURE__ */ mo.reduce((t, o) => t.concat(o, o + "-" + Cl[0], o + "-" + Cl[1]), []), lt = Math.min, at = Math.max, Fs = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Ns = {
  start: "end",
  end: "start"
};
function Ra(t, o, e) {
  return at(t, lt(o, e));
}
function ct(t, o) {
  return typeof t == "function" ? t(o) : t;
}
function Ye(t) {
  return t.split("-")[0];
}
function et(t) {
  return t.split("-")[1];
}
function bo(t) {
  return t === "x" ? "y" : "x";
}
function ll(t) {
  return t === "y" ? "height" : "width";
}
function Rt(t) {
  return ["top", "bottom"].includes(Ye(t)) ? "y" : "x";
}
function ol(t) {
  return bo(Rt(t));
}
function yo(t, o, e) {
  e === void 0 && (e = !1);
  const l = et(t), a = ol(t), n = ll(a);
  let r = a === "x" ? l === (e ? "end" : "start") ? "right" : "left" : l === "start" ? "bottom" : "top";
  return o.reference[n] > o.floating[n] && (r = da(r)), [r, da(r)];
}
function Os(t) {
  const o = da(t);
  return [ua(t), o, ua(o)];
}
function ua(t) {
  return t.replace(/start|end/g, (o) => Ns[o]);
}
function Ps(t, o, e) {
  const l = ["left", "right"], a = ["right", "left"], n = ["top", "bottom"], r = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return e ? o ? a : l : o ? l : a;
    case "left":
    case "right":
      return o ? n : r;
    default:
      return [];
  }
}
function Is(t, o, e, l) {
  const a = et(t);
  let n = Ps(Ye(t), e === "start", l);
  return a && (n = n.map((r) => r + "-" + a), o && (n = n.concat(n.map(ua)))), n;
}
function da(t) {
  return t.replace(/left|right|bottom|top/g, (o) => Fs[o]);
}
function Es(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function nl(t) {
  return typeof t != "number" ? Es(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function yt(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}
function Tl(t, o, e) {
  let {
    reference: l,
    floating: a
  } = t;
  const n = Rt(o), r = ol(o), u = ll(r), i = Ye(o), d = n === "y", c = l.x + l.width / 2 - a.width / 2, f = l.y + l.height / 2 - a.height / 2, p = l[u] / 2 - a[u] / 2;
  let v;
  switch (i) {
    case "top":
      v = {
        x: c,
        y: l.y - a.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: l.y + l.height
      };
      break;
    case "right":
      v = {
        x: l.x + l.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: l.x - a.width,
        y: f
      };
      break;
    default:
      v = {
        x: l.x,
        y: l.y
      };
  }
  switch (et(o)) {
    case "start":
      v[r] -= p * (e && d ? -1 : 1);
      break;
    case "end":
      v[r] += p * (e && d ? -1 : 1);
      break;
  }
  return v;
}
const Ls = async (t, o, e) => {
  const {
    placement: l = "bottom",
    strategy: a = "absolute",
    middleware: n = [],
    platform: r
  } = e, u = n.filter(Boolean), i = await (r.isRTL == null ? void 0 : r.isRTL(o));
  let d = await r.getElementRects({
    reference: t,
    floating: o,
    strategy: a
  }), {
    x: c,
    y: f
  } = Tl(d, l, i), p = l, v = {}, m = 0;
  for (let B = 0; B < u.length; B++) {
    const {
      name: w,
      fn: _
    } = u[B], {
      x: k,
      y: g,
      data: $,
      reset: y
    } = await _({
      x: c,
      y: f,
      initialPlacement: l,
      placement: p,
      strategy: a,
      middlewareData: v,
      rects: d,
      platform: r,
      elements: {
        reference: t,
        floating: o
      }
    });
    c = k ?? c, f = g ?? f, v = {
      ...v,
      [w]: {
        ...v[w],
        ...$
      }
    }, y && m <= 50 && (m++, typeof y == "object" && (y.placement && (p = y.placement), y.rects && (d = y.rects === !0 ? await r.getElementRects({
      reference: t,
      floating: o,
      strategy: a
    }) : y.rects), {
      x: c,
      y: f
    } = Tl(d, p, i)), B = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: a,
    middlewareData: v
  };
};
async function It(t, o) {
  var e;
  o === void 0 && (o = {});
  const {
    x: l,
    y: a,
    platform: n,
    rects: r,
    elements: u,
    strategy: i
  } = t, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = ct(o, t), m = nl(v), w = u[p ? f === "floating" ? "reference" : "floating" : f], _ = yt(await n.getClippingRect({
    element: (e = await (n.isElement == null ? void 0 : n.isElement(w))) == null || e ? w : w.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(u.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: i
  })), k = f === "floating" ? {
    x: l,
    y: a,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, g = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(u.floating)), $ = await (n.isElement == null ? void 0 : n.isElement(g)) ? await (n.getScale == null ? void 0 : n.getScale(g)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, y = yt(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: k,
    offsetParent: g,
    strategy: i
  }) : k);
  return {
    top: (_.top - y.top + m.top) / $.y,
    bottom: (y.bottom - _.bottom + m.bottom) / $.y,
    left: (_.left - y.left + m.left) / $.x,
    right: (y.right - _.right + m.right) / $.x
  };
}
const Rs = (t) => ({
  name: "arrow",
  options: t,
  async fn(o) {
    const {
      x: e,
      y: l,
      placement: a,
      rects: n,
      platform: r,
      elements: u,
      middlewareData: i
    } = o, {
      element: d,
      padding: c = 0
    } = ct(t, o) || {};
    if (d == null)
      return {};
    const f = nl(c), p = {
      x: e,
      y: l
    }, v = ol(a), m = ll(v), B = await r.getDimensions(d), w = v === "y", _ = w ? "top" : "left", k = w ? "bottom" : "right", g = w ? "clientHeight" : "clientWidth", $ = n.reference[m] + n.reference[v] - p[v] - n.floating[m], y = p[v] - n.reference[v], A = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(d));
    let S = A ? A[g] : 0;
    (!S || !await (r.isElement == null ? void 0 : r.isElement(A))) && (S = u.floating[g] || n.floating[m]);
    const Y = $ / 2 - y / 2, K = S / 2 - B[m] / 2 - 1, P = lt(f[_], K), j = lt(f[k], K), F = P, N = S - B[m] - j, z = S / 2 - B[m] / 2 + Y, C = Ra(F, z, N), x = !i.arrow && et(a) != null && z !== C && n.reference[m] / 2 - (z < F ? P : j) - B[m] / 2 < 0, E = x ? z < F ? z - F : z - N : 0;
    return {
      [v]: p[v] + E,
      data: {
        [v]: C,
        centerOffset: z - C - E,
        ...x && {
          alignmentOffset: E
        }
      },
      reset: x
    };
  }
});
function zs(t, o, e) {
  return (t ? [...e.filter((a) => et(a) === t), ...e.filter((a) => et(a) !== t)] : e.filter((a) => Ye(a) === a)).filter((a) => t ? et(a) === t || (o ? ua(a) !== a : !1) : !0);
}
const Ms = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(o) {
      var e, l, a;
      const {
        rects: n,
        middlewareData: r,
        placement: u,
        platform: i,
        elements: d
      } = o, {
        crossAxis: c = !1,
        alignment: f,
        allowedPlacements: p = kl,
        autoAlignment: v = !0,
        ...m
      } = ct(t, o), B = f !== void 0 || p === kl ? zs(f || null, v, p) : p, w = await It(o, m), _ = ((e = r.autoPlacement) == null ? void 0 : e.index) || 0, k = B[_];
      if (k == null)
        return {};
      const g = yo(k, n, await (i.isRTL == null ? void 0 : i.isRTL(d.floating)));
      if (u !== k)
        return {
          reset: {
            placement: B[0]
          }
        };
      const $ = [w[Ye(k)], w[g[0]], w[g[1]]], y = [...((l = r.autoPlacement) == null ? void 0 : l.overflows) || [], {
        placement: k,
        overflows: $
      }], A = B[_ + 1];
      if (A)
        return {
          data: {
            index: _ + 1,
            overflows: y
          },
          reset: {
            placement: A
          }
        };
      const S = y.map((P) => {
        const j = et(P.placement);
        return [P.placement, j && c ? (
          // Check along the mainAxis and main crossAxis side.
          P.overflows.slice(0, 2).reduce((F, N) => F + N, 0)
        ) : (
          // Check only the mainAxis.
          P.overflows[0]
        ), P.overflows];
      }).sort((P, j) => P[1] - j[1]), K = ((a = S.filter((P) => P[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        et(P[0]) ? 2 : 3
      ).every((j) => j <= 0))[0]) == null ? void 0 : a[0]) || S[0][0];
      return K !== u ? {
        data: {
          index: _ + 1,
          overflows: y
        },
        reset: {
          placement: K
        }
      } : {};
    }
  };
}, go = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(o) {
      var e, l;
      const {
        placement: a,
        middlewareData: n,
        rects: r,
        initialPlacement: u,
        platform: i,
        elements: d
      } = o, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: B = !0,
        ...w
      } = ct(t, o);
      if ((e = n.arrow) != null && e.alignmentOffset)
        return {};
      const _ = Ye(a), k = Ye(u) === u, g = await (i.isRTL == null ? void 0 : i.isRTL(d.floating)), $ = p || (k || !B ? [da(u)] : Os(u));
      !p && m !== "none" && $.push(...Is(u, B, m, g));
      const y = [u, ...$], A = await It(o, w), S = [];
      let Y = ((l = n.flip) == null ? void 0 : l.overflows) || [];
      if (c && S.push(A[_]), f) {
        const F = yo(a, r, g);
        S.push(A[F[0]], A[F[1]]);
      }
      if (Y = [...Y, {
        placement: a,
        overflows: S
      }], !S.every((F) => F <= 0)) {
        var K, P;
        const F = (((K = n.flip) == null ? void 0 : K.index) || 0) + 1, N = y[F];
        if (N)
          return {
            data: {
              index: F,
              overflows: Y
            },
            reset: {
              placement: N
            }
          };
        let z = (P = Y.filter((C) => C.overflows[0] <= 0).sort((C, x) => C.overflows[1] - x.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!z)
          switch (v) {
            case "bestFit": {
              var j;
              const C = (j = Y.map((x) => [x.placement, x.overflows.filter((E) => E > 0).reduce((E, I) => E + I, 0)]).sort((x, E) => x[1] - E[1])[0]) == null ? void 0 : j[0];
              C && (z = C);
              break;
            }
            case "initialPlacement":
              z = u;
              break;
          }
        if (a !== z)
          return {
            reset: {
              placement: z
            }
          };
      }
      return {};
    }
  };
};
function Sl(t, o) {
  return {
    top: t.top - o.height,
    right: t.right - o.width,
    bottom: t.bottom - o.height,
    left: t.left - o.width
  };
}
function xl(t) {
  return mo.some((o) => t[o] >= 0);
}
const Hs = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(o) {
      const {
        rects: e
      } = o, {
        strategy: l = "referenceHidden",
        ...a
      } = ct(t, o);
      switch (l) {
        case "referenceHidden": {
          const n = await It(o, {
            ...a,
            elementContext: "reference"
          }), r = Sl(n, e.reference);
          return {
            data: {
              referenceHiddenOffsets: r,
              referenceHidden: xl(r)
            }
          };
        }
        case "escaped": {
          const n = await It(o, {
            ...a,
            altBoundary: !0
          }), r = Sl(n, e.floating);
          return {
            data: {
              escapedOffsets: r,
              escaped: xl(r)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function ho(t) {
  const o = lt(...t.map((n) => n.left)), e = lt(...t.map((n) => n.top)), l = at(...t.map((n) => n.right)), a = at(...t.map((n) => n.bottom));
  return {
    x: o,
    y: e,
    width: l - o,
    height: a - e
  };
}
function Ds(t) {
  const o = t.slice().sort((a, n) => a.y - n.y), e = [];
  let l = null;
  for (let a = 0; a < o.length; a++) {
    const n = o[a];
    !l || n.y - l.y > l.height / 2 ? e.push([n]) : e[e.length - 1].push(n), l = n;
  }
  return e.map((a) => yt(ho(a)));
}
const js = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(o) {
      const {
        placement: e,
        elements: l,
        rects: a,
        platform: n,
        strategy: r
      } = o, {
        padding: u = 2,
        x: i,
        y: d
      } = ct(t, o), c = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(l.reference)) || []), f = Ds(c), p = yt(ho(c)), v = nl(u);
      function m() {
        if (f.length === 2 && f[0].left > f[1].right && i != null && d != null)
          return f.find((w) => i > w.left - v.left && i < w.right + v.right && d > w.top - v.top && d < w.bottom + v.bottom) || p;
        if (f.length >= 2) {
          if (Rt(e) === "y") {
            const P = f[0], j = f[f.length - 1], F = Ye(e) === "top", N = P.top, z = j.bottom, C = F ? P.left : j.left, x = F ? P.right : j.right, E = x - C, I = z - N;
            return {
              top: N,
              bottom: z,
              left: C,
              right: x,
              width: E,
              height: I,
              x: C,
              y: N
            };
          }
          const w = Ye(e) === "left", _ = at(...f.map((P) => P.right)), k = lt(...f.map((P) => P.left)), g = f.filter((P) => w ? P.left === k : P.right === _), $ = g[0].top, y = g[g.length - 1].bottom, A = k, S = _, Y = S - A, K = y - $;
          return {
            top: $,
            bottom: y,
            left: A,
            right: S,
            width: Y,
            height: K,
            x: A,
            y: $
          };
        }
        return p;
      }
      const B = await n.getElementRects({
        reference: {
          getBoundingClientRect: m
        },
        floating: l.floating,
        strategy: r
      });
      return a.reference.x !== B.reference.x || a.reference.y !== B.reference.y || a.reference.width !== B.reference.width || a.reference.height !== B.reference.height ? {
        reset: {
          rects: B
        }
      } : {};
    }
  };
};
async function Gs(t, o) {
  const {
    placement: e,
    platform: l,
    elements: a
  } = t, n = await (l.isRTL == null ? void 0 : l.isRTL(a.floating)), r = Ye(e), u = et(e), i = Rt(e) === "y", d = ["left", "top"].includes(r) ? -1 : 1, c = n && i ? -1 : 1, f = ct(o, t);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f
  };
  return u && typeof m == "number" && (v = u === "end" ? m * -1 : m), i ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
const Bo = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(o) {
      var e, l;
      const {
        x: a,
        y: n,
        placement: r,
        middlewareData: u
      } = o, i = await Gs(o, t);
      return r === ((e = u.offset) == null ? void 0 : e.placement) && (l = u.arrow) != null && l.alignmentOffset ? {} : {
        x: a + i.x,
        y: n + i.y,
        data: {
          ...i,
          placement: r
        }
      };
    }
  };
}, _o = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(o) {
      const {
        x: e,
        y: l,
        placement: a
      } = o, {
        mainAxis: n = !0,
        crossAxis: r = !1,
        limiter: u = {
          fn: (w) => {
            let {
              x: _,
              y: k
            } = w;
            return {
              x: _,
              y: k
            };
          }
        },
        ...i
      } = ct(t, o), d = {
        x: e,
        y: l
      }, c = await It(o, i), f = Rt(Ye(a)), p = bo(f);
      let v = d[p], m = d[f];
      if (n) {
        const w = p === "y" ? "top" : "left", _ = p === "y" ? "bottom" : "right", k = v + c[w], g = v - c[_];
        v = Ra(k, v, g);
      }
      if (r) {
        const w = f === "y" ? "top" : "left", _ = f === "y" ? "bottom" : "right", k = m + c[w], g = m - c[_];
        m = Ra(k, m, g);
      }
      const B = u.fn({
        ...o,
        [p]: v,
        [f]: m
      });
      return {
        ...B,
        data: {
          x: B.x - e,
          y: B.y - l
        }
      };
    }
  };
}, wo = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(o) {
      const {
        placement: e,
        rects: l,
        platform: a,
        elements: n
      } = o, {
        apply: r = () => {
        },
        ...u
      } = ct(t, o), i = await It(o, u), d = Ye(e), c = et(e), f = Rt(e) === "y", {
        width: p,
        height: v
      } = l.floating;
      let m, B;
      d === "top" || d === "bottom" ? (m = d, B = c === (await (a.isRTL == null ? void 0 : a.isRTL(n.floating)) ? "start" : "end") ? "left" : "right") : (B = d, m = c === "end" ? "top" : "bottom");
      const w = v - i.top - i.bottom, _ = p - i.left - i.right, k = lt(v - i[m], w), g = lt(p - i[B], _), $ = !o.middlewareData.shift;
      let y = k, A = g;
      if (f ? A = c || $ ? lt(g, _) : _ : y = c || $ ? lt(k, w) : w, $ && !c) {
        const Y = at(i.left, 0), K = at(i.right, 0), P = at(i.top, 0), j = at(i.bottom, 0);
        f ? A = p - 2 * (Y !== 0 || K !== 0 ? Y + K : at(i.left, i.right)) : y = v - 2 * (P !== 0 || j !== 0 ? P + j : at(i.top, i.bottom));
      }
      await r({
        ...o,
        availableWidth: A,
        availableHeight: y
      });
      const S = await a.getDimensions(n.floating);
      return p !== S.width || v !== S.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ke(t) {
  var o;
  return ((o = t.ownerDocument) == null ? void 0 : o.defaultView) || window;
}
function ot(t) {
  return Ke(t).getComputedStyle(t);
}
const $l = Math.min, jt = Math.max, ca = Math.round;
function Co(t) {
  const o = ot(t);
  let e = parseFloat(o.width), l = parseFloat(o.height);
  const a = t.offsetWidth, n = t.offsetHeight, r = ca(e) !== a || ca(l) !== n;
  return r && (e = a, l = n), { width: e, height: l, fallback: r };
}
function pt(t) {
  return To(t) ? (t.nodeName || "").toLowerCase() : "";
}
let Qt;
function ko() {
  if (Qt)
    return Qt;
  const t = navigator.userAgentData;
  return t && Array.isArray(t.brands) ? (Qt = t.brands.map((o) => o.brand + "/" + o.version).join(" "), Qt) : navigator.userAgent;
}
function nt(t) {
  return t instanceof Ke(t).HTMLElement;
}
function tt(t) {
  return t instanceof Ke(t).Element;
}
function To(t) {
  return t instanceof Ke(t).Node;
}
function Al(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof Ke(t).ShadowRoot || t instanceof ShadowRoot;
}
function Ta(t) {
  const { overflow: o, overflowX: e, overflowY: l, display: a } = ot(t);
  return /auto|scroll|overlay|hidden|clip/.test(o + l + e) && !["inline", "contents"].includes(a);
}
function qs(t) {
  return ["table", "td", "th"].includes(pt(t));
}
function za(t) {
  const o = /firefox/i.test(ko()), e = ot(t), l = e.backdropFilter || e.WebkitBackdropFilter;
  return e.transform !== "none" || e.perspective !== "none" || !!l && l !== "none" || o && e.willChange === "filter" || o && !!e.filter && e.filter !== "none" || ["transform", "perspective"].some((a) => e.willChange.includes(a)) || ["paint", "layout", "strict", "content"].some((a) => {
    const n = e.contain;
    return n != null && n.includes(a);
  });
}
function So() {
  return !/^((?!chrome|android).)*safari/i.test(ko());
}
function sl(t) {
  return ["html", "body", "#document"].includes(pt(t));
}
function xo(t) {
  return tt(t) ? t : t.contextElement;
}
const $o = { x: 1, y: 1 };
function Pt(t) {
  const o = xo(t);
  if (!nt(o))
    return $o;
  const e = o.getBoundingClientRect(), { width: l, height: a, fallback: n } = Co(o);
  let r = (n ? ca(e.width) : e.width) / l, u = (n ? ca(e.height) : e.height) / a;
  return r && Number.isFinite(r) || (r = 1), u && Number.isFinite(u) || (u = 1), { x: r, y: u };
}
function gt(t, o, e, l) {
  var a, n;
  o === void 0 && (o = !1), e === void 0 && (e = !1);
  const r = t.getBoundingClientRect(), u = xo(t);
  let i = $o;
  o && (l ? tt(l) && (i = Pt(l)) : i = Pt(t));
  const d = u ? Ke(u) : window, c = !So() && e;
  let f = (r.left + (c && ((a = d.visualViewport) == null ? void 0 : a.offsetLeft) || 0)) / i.x, p = (r.top + (c && ((n = d.visualViewport) == null ? void 0 : n.offsetTop) || 0)) / i.y, v = r.width / i.x, m = r.height / i.y;
  if (u) {
    const B = Ke(u), w = l && tt(l) ? Ke(l) : l;
    let _ = B.frameElement;
    for (; _ && l && w !== B; ) {
      const k = Pt(_), g = _.getBoundingClientRect(), $ = getComputedStyle(_);
      g.x += (_.clientLeft + parseFloat($.paddingLeft)) * k.x, g.y += (_.clientTop + parseFloat($.paddingTop)) * k.y, f *= k.x, p *= k.y, v *= k.x, m *= k.y, f += g.x, p += g.y, _ = Ke(_).frameElement;
    }
  }
  return { width: v, height: m, top: p, right: f + v, bottom: p + m, left: f, x: f, y: p };
}
function ft(t) {
  return ((To(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function Sa(t) {
  return tt(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function Ao(t) {
  return gt(ft(t)).left + Sa(t).scrollLeft;
}
function Wt(t) {
  if (pt(t) === "html")
    return t;
  const o = t.assignedSlot || t.parentNode || Al(t) && t.host || ft(t);
  return Al(o) ? o.host : o;
}
function Vo(t) {
  const o = Wt(t);
  return sl(o) ? o.ownerDocument.body : nt(o) && Ta(o) ? o : Vo(o);
}
function Gt(t, o) {
  var e;
  o === void 0 && (o = []);
  const l = Vo(t), a = l === ((e = t.ownerDocument) == null ? void 0 : e.body), n = Ke(l);
  return a ? o.concat(n, n.visualViewport || [], Ta(l) ? l : []) : o.concat(l, Gt(l));
}
function Vl(t, o, e) {
  return o === "viewport" ? yt(function(l, a) {
    const n = Ke(l), r = ft(l), u = n.visualViewport;
    let i = r.clientWidth, d = r.clientHeight, c = 0, f = 0;
    if (u) {
      i = u.width, d = u.height;
      const p = So();
      (p || !p && a === "fixed") && (c = u.offsetLeft, f = u.offsetTop);
    }
    return { width: i, height: d, x: c, y: f };
  }(t, e)) : tt(o) ? yt(function(l, a) {
    const n = gt(l, !0, a === "fixed"), r = n.top + l.clientTop, u = n.left + l.clientLeft, i = nt(l) ? Pt(l) : { x: 1, y: 1 };
    return { width: l.clientWidth * i.x, height: l.clientHeight * i.y, x: u * i.x, y: r * i.y };
  }(o, e)) : yt(function(l) {
    const a = ft(l), n = Sa(l), r = l.ownerDocument.body, u = jt(a.scrollWidth, a.clientWidth, r.scrollWidth, r.clientWidth), i = jt(a.scrollHeight, a.clientHeight, r.scrollHeight, r.clientHeight);
    let d = -n.scrollLeft + Ao(l);
    const c = -n.scrollTop;
    return ot(r).direction === "rtl" && (d += jt(a.clientWidth, r.clientWidth) - u), { width: u, height: i, x: d, y: c };
  }(ft(t)));
}
function Fl(t) {
  return nt(t) && ot(t).position !== "fixed" ? t.offsetParent : null;
}
function Nl(t) {
  const o = Ke(t);
  let e = Fl(t);
  for (; e && qs(e) && ot(e).position === "static"; )
    e = Fl(e);
  return e && (pt(e) === "html" || pt(e) === "body" && ot(e).position === "static" && !za(e)) ? o : e || function(l) {
    let a = Wt(l);
    for (; nt(a) && !sl(a); ) {
      if (za(a))
        return a;
      a = Wt(a);
    }
    return null;
  }(t) || o;
}
function Ws(t, o, e) {
  const l = nt(o), a = ft(o), n = gt(t, !0, e === "fixed", o);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const u = { x: 0, y: 0 };
  if (l || !l && e !== "fixed")
    if ((pt(o) !== "body" || Ta(a)) && (r = Sa(o)), nt(o)) {
      const i = gt(o, !0);
      u.x = i.x + o.clientLeft, u.y = i.y + o.clientTop;
    } else
      a && (u.x = Ao(a));
  return { x: n.left + r.scrollLeft - u.x, y: n.top + r.scrollTop - u.y, width: n.width, height: n.height };
}
const Us = { getClippingRect: function(t) {
  let { element: o, boundary: e, rootBoundary: l, strategy: a } = t;
  const n = e === "clippingAncestors" ? function(d, c) {
    const f = c.get(d);
    if (f)
      return f;
    let p = Gt(d).filter((w) => tt(w) && pt(w) !== "body"), v = null;
    const m = ot(d).position === "fixed";
    let B = m ? Wt(d) : d;
    for (; tt(B) && !sl(B); ) {
      const w = ot(B), _ = za(B);
      (m ? _ || v : _ || w.position !== "static" || !v || !["absolute", "fixed"].includes(v.position)) ? v = w : p = p.filter((k) => k !== B), B = Wt(B);
    }
    return c.set(d, p), p;
  }(o, this._c) : [].concat(e), r = [...n, l], u = r[0], i = r.reduce((d, c) => {
    const f = Vl(o, c, a);
    return d.top = jt(f.top, d.top), d.right = $l(f.right, d.right), d.bottom = $l(f.bottom, d.bottom), d.left = jt(f.left, d.left), d;
  }, Vl(o, u, a));
  return { width: i.right - i.left, height: i.bottom - i.top, x: i.left, y: i.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
  let { rect: o, offsetParent: e, strategy: l } = t;
  const a = nt(e), n = ft(e);
  if (e === n)
    return o;
  let r = { scrollLeft: 0, scrollTop: 0 }, u = { x: 1, y: 1 };
  const i = { x: 0, y: 0 };
  if ((a || !a && l !== "fixed") && ((pt(e) !== "body" || Ta(n)) && (r = Sa(e)), nt(e))) {
    const d = gt(e);
    u = Pt(e), i.x = d.x + e.clientLeft, i.y = d.y + e.clientTop;
  }
  return { width: o.width * u.x, height: o.height * u.y, x: o.x * u.x - r.scrollLeft * u.x + i.x, y: o.y * u.y - r.scrollTop * u.y + i.y };
}, isElement: tt, getDimensions: function(t) {
  return nt(t) ? Co(t) : t.getBoundingClientRect();
}, getOffsetParent: Nl, getDocumentElement: ft, getScale: Pt, async getElementRects(t) {
  let { reference: o, floating: e, strategy: l } = t;
  const a = this.getOffsetParent || Nl, n = this.getDimensions;
  return { reference: Ws(o, await a(e), l), floating: { x: 0, y: 0, ...await n(e) } };
}, getClientRects: (t) => Array.from(t.getClientRects()), isRTL: (t) => ot(t).direction === "rtl" };
function Fo(t, o, e, l) {
  l === void 0 && (l = {});
  const { ancestorScroll: a = !0, ancestorResize: n = !0, elementResize: r = !0, animationFrame: u = !1 } = l, i = a && !u, d = i || n ? [...tt(t) ? Gt(t) : t.contextElement ? Gt(t.contextElement) : [], ...Gt(o)] : [];
  d.forEach((v) => {
    i && v.addEventListener("scroll", e, { passive: !0 }), n && v.addEventListener("resize", e);
  });
  let c, f = null;
  if (r) {
    let v = !0;
    f = new ResizeObserver(() => {
      v || e(), v = !1;
    }), tt(t) && !u && f.observe(t), tt(t) || !t.contextElement || u || f.observe(t.contextElement), f.observe(o);
  }
  let p = u ? gt(t) : null;
  return u && function v() {
    const m = gt(t);
    !p || m.x === p.x && m.y === p.y && m.width === p.width && m.height === p.height || e(), p = m, c = requestAnimationFrame(v);
  }(), e(), () => {
    var v;
    d.forEach((m) => {
      i && m.removeEventListener("scroll", e), n && m.removeEventListener("resize", e);
    }), (v = f) == null || v.disconnect(), f = null, u && cancelAnimationFrame(c);
  };
}
const Ks = (t, o, e) => {
  const l = /* @__PURE__ */ new Map(), a = { platform: Us, ...e }, n = { ...a.platform, _c: l };
  return Ls(t, o, { ...a, platform: n });
};
function Xs(t) {
  return No(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Ys(t) {
  var o;
  return (t == null || (o = t.ownerDocument) == null ? void 0 : o.defaultView) || window;
}
function No(t) {
  return t instanceof Node || t instanceof Ys(t).Node;
}
function Zs(t) {
  return t != null && typeof t == "object" && "$el" in t;
}
function Ma(t) {
  if (Zs(t)) {
    const o = t.$el;
    return No(o) && Xs(o) === "#comment" ? null : o;
  }
  return t;
}
function $t(t) {
  return typeof t == "function" ? t() : s(t);
}
function Js(t) {
  return {
    name: "arrow",
    options: t,
    fn(o) {
      const e = Ma($t(t.element));
      return e == null ? {} : Rs({
        element: e,
        padding: t.padding
      }).fn(o);
    }
  };
}
function Oo(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Ol(t, o) {
  const e = Oo(t);
  return Math.round(o * e) / e;
}
function Po(t, o, e) {
  e === void 0 && (e = {});
  const l = e.whileElementsMounted, a = h(() => {
    var S;
    return (S = $t(e.open)) != null ? S : !0;
  }), n = h(() => $t(e.middleware)), r = h(() => {
    var S;
    return (S = $t(e.placement)) != null ? S : "bottom";
  }), u = h(() => {
    var S;
    return (S = $t(e.strategy)) != null ? S : "absolute";
  }), i = h(() => {
    var S;
    return (S = $t(e.transform)) != null ? S : !0;
  }), d = h(() => Ma(t.value)), c = h(() => Ma(o.value)), f = H(0), p = H(0), v = H(u.value), m = H(r.value), B = Ca({}), w = H(!1), _ = h(() => {
    const S = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return S;
    const Y = Ol(c.value, f.value), K = Ol(c.value, p.value);
    return i.value ? {
      ...S,
      transform: "translate(" + Y + "px, " + K + "px)",
      ...Oo(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: Y + "px",
      top: K + "px"
    };
  });
  let k;
  function g() {
    d.value == null || c.value == null || Ks(d.value, c.value, {
      middleware: n.value,
      placement: r.value,
      strategy: u.value
    }).then((S) => {
      f.value = S.x, p.value = S.y, v.value = S.strategy, m.value = S.placement, B.value = S.middlewareData, w.value = !0;
    });
  }
  function $() {
    typeof k == "function" && (k(), k = void 0);
  }
  function y() {
    if ($(), l === void 0) {
      g();
      return;
    }
    if (d.value != null && c.value != null) {
      k = l(d.value, c.value, g);
      return;
    }
  }
  function A() {
    a.value || (w.value = !1);
  }
  return de([n, r, u], g, {
    flush: "sync"
  }), de([d, c], y, {
    flush: "sync"
  }), de(a, A, {
    flush: "sync"
  }), uo() && co($), {
    x: Tt(f),
    y: Tt(p),
    strategy: Tt(v),
    placement: Tt(m),
    middlewareData: Tt(B),
    isPositioned: Tt(w),
    floatingStyles: _,
    update: g
  };
}
const Qs = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), er = /^aria-[\w-]*$/i, tr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, ar = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, lr = (t, o) => {
  const e = t.nodeName.toLowerCase();
  return o.includes(e) ? Qs.has(e) ? !!(tr.test(t.nodeValue || "") || ar.test(t.nodeValue || "")) : !0 : o.filter((l) => l instanceof RegExp).some((l) => l.test(e));
}, Ft = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", er],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, Nt = (t, o, e) => {
  if (!t.length)
    return t;
  if (e && typeof e == "function")
    return e(t);
  const a = new window.DOMParser().parseFromString(t, "text/html"), n = a.body.querySelectorAll("*");
  for (const r of n) {
    const u = r.nodeName.toLowerCase();
    if (!Object.keys(o).includes(u)) {
      r.remove();
      continue;
    }
    const i = r.attributes, d = [...o["*"] || [], ...o[u] || []];
    for (const c of i)
      lr(c, d) || r.removeAttribute(c.nodeName);
  }
  return a.body.innerHTML;
};
function rt(t) {
  return uo() ? (co(t), !0) : !1;
}
function or(t, o) {
  if (typeof Symbol < "u") {
    const e = { ...t };
    return Object.defineProperty(e, Symbol.iterator, {
      enumerable: !1,
      value() {
        let l = 0;
        return {
          next: () => ({
            value: o[l++],
            done: l > o.length
          })
        };
      }
    }), e;
  } else
    return Object.assign([...o], t);
}
function Ee(t) {
  return typeof t == "function" ? t() : s(t);
}
const fa = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Io = (t) => t != null, nr = Object.prototype.toString, sr = (t) => nr.call(t) === "[object Object]", Xe = () => {
}, Ha = /* @__PURE__ */ rr();
function rr() {
  var t, o;
  return fa && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((o = window == null ? void 0 : window.navigator) == null ? void 0 : o.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Eo(t, o) {
  function e(...l) {
    return new Promise((a, n) => {
      Promise.resolve(t(() => o.apply(this, l), { fn: o, thisArg: this, args: l })).then(a).catch(n);
    });
  }
  return e;
}
const Lo = (t) => t();
function ir(t, o = {}) {
  let e, l, a = Xe;
  const n = (u) => {
    clearTimeout(u), a(), a = Xe;
  };
  return (u) => {
    const i = Ee(t), d = Ee(o.maxWait);
    return e && n(e), i <= 0 || d !== void 0 && d <= 0 ? (l && (n(l), l = null), Promise.resolve(u())) : new Promise((c, f) => {
      a = o.rejectOnCancel ? f : c, d && !l && (l = setTimeout(() => {
        e && n(e), l = null, c(u());
      }, d)), e = setTimeout(() => {
        l && n(l), l = null, c(u());
      }, i);
    });
  };
}
function ur(t = Lo) {
  const o = H(!0);
  function e() {
    o.value = !1;
  }
  function l() {
    o.value = !0;
  }
  const a = (...n) => {
    o.value && t(...n);
  };
  return { isActive: Oe(o), pause: e, resume: l, eventFilter: a };
}
function dr(t) {
  const o = /* @__PURE__ */ Object.create(null);
  return (e) => o[e] || (o[e] = t(e));
}
const cr = /-(\w)/g, fr = dr((t) => t.replace(cr, (o, e) => e ? e.toUpperCase() : ""));
function vr(t, o) {
  var e;
  if (typeof t == "number")
    return t + o;
  const l = ((e = t.match(/^-?\d+\.?\d*/)) == null ? void 0 : e[0]) || "", a = t.slice(l.length), n = Number.parseFloat(l) + o;
  return Number.isNaN(n) ? t : n + a;
}
function pr(t) {
  return t || Bt();
}
function Ro(...t) {
  if (t.length !== 1)
    return T(...t);
  const o = t[0];
  return typeof o == "function" ? Oe(gs(() => ({ get: o, set: Xe }))) : H(o);
}
function mr(t, o = 200, e = {}) {
  return Eo(
    ir(o, e),
    t
  );
}
function br(t, o, e = {}) {
  const {
    eventFilter: l = Lo,
    ...a
  } = e;
  return de(
    t,
    Eo(
      l,
      o
    ),
    a
  );
}
function Da(t, o, e = {}) {
  const {
    eventFilter: l,
    ...a
  } = e, { eventFilter: n, pause: r, resume: u, isActive: i } = ur(l);
  return { stop: br(
    t,
    o,
    {
      ...a,
      eventFilter: n
    }
  ), pause: r, resume: u, isActive: i };
}
function ja(t, o, ...[e]) {
  const {
    flush: l = "sync",
    deep: a = !1,
    immediate: n = !0,
    direction: r = "both",
    transform: u = {}
  } = e || {}, i = [], d = "ltr" in u && u.ltr || ((p) => p), c = "rtl" in u && u.rtl || ((p) => p);
  return (r === "both" || r === "ltr") && i.push(Da(
    t,
    (p) => {
      i.forEach((v) => v.pause()), o.value = d(p), i.forEach((v) => v.resume());
    },
    { flush: l, deep: a, immediate: n }
  )), (r === "both" || r === "rtl") && i.push(Da(
    o,
    (p) => {
      i.forEach((v) => v.pause()), t.value = c(p), i.forEach((v) => v.resume());
    },
    { flush: l, deep: a, immediate: n }
  )), () => {
    i.forEach((p) => p.stop());
  };
}
function zo(t, o = !0, e) {
  pr() ? He(t, e) : o ? t() : Ne(t);
}
function Mo(t, o = 1e3, e = {}) {
  const {
    immediate: l = !0,
    immediateCallback: a = !1
  } = e;
  let n = null;
  const r = H(!1);
  function u() {
    n && (clearInterval(n), n = null);
  }
  function i() {
    r.value = !1, u();
  }
  function d() {
    const c = Ee(o);
    c <= 0 || (r.value = !0, a && t(), u(), n = setInterval(t, c));
  }
  if (l && fa && d(), ys(o) || typeof o == "function") {
    const c = de(o, () => {
      r.value && fa && d();
    });
    rt(c);
  }
  return rt(i), {
    isActive: r,
    pause: i,
    resume: d
  };
}
function Be(t, o = {}) {
  const {
    method: e = "parseFloat",
    radix: l,
    nanToZero: a
  } = o;
  return h(() => {
    let n = Ee(t);
    return typeof n == "string" && (n = Number[e](n, l)), a && Number.isNaN(n) && (n = 0), n;
  });
}
function va(t = {}) {
  const {
    inheritAttrs: o = !0
  } = t, e = Ca(), l = /* @__PURE__ */ G({
    setup(n, { slots: r }) {
      return () => {
        e.value = r.default;
      };
    }
  }), a = /* @__PURE__ */ G({
    inheritAttrs: o,
    setup(n, { attrs: r, slots: u }) {
      return () => {
        var i;
        if (!e.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const d = (i = e.value) == null ? void 0 : i.call(e, { ...yr(r), $slots: u });
        return o && (d == null ? void 0 : d.length) === 1 ? d[0] : d;
      };
    }
  });
  return or(
    { define: l, reuse: a },
    [l, a]
  );
}
function yr(t) {
  const o = {};
  for (const e in t)
    o[fr(e)] = t[e];
  return o;
}
function Le(t) {
  var o;
  const e = Ee(t);
  return (o = e == null ? void 0 : e.$el) != null ? o : e;
}
const Me = fa ? window : void 0;
function $e(...t) {
  let o, e, l, a;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([e, l, a] = t, o = Me) : [o, e, l, a] = t, !o)
    return Xe;
  Array.isArray(e) || (e = [e]), Array.isArray(l) || (l = [l]);
  const n = [], r = () => {
    n.forEach((c) => c()), n.length = 0;
  }, u = (c, f, p, v) => (c.addEventListener(f, p, v), () => c.removeEventListener(f, p, v)), i = de(
    () => [Le(o), Ee(a)],
    ([c, f]) => {
      if (r(), !c)
        return;
      const p = sr(f) ? { ...f } : f;
      n.push(
        ...e.flatMap((v) => l.map((m) => u(c, v, m, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    i(), r();
  };
  return rt(d), d;
}
let Pl = !1;
function Ho(t, o, e = {}) {
  const { window: l = Me, ignore: a = [], capture: n = !0, detectIframe: r = !1 } = e;
  if (!l)
    return Xe;
  Ha && !Pl && (Pl = !0, Array.from(l.document.body.children).forEach((p) => p.addEventListener("click", Xe)), l.document.documentElement.addEventListener("click", Xe));
  let u = !0;
  const i = (p) => a.some((v) => {
    if (typeof v == "string")
      return Array.from(l.document.querySelectorAll(v)).some((m) => m === p.target || p.composedPath().includes(m));
    {
      const m = Le(v);
      return m && (p.target === m || p.composedPath().includes(m));
    }
  }), c = [
    $e(l, "click", (p) => {
      const v = Le(t);
      if (!(!v || v === p.target || p.composedPath().includes(v))) {
        if (p.detail === 0 && (u = !i(p)), !u) {
          u = !0;
          return;
        }
        o(p);
      }
    }, { passive: !0, capture: n }),
    $e(l, "pointerdown", (p) => {
      const v = Le(t);
      u = !i(p) && !!(v && !p.composedPath().includes(v));
    }, { passive: !0 }),
    r && $e(l, "blur", (p) => {
      setTimeout(() => {
        var v;
        const m = Le(t);
        ((v = l.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(m != null && m.contains(l.document.activeElement)) && o(p);
      }, 0);
    })
  ].filter(Boolean);
  return () => c.forEach((p) => p());
}
function gr(t) {
  return typeof t == "function" ? t : typeof t == "string" ? (o) => o.key === t : Array.isArray(t) ? (o) => t.includes(o.key) : () => !0;
}
function qe(...t) {
  let o, e, l = {};
  t.length === 3 ? (o = t[0], e = t[1], l = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (o = !0, e = t[0], l = t[1]) : (o = t[0], e = t[1]) : (o = !0, e = t[0]);
  const {
    target: a = Me,
    eventName: n = "keydown",
    passive: r = !1,
    dedupe: u = !1
  } = l, i = gr(o);
  return $e(a, n, (c) => {
    c.repeat && Ee(u) || i(c) && e(c);
  }, r);
}
function hr() {
  const t = H(!1), o = Bt();
  return o && He(() => {
    t.value = !0;
  }, o), t;
}
function rl(t) {
  const o = hr();
  return h(() => (o.value, !!t()));
}
function Do(t, o, e = {}) {
  const { window: l = Me, ...a } = e;
  let n;
  const r = rl(() => l && "MutationObserver" in l), u = () => {
    n && (n.disconnect(), n = void 0);
  }, i = h(() => {
    const p = Ee(t), v = (Array.isArray(p) ? p : [p]).map(Le).filter(Io);
    return new Set(v);
  }), d = de(
    () => i.value,
    (p) => {
      u(), r.value && p.size && (n = new MutationObserver(o), p.forEach((v) => n.observe(v, a)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => n == null ? void 0 : n.takeRecords(), f = () => {
    u(), d();
  };
  return rt(f), {
    isSupported: r,
    stop: f,
    takeRecords: c
  };
}
function At(t, o = {}) {
  const { window: e = Me } = o, l = rl(() => e && "matchMedia" in e && typeof e.matchMedia == "function");
  let a;
  const n = H(!1), r = (d) => {
    n.value = d.matches;
  }, u = () => {
    a && ("removeEventListener" in a ? a.removeEventListener("change", r) : a.removeListener(r));
  }, i = Et(() => {
    l.value && (u(), a = e.matchMedia(Ee(t)), "addEventListener" in a ? a.addEventListener("change", r) : a.addListener(r), n.value = a.matches);
  });
  return rt(() => {
    i(), u(), a = void 0;
  }), n;
}
const Br = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
function _r(t, o = {}) {
  function e(c, f) {
    let p = Ee(t[Ee(c)]);
    return f != null && (p = vr(p, f)), typeof p == "number" && (p = `${p}px`), p;
  }
  const { window: l = Me, strategy: a = "min-width" } = o;
  function n(c) {
    return l ? l.matchMedia(c).matches : !1;
  }
  const r = (c) => At(() => `(min-width: ${e(c)})`, o), u = (c) => At(() => `(max-width: ${e(c)})`, o), i = Object.keys(t).reduce((c, f) => (Object.defineProperty(c, f, {
    get: () => a === "min-width" ? r(f) : u(f),
    enumerable: !0,
    configurable: !0
  }), c), {});
  function d() {
    const c = Object.keys(t).map((f) => [f, r(f)]);
    return h(() => c.filter(([, f]) => f.value).map(([f]) => f));
  }
  return Object.assign(i, {
    greaterOrEqual: r,
    smallerOrEqual: u,
    greater(c) {
      return At(() => `(min-width: ${e(c, 0.1)})`, o);
    },
    smaller(c) {
      return At(() => `(max-width: ${e(c, -0.1)})`, o);
    },
    between(c, f) {
      return At(() => `(min-width: ${e(c)}) and (max-width: ${e(f, -0.1)})`, o);
    },
    isGreater(c) {
      return n(`(min-width: ${e(c, 0.1)})`);
    },
    isGreaterOrEqual(c) {
      return n(`(min-width: ${e(c)})`);
    },
    isSmaller(c) {
      return n(`(max-width: ${e(c, -0.1)})`);
    },
    isSmallerOrEqual(c) {
      return n(`(max-width: ${e(c)})`);
    },
    isInBetween(c, f) {
      return n(`(min-width: ${e(c)}) and (max-width: ${e(f, -0.1)})`);
    },
    current: d,
    active() {
      const c = d();
      return h(() => c.value.length === 0 ? "" : c.value.at(-1));
    }
  });
}
const ea = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ta = "__vueuse_ssr_handlers__", wr = /* @__PURE__ */ Cr();
function Cr() {
  return ta in ea || (ea[ta] = ea[ta] || {}), ea[ta];
}
function il(t, o) {
  return wr[t] || o;
}
function kr(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
const Tr = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, Il = "vueuse-storage";
function Sr(t, o, e, l = {}) {
  var a;
  const {
    flush: n = "pre",
    deep: r = !0,
    listenToStorageChanges: u = !0,
    writeDefaults: i = !0,
    mergeDefaults: d = !1,
    shallow: c,
    window: f = Me,
    eventFilter: p,
    onError: v = (P) => {
      console.error(P);
    },
    initOnMounted: m
  } = l, B = (c ? Ca : H)(typeof o == "function" ? o() : o);
  if (!e)
    try {
      e = il("getDefaultStorage", () => {
        var P;
        return (P = Me) == null ? void 0 : P.localStorage;
      })();
    } catch (P) {
      v(P);
    }
  if (!e)
    return B;
  const w = Ee(o), _ = kr(w), k = (a = l.serializer) != null ? a : Tr[_], { pause: g, resume: $ } = Da(
    B,
    () => A(B.value),
    { flush: n, deep: r, eventFilter: p }
  );
  f && u && zo(() => {
    $e(f, "storage", Y), $e(f, Il, K), m && Y();
  }), m || Y();
  function y(P, j) {
    f && f.dispatchEvent(new CustomEvent(Il, {
      detail: {
        key: t,
        oldValue: P,
        newValue: j,
        storageArea: e
      }
    }));
  }
  function A(P) {
    try {
      const j = e.getItem(t);
      if (P == null)
        y(j, null), e.removeItem(t);
      else {
        const F = k.write(P);
        j !== F && (e.setItem(t, F), y(j, F));
      }
    } catch (j) {
      v(j);
    }
  }
  function S(P) {
    const j = P ? P.newValue : e.getItem(t);
    if (j == null)
      return i && w != null && e.setItem(t, k.write(w)), w;
    if (!P && d) {
      const F = k.read(j);
      return typeof d == "function" ? d(F, w) : _ === "object" && !Array.isArray(F) ? { ...w, ...F } : F;
    } else
      return typeof j != "string" ? j : k.read(j);
  }
  function Y(P) {
    if (!(P && P.storageArea !== e)) {
      if (P && P.key == null) {
        B.value = w;
        return;
      }
      if (!(P && P.key !== t)) {
        g();
        try {
          (P == null ? void 0 : P.newValue) !== k.write(B.value) && (B.value = S(P));
        } catch (j) {
          v(j);
        } finally {
          P ? Ne($) : $();
        }
      }
    }
  }
  function K(P) {
    Y(P.detail);
  }
  return B;
}
function xr(t) {
  return At("(prefers-color-scheme: dark)", t);
}
function $r(t = {}) {
  const {
    selector: o = "html",
    attribute: e = "class",
    initialValue: l = "auto",
    window: a = Me,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: u = !0,
    storageRef: i,
    emitAuto: d,
    disableTransition: c = !0
  } = t, f = {
    auto: "",
    light: "light",
    dark: "dark",
    ...t.modes || {}
  }, p = xr({ window: a }), v = h(() => p.value ? "dark" : "light"), m = i || (r == null ? Ro(l) : Sr(r, l, n, { window: a, listenToStorageChanges: u })), B = h(() => m.value === "auto" ? v.value : m.value), w = il(
    "updateHTMLAttrs",
    ($, y, A) => {
      const S = typeof $ == "string" ? a == null ? void 0 : a.document.querySelector($) : Le($);
      if (!S)
        return;
      let Y;
      if (c && (Y = a.document.createElement("style"), Y.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), a.document.head.appendChild(Y)), y === "class") {
        const K = A.split(/\s/g);
        Object.values(f).flatMap((P) => (P || "").split(/\s/g)).filter(Boolean).forEach((P) => {
          K.includes(P) ? S.classList.add(P) : S.classList.remove(P);
        });
      } else
        S.setAttribute(y, A);
      c && (a.getComputedStyle(Y).opacity, document.head.removeChild(Y));
    }
  );
  function _($) {
    var y;
    w(o, e, (y = f[$]) != null ? y : $);
  }
  function k($) {
    t.onChanged ? t.onChanged($, _) : _($);
  }
  de(B, k, { flush: "post", immediate: !0 }), zo(() => k(B.value));
  const g = h({
    get() {
      return d ? m.value : B.value;
    },
    set($) {
      m.value = $;
    }
  });
  try {
    return Object.assign(g, { store: m, system: v, state: B });
  } catch {
    return g;
  }
}
function ul(t, o = {}) {
  const {
    delayEnter: e = 0,
    delayLeave: l = 0,
    window: a = Me
  } = o, n = H(!1);
  let r;
  const u = (i) => {
    const d = i ? e : l;
    r && (clearTimeout(r), r = void 0), d ? r = setTimeout(() => n.value = i, d) : n.value = i;
  };
  return a && ($e(t, "mouseenter", () => u(!0), { passive: !0 }), $e(t, "mouseleave", () => u(!1), { passive: !0 })), n;
}
function Ar(t, o, e = {}) {
  const {
    root: l,
    rootMargin: a = "0px",
    threshold: n = 0.1,
    window: r = Me,
    immediate: u = !0
  } = e, i = rl(() => r && "IntersectionObserver" in r), d = h(() => {
    const m = Ee(t);
    return (Array.isArray(m) ? m : [m]).map(Le).filter(Io);
  });
  let c = Xe;
  const f = H(u), p = i.value ? de(
    () => [d.value, Le(l), f.value],
    ([m, B]) => {
      if (c(), !f.value || !m.length)
        return;
      const w = new IntersectionObserver(
        o,
        {
          root: Le(B),
          rootMargin: a,
          threshold: n
        }
      );
      m.forEach((_) => _ && w.observe(_)), c = () => {
        w.disconnect(), c = Xe;
      };
    },
    { immediate: u, flush: "post" }
  ) : Xe, v = () => {
    c(), p(), f.value = !1;
  };
  return rt(v), {
    isSupported: i,
    isActive: f,
    pause() {
      c(), f.value = !1;
    },
    resume() {
      f.value = !0;
    },
    stop: v
  };
}
function Re(t, o = {}) {
  const { initialValue: e = !1, focusVisible: l = !1, preventScroll: a = !1 } = o, n = H(!1), r = h(() => Le(t));
  $e(r, "focus", (i) => {
    var d, c;
    (!l || (c = (d = i.target).matches) != null && c.call(d, ":focus-visible")) && (n.value = !0);
  }), $e(r, "blur", () => n.value = !1);
  const u = h({
    get: () => n.value,
    set(i) {
      var d, c;
      !i && n.value ? (d = r.value) == null || d.blur() : i && !n.value && ((c = r.value) == null || c.focus({ preventScroll: a }));
    }
  });
  return de(
    r,
    () => {
      u.value = e;
    },
    { immediate: !0, flush: "post" }
  ), { focused: u };
}
function Fa(t) {
  return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t;
}
const Vr = {
  page: (t) => [t.pageX, t.pageY],
  client: (t) => [t.clientX, t.clientY],
  screen: (t) => [t.screenX, t.screenY],
  movement: (t) => t instanceof Touch ? null : [t.movementX, t.movementY]
};
function Fr(t = {}) {
  const {
    type: o = "page",
    touch: e = !0,
    resetOnTouchEnds: l = !1,
    initialValue: a = { x: 0, y: 0 },
    window: n = Me,
    target: r = n,
    scroll: u = !0,
    eventFilter: i
  } = t;
  let d = null;
  const c = H(a.x), f = H(a.y), p = H(null), v = typeof o == "function" ? o : Vr[o], m = (y) => {
    const A = v(y);
    d = y, A && ([c.value, f.value] = A, p.value = "mouse");
  }, B = (y) => {
    if (y.touches.length > 0) {
      const A = v(y.touches[0]);
      A && ([c.value, f.value] = A, p.value = "touch");
    }
  }, w = () => {
    if (!d || !n)
      return;
    const y = v(d);
    d instanceof MouseEvent && y && (c.value = y[0] + n.scrollX, f.value = y[1] + n.scrollY);
  }, _ = () => {
    c.value = a.x, f.value = a.y;
  }, k = i ? (y) => i(() => m(y), {}) : (y) => m(y), g = i ? (y) => i(() => B(y), {}) : (y) => B(y), $ = i ? () => i(() => w(), {}) : () => w();
  if (r) {
    const y = { passive: !0 };
    $e(r, ["mousemove", "dragover"], k, y), e && o !== "movement" && ($e(r, ["touchstart", "touchmove"], g, y), l && $e(r, "touchend", _, y)), u && o === "page" && $e(n, "scroll", $, { passive: !0 });
  }
  return {
    x: c,
    y: f,
    sourceType: p
  };
}
function El(t, o = {}) {
  const {
    handleOutside: e = !0,
    window: l = Me
  } = o, a = o.type || "page", { x: n, y: r, sourceType: u } = Fr(o), i = H(t ?? (l == null ? void 0 : l.document.body)), d = H(0), c = H(0), f = H(0), p = H(0), v = H(0), m = H(0), B = H(!0);
  let w = () => {
  };
  return l && (w = de(
    [i, n, r],
    () => {
      const _ = Le(i);
      if (!_)
        return;
      const {
        left: k,
        top: g,
        width: $,
        height: y
      } = _.getBoundingClientRect();
      f.value = k + (a === "page" ? l.pageXOffset : 0), p.value = g + (a === "page" ? l.pageYOffset : 0), v.value = y, m.value = $;
      const A = n.value - f.value, S = r.value - p.value;
      B.value = $ === 0 || y === 0 || A < 0 || S < 0 || A > $ || S > y, (e || !B.value) && (d.value = A, c.value = S);
    },
    { immediate: !0 }
  ), $e(document, "mouseleave", () => {
    B.value = !0;
  })), {
    x: n,
    y: r,
    sourceType: u,
    elementX: d,
    elementY: c,
    elementPositionX: f,
    elementPositionY: p,
    elementHeight: v,
    elementWidth: m,
    isOutside: B,
    stop: w
  };
}
function jo(t) {
  const o = window.getComputedStyle(t);
  if (o.overflowX === "scroll" || o.overflowY === "scroll" || o.overflowX === "auto" && t.clientWidth < t.scrollWidth || o.overflowY === "auto" && t.clientHeight < t.scrollHeight)
    return !0;
  {
    const e = t.parentNode;
    return !e || e.tagName === "BODY" ? !1 : jo(e);
  }
}
function Nr(t) {
  const o = t || window.event, e = o.target;
  return jo(e) ? !1 : o.touches.length > 1 ? !0 : (o.preventDefault && o.preventDefault(), !1);
}
const Na = /* @__PURE__ */ new WeakMap();
function Or(t, o = !1) {
  const e = H(o);
  let l = null, a = "";
  de(Ro(t), (u) => {
    const i = Fa(Ee(u));
    if (i) {
      const d = i;
      if (Na.get(d) || Na.set(d, d.style.overflow), d.style.overflow !== "hidden" && (a = d.style.overflow), d.style.overflow === "hidden")
        return e.value = !0;
      if (e.value)
        return d.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const n = () => {
    const u = Fa(Ee(t));
    !u || e.value || (Ha && (l = $e(
      u,
      "touchmove",
      (i) => {
        Nr(i);
      },
      { passive: !1 }
    )), u.style.overflow = "hidden", e.value = !0);
  }, r = () => {
    const u = Fa(Ee(t));
    !u || !e.value || (Ha && (l == null || l()), u.style.overflow = a, Na.delete(u), e.value = !1);
  };
  return rt(r), h({
    get() {
      return e.value;
    },
    set(u) {
      u ? n() : r();
    }
  });
}
function Pr(t, o = {}) {
  const {
    threshold: e = 50,
    onSwipe: l,
    onSwipeEnd: a,
    onSwipeStart: n,
    passive: r = !0,
    window: u = Me
  } = o, i = _l({ x: 0, y: 0 }), d = _l({ x: 0, y: 0 }), c = h(() => i.x - d.x), f = h(() => i.y - d.y), { max: p, abs: v } = Math, m = h(() => p(v(c.value), v(f.value)) >= e), B = H(!1), w = h(() => m.value ? v(c.value) > v(f.value) ? c.value > 0 ? "left" : "right" : f.value > 0 ? "up" : "down" : "none"), _ = (K) => [K.touches[0].clientX, K.touches[0].clientY], k = (K, P) => {
    i.x = K, i.y = P;
  }, g = (K, P) => {
    d.x = K, d.y = P;
  };
  let $;
  const y = Ir(u == null ? void 0 : u.document);
  r ? $ = y ? { passive: !0 } : { capture: !1 } : $ = y ? { passive: !1, capture: !0 } : { capture: !0 };
  const A = (K) => {
    B.value && (a == null || a(K, w.value)), B.value = !1;
  }, S = [
    $e(t, "touchstart", (K) => {
      if (K.touches.length !== 1)
        return;
      $.capture && !$.passive && K.preventDefault();
      const [P, j] = _(K);
      k(P, j), g(P, j), n == null || n(K);
    }, $),
    $e(t, "touchmove", (K) => {
      if (K.touches.length !== 1)
        return;
      const [P, j] = _(K);
      g(P, j), !B.value && m.value && (B.value = !0), B.value && (l == null || l(K));
    }, $),
    $e(t, ["touchend", "touchcancel"], A, $)
  ];
  return {
    isPassiveEventSupported: y,
    isSwiping: B,
    direction: w,
    coordsStart: i,
    coordsEnd: d,
    lengthX: c,
    lengthY: f,
    stop: () => S.forEach((K) => K())
  };
}
function Ir(t) {
  if (!t)
    return !1;
  let o = !1;
  const e = {
    get passive() {
      return o = !0, !1;
    }
  };
  return t.addEventListener("x", Xe, e), t.removeEventListener("x", Xe), o;
}
const Er = ["id"], Lr = ["id"], Rr = ["innerHTML"], zr = ["innerHTML"], dl = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BPopover",
  props: /* @__PURE__ */ be({
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    click: { type: Boolean, default: !1 },
    closeOnHide: { type: Boolean, default: !1 },
    content: { default: void 0 },
    customClass: { default: "" },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    floatingMiddleware: { default: void 0 },
    html: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    manual: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noHide: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    noninteractive: { type: Boolean, default: !1 },
    offset: { default: null },
    placement: { default: "top" },
    persistent: { type: Boolean, default: !1 },
    realtime: { type: Boolean, default: !1 },
    reference: { default: null },
    strategy: { default: "absolute" },
    target: { default: null },
    title: { default: void 0 },
    tooltip: { type: Boolean, default: !1 },
    variant: { default: null },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BPopover"), n = e, r = we(t, "modelValue"), u = H(r.value), i = H(r.value);
    Et(() => {
      r.value = u.value;
    }), de(r, (q) => {
      q !== u.value && (q ? D() : M(new Event("update:modelValue")));
    });
    const d = Ce(() => a.id, "popover"), c = H(!1), f = H(null), p = H(null), v = H(null), m = H(null), B = H(null), w = h(
      () => a.title ? Nt(a.title, Ft) : ""
    ), _ = h(
      () => a.content ? Nt(a.content, Ft) : ""
    ), k = T(() => a.placement.startsWith("auto")), g = Be(() => a.offset ?? NaN), $ = h(
      () => cl(a.boundary) ? a.boundary : void 0
    ), y = h(
      () => Go(a.boundary) ? a.boundary : void 0
    ), A = H({}), S = h(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const q = a.offset !== null ? g.value : a.tooltip ? 6 : 8, se = [Bo(q)];
      return a.noFlip === !1 && !k.value && se.push(
        go({
          boundary: $.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), k.value && se.push(
        Ms({
          alignment: a.placement.split("-")[1] || void 0,
          boundary: $.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === !1 && se.push(
        _o({
          boundary: $.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.noHide === !1 && se.push(
        Hs({
          boundary: $.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.inline === !0 && se.push(js()), se.push(Js({ element: v, padding: 10 })), a.noSize === !1 && se.push(
        wo({
          boundary: $.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: ie, availableHeight: te }) {
            A.value = {
              maxHeight: te ? `${te}px` : void 0,
              maxWidth: ie ? `${ie}px` : void 0
            };
          }
        })
      ), se;
    }), Y = T(
      () => k.value ? void 0 : a.placement
    ), { floatingStyles: K, middlewareData: P, placement: j, update: F } = Po(p, f, {
      placement: Y,
      middleware: S,
      strategy: T(() => a.strategy),
      whileElementsMounted: (...q) => Fo(...q, { animationFrame: a.realtime })
    }), N = H({ position: "absolute" });
    de(P, (q) => {
      var se;
      if (a.noHide === !1 && (c.value = !!((se = q.hide) != null && se.referenceHidden), a.closeOnHide && c.value && !a.noAutoClose && !a.manual && M(new Event("closeOnHide"))), q.arrow) {
        const { x: ie, y: te } = q.arrow;
        N.value = {
          position: "absolute",
          top: te ? `${te}px` : "",
          left: ie ? `${ie}px` : ""
        };
      }
    });
    const z = h(() => {
      const q = a.tooltip ? "tooltip" : "popover";
      return [
        q,
        `b-${q}`,
        {
          [`b-${q}-${a.variant}`]: a.variant !== null,
          show: u.value && !c.value,
          "pe-none": !u.value,
          fade: !a.noFade,
          "d-none": !u.value && a.noFade,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${q}-${Hr(j.value)}`]: j.value !== void 0
        }
      ];
    }), { isOutside: C } = El(f), { isOutside: x } = El(m), E = (q) => {
      const se = q ?? new Event("click");
      u.value ? M(se) : D();
    }, I = (q, se = {}) => new wt(q, {
      cancelable: !1,
      target: f.value || null,
      relatedTarget: null,
      trigger: null,
      ...se,
      componentId: d.value
    });
    let X;
    const D = () => {
      const q = I("show", { cancelable: !0 });
      if (n("show", q), q.defaultPrevented) {
        n("show-prevented");
        return;
      }
      i.value = !0, Ne(() => {
        var se;
        F(), X = setTimeout(
          () => {
            F(), u.value = !0, Ne(() => {
              n("shown", I("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((se = a.delay) == null ? void 0 : se.show) || 0
        );
      });
    }, M = (q) => {
      var te;
      const se = I("hide", { cancelable: !0 });
      if (n("hide", se), se.defaultPrevented) {
        n("hide-prevented");
        return;
      }
      X && (clearTimeout(X), X = void 0);
      const ie = typeof a.delay == "number" ? a.delay : ((te = a.delay) == null ? void 0 : te.hide) || 0;
      setTimeout(() => {
        var ve, ue;
        (q == null ? void 0 : q.type) === "click" || (q == null ? void 0 : q.type) === "forceHide" || (q == null ? void 0 : q.type) === "closeOnHide" || (q == null ? void 0 : q.type) === "update:modelValue" && a.manual || !a.noninteractive && C.value && x.value && !((ve = f.value) != null && ve.contains(document == null ? void 0 : document.activeElement)) && !((ue = m.value) != null && ue.contains(document == null ? void 0 : document.activeElement)) || a.noninteractive && x.value ? (u.value = !1, Ne(() => {
          setTimeout(
            () => {
              i.value = !1;
            },
            f.value ? La(f.value) : 150
          ), n("hidden", I("hidden"));
        })) : setTimeout(
          () => {
            M(q);
          },
          ie < 50 ? 50 : ie
        );
      }, ie);
    };
    o({
      hide: M,
      show: D,
      toggle: E
    });
    const Q = () => {
      var q;
      if (a.target) {
        const se = mt(a.target);
        se ? m.value = se : console.warn("Target element not found", a.target);
      } else
        m.value = (q = B.value) == null ? void 0 : q.nextElementSibling;
      if (a.reference) {
        const se = mt(a.reference);
        se ? p.value = se : console.warn("Reference element not found", a.reference);
      } else
        p.value = m.value;
      if (!(!m.value || a.manual) && al) {
        if (m.value.addEventListener("forceHide", M), a.click) {
          m.value.addEventListener("click", E);
          return;
        }
        m.value.addEventListener("pointerenter", D), m.value.addEventListener("pointerleave", M), m.value.addEventListener("focus", D), m.value.addEventListener("blur", M);
      }
    }, Z = () => {
      m.value && (m.value.removeEventListener("forceHide", M), m.value.removeEventListener("click", E), m.value.removeEventListener("pointerenter", D), m.value.removeEventListener("pointerleave", M), m.value.removeEventListener("focus", D), m.value.removeEventListener("blur", M));
    };
    return Ho(
      f,
      () => {
        u.value && a.click && !a.noAutoClose && !a.manual && M(new Event("clickOutside"));
      },
      { ignore: [m] }
    ), de([() => a.click, () => a.target, () => a.reference], () => {
      Z(), Q();
    }), He(Q), Qa(Z), (q, se) => (b(), O(pe, null, [
      ae("span", {
        id: s(d) + "_placeholder",
        ref_key: "placeholder",
        ref: B
      }, null, 8, Er),
      V(q.$slots, "target", {
        show: D,
        hide: M,
        toggle: E,
        showState: u.value
      }),
      (b(), L(_t, {
        to: s(a).teleportTo,
        disabled: !s(a).teleportTo || s(a).teleportDisabled
      }, [
        i.value || s(a).persistent ? (b(), O("div", J({
          key: 0,
          id: s(d)
        }, q.$attrs, {
          ref_key: "element",
          ref: f,
          class: z.value,
          role: "tooltip",
          tabindex: "-1",
          style: s(K)
        }), [
          ae("div", {
            ref_key: "arrow",
            ref: v,
            class: W(`${s(a).tooltip ? "tooltip" : "popover"}-arrow`),
            style: ze(N.value),
            "data-popper-arrow": ""
          }, null, 6),
          ae("div", {
            class: "overflow-auto",
            style: ze(A.value)
          }, [
            s(a).title || q.$slots.title ? (b(), O(pe, { key: 0 }, [
              s(a).html ? (b(), O("div", {
                key: 1,
                class: W(["position-sticky top-0", s(a).tooltip ? "tooltip-inner" : "popover-header"]),
                innerHTML: w.value
              }, null, 10, Rr)) : (b(), O("div", {
                key: 0,
                class: W(["position-sticky top-0", s(a).tooltip ? "tooltip-inner" : "popover-header"])
              }, [
                V(q.$slots, "title", {}, () => [
                  ce(oe(s(a).title), 1)
                ])
              ], 2))
            ], 64)) : ne("", !0),
            s(a).tooltip && !q.$slots.title && !s(a).title || !s(a).tooltip ? (b(), O(pe, { key: 1 }, [
              s(a).html ? (b(), O("div", {
                key: 1,
                class: W(s(a).tooltip ? "tooltip-inner" : "popover-body"),
                innerHTML: _.value
              }, null, 10, zr)) : (b(), O("div", {
                key: 0,
                class: W(s(a).tooltip ? "tooltip-inner" : "popover-body")
              }, [
                V(q.$slots, "default", {}, () => [
                  ce(oe(s(a).content), 1)
                ])
              ], 2))
            ], 64)) : ne("", !0)
          ], 4)
        ], 16, Lr)) : ne("", !0)
      ], 8, ["to", "disabled"]))
    ], 64));
  }
}), Mr = ({
  top: t,
  end: o,
  start: e,
  alignCenter: l,
  alignEnd: a
}) => {
  const n = t ? "top" : e ? "left" : o ? "right" : "bottom", r = a ? "end" : l ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
}, Hr = (t) => {
  const [o] = t.split("-");
  switch (o) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return o;
  }
}, Ut = (t) => typeof t != "object" || t.active !== !1, pa = (t, o) => {
  if (!Ut(t))
    return {};
  const l = typeof t > "u" || typeof t == "object" && !t.title && !t.content, a = o.getAttribute("title") || o.getAttribute("data-original-title");
  return l ? a ? (o.removeAttribute("title"), o.setAttribute("data-original-title", a), {
    content: Nt(a, Ft)
  }) : {} : typeof t == "string" ? {
    content: Nt(t, Ft)
  } : {
    title: t != null && t.title ? Nt(t == null ? void 0 : t.title, Ft) : void 0,
    content: t != null && t.content ? Nt(t == null ? void 0 : t.content, Ft) : void 0
  };
}, ma = (t, o) => ({
  target: o,
  modelValue: t.modifiers.show,
  inline: t.modifiers.inline,
  click: t.modifiers.click,
  realtime: t.modifiers.realtime,
  persistent: t.modifiers.persistent,
  placement: t.modifiers.left ? "left" : t.modifiers.right ? "right" : t.modifiers.bottom ? "bottom" : t.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof t.value == "object" ? t.value : {},
  ...t.modifiers.interactive ? { noninteractive: !1 } : {},
  title: null,
  content: null
}), ba = (t, o, e) => {
  var a;
  const l = document.createElement("span");
  o.modifiers.body ? document.body.appendChild(l) : o.modifiers.child ? t.appendChild(l) : (a = t.parentNode) == null || a.insertBefore(l, t.nextSibling), fo(Ie(dl, e), l), t.$__element = l;
}, ya = (t) => {
  const o = t.$__element;
  o && fo(null, o), setTimeout(() => {
    o == null || o.remove();
  }, 0), delete t.$__element;
}, cl = (t) => t === "clippingAncestors" || t instanceof Element || Array.isArray(t), Go = (t) => !cl(t), Ga = (t, o, e) => {
  const l = Fe(t, o);
  return e && typeof e == "function" ? e(l, o, t) : l;
}, la = (t, o, e, l = e) => o.reduce((a, n) => (t[n] && a.push(
  [l, n.replace(e, ""), t[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), a), []), mt = (t) => {
  if (t)
    return typeof t == "string" ? typeof document > "u" ? void 0 : document.getElementById(t) ?? document.querySelector(t) ?? void 0 : t.$el ?? t;
}, Dr = (t, o) => ((t == null ? void 0 : t()) ?? []).reduce((e, l) => (typeof l.type == "symbol" ? e = e.concat(l.children) : e.push(l), e), []).filter((e) => {
  var l;
  return ((l = e.type) == null ? void 0 : l.__name) === o;
}), qo = /_/g, Wo = /([a-z])([A-Z])/g, jr = /^[0-9]*\.?[0-9]+$/, Gr = /(\s|^)(\w)/g, qr = /(\s|^)(\w)/, oa = /\s+/, Wr = /^#/, Ur = /^#[A-Za-z]+[\w\-:.]*$/, Kr = /[-/\\^$*+?.()|[\]{}]/g, Xr = /[\s\uFEFF\xA0]+/g, na = (t) => t.replace(qo, " ").replace(Wo, (o, e, l) => `${e} ${l}`).replace(qr, (o, e, l) => e + l.toUpperCase()), Ll = (t) => t.replace(qo, " ").replace(Wo, (o, e, l) => `${e} ${l}`).replace(Gr, (o, e, l) => e + l.toUpperCase()), Yr = (t) => {
  const o = t.trim();
  return o.charAt(0).toUpperCase() + o.slice(1);
}, Zr = (t) => t.replace(Kr, "\\$&"), Jr = (t) => Zr(t).replace(Xr, "\\s"), sa = (t) => typeof t == "string" ? Ll(t) : t.label !== void 0 ? t.label : typeof t.key == "string" ? Ll(t.key) : t.key, Qr = (t) => !!(t.href || t.to), Uo = Symbol("bvn::carousel"), Ko = Symbol("bvn::tabs"), Xo = Symbol("bvn::progress"), Yo = Symbol("bvn::listGroup"), Zo = Symbol("bvn::avatarGroup"), Jo = Symbol("bvn::accordion"), Qo = Symbol("bvn::checkboxGroup"), en = Symbol("bvn::radioGroup"), fl = Symbol("bvn::collapse"), tn = Symbol("bvn::collapse"), vl = Symbol("bvn::navbar"), an = Symbol("bvn::toastPlugin"), ln = Symbol("bvn::rtlPlugin"), on = Symbol("bvn::breadcrumbPlugin"), nn = Symbol("bvn::modalControllerPlugin"), sn = Symbol("bvn::modalManagerPlugin"), rn = Symbol("bvn::idPluginKey"), ra = Symbol("bvn::defaults"), un = Symbol("bvn::inputGroup"), dn = (t, o) => {
  if (t === null)
    return;
  let e = t;
  if (o.trim && (e = e.toString().trim()), o.number && typeof e == "string" && e !== "") {
    const l = Number.parseFloat(e);
    e = Number.isNaN(l) ? e : l;
  }
  return e;
}, Mt = (t, o = {}, e = {}) => {
  const l = [t];
  let a;
  for (let n = 0; n < l.length && !a; n++) {
    const r = l[n];
    a = e[r];
  }
  return a && typeof a == "function" ? a(o) : a;
}, xa = (t, o) => Object.keys(t).filter((e) => !o.map((l) => l.toString()).includes(e)).reduce((e, l) => ({ ...e, [l]: t[l] }), {}), pl = (t, o) => [...o].reduce(
  (e, l) => (e[l] = t[l], e),
  {}
), Fe = (t, o, e) => {
  const l = o.split(/[.[\]]/g);
  let a = t;
  for (const n of l) {
    if (a === null || a === void 0)
      return e;
    n.trim() !== "" && (a = a[n]);
  }
  return a === void 0 ? e : a;
}, ei = (t, o, e) => {
  const l = (i) => {
    if (((f) => f == null || typeof f != "object" && typeof f != "function")(i))
      return i;
    if (typeof i == "function")
      return i.bind({});
    const c = new i.constructor();
    return Object.getOwnPropertyNames(i).forEach((f) => {
      c[f] = i[f];
    }), c;
  }, a = (i, d) => {
    const c = d === void 0 ? 0 : d;
    if (i == null)
      return c;
    const f = Number.parseInt(i);
    return Number.isNaN(f) ? c : f;
  };
  if (!t)
    return {};
  if (!o || e === void 0)
    return t;
  const n = o.split(/[.[\]]/g).filter((i) => !!i.trim()), r = (i) => {
    if (n.length > 1) {
      const d = n.shift(), c = a(n[0], null) !== null;
      i[d] = i[d] === void 0 ? c ? [] : {} : i[d], r(i[d]);
    } else
      i[n[0]] = e;
  }, u = l(t);
  return r(u), u;
}, Rl = (t, o) => {
  const { all: e, ...l } = t, a = {};
  e && o.forEach((r) => {
    a[r] = e;
  });
  const n = { ...a, ...l };
  return Object.entries(n).filter(([r, u]) => !!u && o.includes(r)).map(([r]) => r);
}, zl = (t, o) => o + (t ? Yr(t) : ""), ti = {
  "top-start": "top-0 start-0",
  "top-center": "top-0 start-50 translate-middle-x",
  "top-end": "top-0 end-0",
  "middle-start": "top-50 start-0 translate-middle-y",
  "middle-center": "top-50 start-50 translate-middle",
  "middle-end": "top-50 end-0 translate-middle-y",
  "bottom-start": "bottom-0 start-0",
  "bottom-center": "bottom-0 start-50 translate-middle-x",
  "bottom-end": "bottom-0 end-0"
}, Ct = (t, o) => {
  const e = T(o), l = T(t), a = T(() => Qr(l.value)), n = h(
    () => a.value ? pl(
      l.value,
      e.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: a, computedLinkProps: n };
}, cn = () => ({ ...Ve(on) }), ai = (t = {}) => {
  const o = t.persist ?? !1, e = "data-bs-theme", l = "body";
  return $r({
    attribute: e,
    selector: l,
    storageKey: o === !0 ? `bv-color-${t.attribute ?? e}-${t.selector ?? l}` : null,
    ...t
  });
}, st = (t) => h(() => {
  let o = xe(t);
  return o = {
    ...o,
    variant: o.variant ?? null,
    bgVariant: o.bgVariant ?? null,
    textVariant: o.textVariant ?? null
  }, {
    [`text-bg-${o.variant}`]: o.variant !== null,
    [`text-${o.textVariant}`]: o.textVariant !== null && o.variant === null,
    [`bg-${o.bgVariant}`]: o.bgVariant !== null && o.variant === null
  };
}), li = (t) => h(() => {
  const o = xe(t);
  return {
    container: o === !0,
    [`container-${o}`]: typeof o == "string"
  };
}), fn = (t, o = H(1e3), e = {}) => {
  const l = Oe(T(t)), a = Oe(T(o)), n = H(!1), r = H(0), u = T(() => Math.ceil(l.value / a.value)), i = T(
    () => f.value || n.value ? Math.round(l.value - r.value * a.value) : 0
  ), { pause: d, resume: c, isActive: f } = Mo(
    () => {
      r.value = r.value + 1;
    },
    o,
    e
  ), p = () => {
    n.value = !1, r.value = 0, c();
  }, v = () => {
    n.value = !1, r.value = u.value;
  };
  Et(() => {
    r.value > u.value && (r.value = u.value), r.value === u.value && d();
  }), de([a, l], () => {
    v(), p();
  });
  const m = () => {
    f.value !== !1 && (n.value = !0, d());
  }, B = () => {
    r.value !== u.value && (n.value = !1, c());
  };
  return {
    isActive: Oe(f),
    isPaused: Oe(n),
    restart: p,
    stop: v,
    pause: m,
    resume: B,
    value: i
  };
};
function oi(t, o = vn("injectSelf")) {
  const { provides: e } = o;
  if (e && t in e)
    return e[t];
}
function vn(t, o) {
  const e = Bt();
  if (!e)
    throw new Error(`[Bvn] ${t} ${o || "must be called from inside a setup function"}`);
  return e;
}
const ni = (t = "") => t.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase(), Ml = (t) => t !== null && typeof t == "object" && !Array.isArray(t);
function pn(t = {}, o = {}, e) {
  const l = {};
  for (const a in t)
    l[a] = t[a];
  for (const a in o) {
    const n = t[a], r = o[a];
    if (Ml(n) && Ml(r)) {
      l[a] = pn(n, r, e);
      continue;
    }
    if (Array.isArray(n) && Array.isArray(r) && e) {
      l[a] = e(n, r);
      continue;
    }
    l[a] = r;
  }
  return l;
}
const si = (t, o) => {
  var e, l;
  return typeof ((e = t.props) == null ? void 0 : e[o]) < "u" || typeof ((l = t.props) == null ? void 0 : l[ni(o)]) < "u";
};
function ri(t = {}, o) {
  const e = Ve(ra, H({})), l = vn("useDefaults");
  if (o = o ?? l.type.name ?? l.type.__name, !o)
    throw new Error("[Bvn] Could not determine component name");
  const a = h(() => {
    var i;
    return (i = e.value) == null ? void 0 : i[t._as ?? o];
  }), n = new Proxy(t, {
    get(i, d) {
      var f, p, v, m;
      const c = Reflect.get(i, d);
      return d === "class" || d === "style" ? [(f = a.value) == null ? void 0 : f[d], c].filter((B) => B != null) : typeof d == "string" && !si(l.vnode, d) ? ((p = a.value) == null ? void 0 : p[d]) ?? ((m = (v = e.value) == null ? void 0 : v.global) == null ? void 0 : m[d]) ?? c : c;
    }
  }), r = Ca();
  Et(() => {
    if (a.value) {
      const i = Object.entries(a.value).filter(
        ([d]) => d.startsWith(d[0].toUpperCase())
      );
      r.value = i.length ? Object.fromEntries(i) : void 0;
    } else
      r.value = void 0;
  });
  function u() {
    const i = oi(ra, l);
    We(
      ra,
      h(
        () => r.value ? pn((i == null ? void 0 : i.value) ?? {}, r.value) : i == null ? void 0 : i.value
      )
    );
  }
  return { props: n, provideSubDefaults: u };
}
function U(t, o) {
  const { props: e, provideSubDefaults: l } = ri(t, o);
  return l(), e;
}
const kt = (t) => h(() => {
  const o = xe(t);
  return o === !0 ? "is-valid" : o === !1 ? "is-invalid" : null;
}), mn = (t) => h(() => {
  const o = xe(t);
  return {
    "form-check": o.plain === !1 && o.button === !1 && o.hasDefaultSlot,
    "form-check-reverse": o.reverse === !0,
    "form-check-inline": o.inline === !0,
    "form-switch": o.switch === !0,
    [`form-control-${o.size}`]: o.size !== void 0 && o.size !== "md" && o.button === !1
  };
}), bn = (t) => {
  const o = T(t), e = kt(() => o.value.state ?? null);
  return h(() => [
    e.value,
    {
      "form-check-input": o.value.plain === !1 && o.value.button === !1,
      "btn-check": o.value.button === !0
    }
  ]);
}, yn = (t) => h(() => {
  const o = xe(t);
  return {
    "form-check-label": o.plain === !1 && o.button === !1,
    btn: o.button === !0,
    [`btn-${o.buttonVariant}`]: o.button === !0 && o.buttonVariant !== void 0 && o.buttonVariant !== null,
    [`btn-${o.size}`]: o.button && o.size && o.size !== "md"
  };
}), gn = (t) => {
  const o = T(t), e = ka(
    () => o.value.ariaInvalid,
    () => o.value.state
  );
  return h(() => ({
    "aria-invalid": e.value,
    "aria-required": o.value.required === !0 ? !0 : void 0
  }));
}, hn = (t) => h(() => {
  const o = xe(t);
  return {
    "was-validated": o.validated === !0,
    "btn-group": o.buttons === !0 && o.stacked === !1,
    "btn-group-vertical": o.stacked === !0 && o.buttons === !0,
    [`btn-group-${o.size}`]: o.size !== void 0
  };
}), Ce = (t, o) => h(() => xe(t) || ii(o)), ii = (t = "") => `__BVID__${Ve(rn, () => Math.random().toString().slice(2, 8))()}___BV_${t}__`, Bn = (t, o, e) => {
  const l = H(null), a = Ce(() => t.id, "input"), n = Be(() => t.debounce ?? 0), r = Be(() => t.debounceMaxWait ?? NaN), u = mr(
    (_) => {
      o.value = _;
    },
    () => e.lazy === !0 ? 0 : n.value,
    { maxWait: () => e.lazy === !0 ? NaN : r.value }
  ), i = (_, k = !1) => {
    e.lazy === !0 && k === !1 || u(_);
  }, { focused: d } = Re(l, {
    initialValue: t.autofocus
  }), c = (_, k, g = !1) => t.formatter !== void 0 && (!t.lazyFormatter || g) ? t.formatter(_, k) : _;
  He(() => {
    var _;
    l.value && (l.value.value = ((_ = o.value) == null ? void 0 : _.toString()) ?? "");
  }), hs(() => {
    Ne(() => {
      t.autofocus && (d.value = !0);
    });
  });
  const f = ka(
    () => t.ariaInvalid,
    () => t.state
  );
  return {
    input: l,
    computedId: a,
    computedAriaInvalid: f,
    onInput: (_) => {
      const { value: k } = _.target, g = c(k, _);
      if (_.defaultPrevented) {
        _.preventDefault();
        return;
      }
      i(g);
    },
    onChange: (_) => {
      const { value: k } = _.target, g = c(k, _);
      if (_.defaultPrevented) {
        _.preventDefault();
        return;
      }
      const $ = g;
      o.value !== $ && i(g, !0);
    },
    onBlur: (_) => {
      if (!e.lazy && !t.lazyFormatter)
        return;
      const { value: k } = _.target, g = c(k, _, !0), $ = g;
      o.value !== $ && i(g, !0);
    },
    focus: () => {
      t.disabled || (d.value = !0);
    },
    blur: () => {
      t.disabled || (d.value = !1);
    }
  };
}, ml = (t, o) => {
  const e = Oe(T(o)), l = Oe(T(t)), a = (i) => typeof i == "object" && i !== null && "label" in i, n = (i) => {
    if (typeof i == "string")
      return { value: i, text: i };
    if (typeof i == "number")
      return { value: i, text: `${i}` };
    if (i instanceof Date)
      return { value: i, text: i.toLocaleString() };
    const d = Fe(i, e.value.valueField), c = Fe(i, e.value.textField), f = Fe(i, e.value.htmlField), p = Fe(i, e.value.disabledField), v = e.value.optionsField ? Fe(i, e.value.optionsField) : void 0;
    return v !== void 0 ? {
      label: Fe(i, e.value.labelField) || c,
      options: v
    } : {
      value: d,
      text: c,
      html: f,
      disabled: p
    };
  }, r = (i) => i.map((d) => n(d));
  return { normalizedOptions: h(() => r(l.value)), isComplex: a };
}, Oa = "modal-open", bl = () => {
  const t = Ve(sn), o = (l) => {
    t == null || t.removeStack(l), t == null || t.removeRegistry(l);
  }, e = il("updateHTMLAttrs", (l, a, n) => {
    const r = typeof l == "string" ? window == null ? void 0 : window.document.querySelector(l) : Le(l);
    r && (a === "class" ? r.classList.toggle(Oa, n === Oa) : r.setAttribute(a, n));
  });
  return rt(() => {
    e("body", "class", "");
  }), de(
    () => t == null ? void 0 : t.countStack.value,
    (l) => {
      l !== void 0 && e("body", "class", l > 0 ? Oa : "");
    }
  ), {
    ...t,
    dispose: o
  };
}, ui = (t, o) => {
  const { pushRegistry: e, pushStack: l, removeStack: a, stack: n, dispose: r, countStack: u } = bl(), i = Bt();
  if (!i || i.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  e == null || e(i), rt(() => {
    r(i);
  });
  const d = (c, f) => {
    c ? l == null || l(i) : f && !c && (a == null || a(i));
  };
  return d(o, o), de(t, d), {
    activePosition: h(
      () => n == null ? void 0 : n.value.findIndex((c) => {
        var f, p;
        return ((f = c.exposed) == null ? void 0 : f.id) === ((p = i.exposed) == null ? void 0 : p.id);
      })
    ),
    activeModalCount: u,
    stackWithoutSelf: h(
      () => (n == null ? void 0 : n.value.filter((c) => {
        var f, p;
        return ((f = c.exposed) == null ? void 0 : f.id) !== ((p = i.exposed) == null ? void 0 : p.id);
      })) ?? []
    )
  };
}, di = (t = void 0) => {
  const { registry: o } = bl(), e = Bt(), l = (r) => r.parent ? r.parent.type.__name === "BModal" ? r.parent : l(r.parent) : null, a = h(() => {
    const r = xe(t);
    return r ? (o == null ? void 0 : o.value.find((u) => {
      var i;
      return ((i = u.exposed) == null ? void 0 : i.id.value) === r;
    })) || null : e ? l(e) : null;
  }), n = T(() => {
    var r;
    return (r = a.value) == null ? void 0 : r.proxy;
  });
  return {
    show() {
      var r, u;
      (u = (r = a.value) == null ? void 0 : r.exposed) == null || u.show();
    },
    hide(r = "") {
      var u, i;
      (i = (u = a.value) == null ? void 0 : u.exposed) == null || i.hide(r);
    },
    modal: n
  };
}, _n = () => {
  const { lastStack: t, stack: o } = bl();
  return {
    ...Ve(nn),
    hide: (n = "") => {
      var r;
      t != null && t.value && ((r = t == null ? void 0 : t.value.exposed) == null || r.hide(n));
    },
    hideAll: (n = "") => {
      o == null || o.value.forEach((r) => {
        var u;
        (u = r.exposed) == null || u.hide(n);
      });
    }
    // Todo: Supports listening events globally in the future
  };
}, ga = (t, o = "px") => h(() => {
  const e = xe(t), l = xe(o);
  return jr.test(String(e)) ? `${Number(e)}${l}` : e;
}), yl = (t) => {
  const o = (e, l) => {
    const a = l === null ? "" : `-${l}`;
    return e === "circle" ? `rounded${a}-circle` : e === "pill" ? `rounded${a}-pill` : typeof e == "number" || e === "0" || e === "1" || e === "2" || e === "3" || e === "4" || e === "5" ? `rounded${a}-${e}` : e === "none" ? `rounded${a}-0` : e === "sm" ? `rounded${a}-1` : e === "lg" ? `rounded${a}-5` : `rounded${a}`;
  };
  return h(() => {
    const e = xe(t);
    return {
      [`${o(e.rounded, null)}`]: !!e.rounded,
      [`${o(e.roundedTop, "top")}`]: !!e.roundedTop,
      [`${o(e.roundedBottom, "bottom")}`]: !!e.roundedBottom,
      [`${o(e.roundedStart, "start")}`]: !!e.roundedStart,
      [`${o(e.roundedEnd, "end")}`]: !!e.roundedEnd
    };
  });
}, ci = () => {
  const t = Ve(ln);
  return He(() => {
    de(
      [() => t == null ? void 0 : t.isRtl.value, () => t == null ? void 0 : t.locale.value],
      ([o, e]) => {
        const l = document.documentElement;
        l.setAttribute("dir", o ?? !1 ? "rtl" : "ltr"), l.setAttribute("lang", e ?? "");
      },
      { immediate: !0 }
    );
  }), { ...t };
}, wn = (t, o) => {
  const e = Oe(T(t)), l = Oe(T(o)), a = T(() => !l.value);
  He(() => {
    const n = Or(
      document.body,
      e.value && a.value
    );
    de([e, a], ([r, u]) => {
      n.value = r && u;
    });
  });
}, Cn = (t, o, e = {}) => {
  const l = T(t), a = T(o), n = H(mt(l.value)), r = H(mt(a.value));
  de([l, a], () => {
    k();
  });
  const {
    contentQuery: u = ":scope > [id]",
    targetQuery: i = "[href]",
    manual: d = !1,
    root: c,
    rootMargin: f = "0px 0px -25%",
    threshold: p = [0.1, 0.5, 1],
    watchChanges: v = !0
  } = e, m = H(null), B = H([]), w = H([]);
  Bt() ? He(() => {
    ja(l, n, {
      transform: {
        ltr: (P) => mt(P)
      },
      direction: "ltr",
      immediate: !0
    }), ja(a, r, {
      transform: {
        ltr: (P) => mt(P)
      },
      direction: "ltr",
      immediate: !0
    }), k();
  }) : Ne(() => {
    k();
  });
  const k = () => {
    w.value = n.value ? Array.from(n.value.querySelectorAll(u)) : [], B.value = w.value.map((P) => ({
      id: P.id,
      el: P,
      visible: !1,
      text: P.textContent
    }));
  };
  let g = !0, $ = 0;
  const y = h(
    () => n.value && getComputedStyle(n.value).overflowY === "visible" ? null : n.value
  ), A = Ar(
    w,
    (P) => {
      var N, z, C, x;
      const j = (N = y.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : N.scrollTop;
      g = j > $, $ = j, P.forEach((E) => {
        if (E.isIntersecting) {
          B.value.forEach((I) => {
            I.el === E.target && (I.visible = !0);
          });
          return;
        }
        B.value.forEach((I) => {
          I.el === E.target && (I.visible = !1);
        });
      });
      let F = null;
      g ? F = ((z = [...B.value].reverse().find((E) => E.visible)) == null ? void 0 : z.id) || null : F = ((C = B.value.find((E) => E.visible)) == null ? void 0 : C.id) || null, F !== null && (m.value = F), m.value || (m.value = ((x = B.value[0]) == null ? void 0 : x.id) || null);
    },
    {
      root: c ? mt(c) : y,
      rootMargin: f,
      threshold: p
    }
  );
  de(m, (P) => {
    var z;
    if (d)
      return;
    const j = (z = r.value) == null ? void 0 : z.querySelectorAll(i);
    if (j === void 0)
      return;
    let F = !1, N = null;
    j.forEach((C) => {
      var E, I, X, D, M, Q, Z, q, se, ie, te;
      const x = C.closest(".dropdown");
      if ((E = C.getAttribute("href")) != null && E.includes(`#${P}`)) {
        N = C, C.classList.add("active"), x && ((I = x == null ? void 0 : x.querySelector(".dropdown-toggle")) == null || I.classList.add("active"), F = !0);
        let ve = (X = C.closest(".nav")) == null ? void 0 : X.previousSibling;
        for (; (D = ve == null ? void 0 : ve.classList) != null && D.contains("nav-item"); )
          F = !0, (M = ve.querySelector(".nav-link")) == null || M.classList.add("active"), ve = (Q = ve.closest(".nav")) == null ? void 0 : Q.previousSibling;
      } else if (C.classList.remove("active"), x && !F && ((Z = x == null ? void 0 : x.querySelector(".dropdown-toggle")) == null || Z.classList.remove("active")), !F) {
        let ve = (q = C.closest(".nav")) == null ? void 0 : q.previousSibling;
        for (; (se = ve == null ? void 0 : ve.classList) != null && se.contains("nav-item"); )
          F = !0, ve.querySelector(".nav-link") !== N && ((ie = ve.querySelector(".nav-link")) == null || ie.classList.remove("active")), ve = (te = ve.closest(".nav")) == null ? void 0 : te.previousSibling;
      }
    });
  });
  const S = v ? Do(
    n,
    () => {
      k();
    },
    {
      childList: !0
    }
  ) : { stop: () => {
  } }, Y = (P, j = !1) => {
    var z, C;
    P.preventDefault();
    const F = (C = (z = P.target) == null ? void 0 : z.getAttribute) == null ? void 0 : C.call(z, "href"), N = F ? document == null ? void 0 : document.querySelector(F) : null;
    N && n.value && (n.value.scrollTo ? n.value.scrollTo({ top: N.offsetTop, behavior: j ? "smooth" : "auto" }) : n.value.scrollTop = N.offsetTop);
  }, K = () => {
    A.stop(), S.stop();
  };
  return {
    current: Oe(m),
    list: B,
    content: n,
    target: r,
    scrollIntoView: Y,
    updateList: k,
    cleanup: K
  };
}, kn = () => ({ ...Ve(an) }), fi = (t) => h(() => {
  const o = {
    name: "",
    enterActiveClass: "",
    enterToClass: "",
    leaveActiveClass: "",
    leaveToClass: "showing",
    enterFromClass: "showing",
    leaveFromClass: "",
    css: !0
  }, e = {
    ...o,
    name: "fade",
    enterActiveClass: "fade showing",
    leaveActiveClass: "fade showing"
  };
  return xe(t) ? o : e;
}), $a = /* @__PURE__ */ G({
  __name: "BTransition",
  props: {
    appear: { type: Boolean, default: !1 },
    mode: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    transProps: { default: void 0 }
  },
  emits: ["after-appear", "after-enter", "after-leave", "appear", "before-appear", "before-enter", "before-leave", "enter", "appear-cancelled", "enter-cancelled", "leave", "leave-cancelled"],
  setup(t, { emit: o }) {
    const l = U(t, "BTransition"), a = o, n = h(() => {
      const u = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, i = {
        ...u,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.noFade ? u : i;
    }), r = h(() => ({ mode: l.mode, css: !0, ...n.value }));
    return (u, i) => (b(), L(el, J({ ...r.value, ...s(l).transProps }, {
      appear: s(l).appear,
      onAfterAppear: i[0] || (i[0] = (d) => a("after-appear", d)),
      onAfterEnter: i[1] || (i[1] = (d) => a("after-enter", d)),
      onAfterLeave: i[2] || (i[2] = (d) => a("after-leave", d)),
      onAppear: i[3] || (i[3] = (d) => a("appear", d)),
      onBeforeAppear: i[4] || (i[4] = (d) => a("before-appear", d)),
      onBeforeEnter: i[5] || (i[5] = (d) => a("before-enter", d)),
      onBeforeLeave: i[6] || (i[6] = (d) => a("before-leave", d)),
      onEnter: i[7] || (i[7] = (d) => a("enter", d)),
      onAppearCancelled: i[8] || (i[8] = (d) => a("appear-cancelled", d)),
      onEnterCancelled: i[9] || (i[9] = (d) => a("enter-cancelled", d)),
      onLeave: i[10] || (i[10] = (d) => a("leave", d)),
      onLeaveCancelled: i[11] || (i[11] = (d) => a("leave-cancelled", d))
    }), {
      default: R(() => [
        V(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["appear"]));
  }
}), vi = ["type", "disabled", "aria-label"], zt = /* @__PURE__ */ G({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: Boolean, default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BCloseButton"), a = o;
    return (n, r) => (b(), O("button", {
      type: s(l).type,
      class: "btn-close",
      disabled: s(l).disabled,
      "aria-label": s(l).ariaLabel,
      onClick: r[0] || (r[0] = (u) => a("click", u))
    }, null, 8, vi));
  }
}), Hl = "active", it = /* @__PURE__ */ G({
  __name: "BLink",
  props: {
    active: { type: Boolean, default: void 0 },
    activeClass: { default: "router-link-active" },
    disabled: { type: Boolean, default: !1 },
    exactActiveClass: { default: "router-link-exact-active" },
    href: { default: void 0 },
    icon: { type: Boolean, default: !1 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: null },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BLink"), a = o, n = Lt(), r = Ve(fl, null), u = Ve(vl, null), i = Bt(), d = h(() => {
      const B = l.routerComponentName.split("-").map((_) => _.charAt(0).toUpperCase() + _.slice(1)).join("");
      return !((i == null ? void 0 : i.appContext.app.component(B)) !== void 0) || l.disabled || !l.to ? "a" : l.routerComponentName;
    }), c = h(() => {
      const B = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || B;
      const { to: w } = l;
      if (w !== void 0 && "path" in w) {
        const _ = w.path || "", k = w.query ? `?${Object.keys(w.query).map(($) => {
          var y;
          return `${$}=${(y = w.query) == null ? void 0 : y[$]}`;
        }).join("=")}` : "", g = !w.hash || w.hash.charAt(0) === "#" ? w.hash || "" : `#${w.hash}`;
        return `${_}${k}${g}` || B;
      }
      return B;
    }), f = h(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      "link-underline": l.underlineVariant === null && (l.underlineOpacity !== void 0 || l.underlineOpacityHover !== void 0),
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": l.icon === !0,
      "stretched-link": l.stretched === !0
    })), p = h(() => ({
      class: f.value,
      to: l.to,
      replace: l.replace,
      href: c.value,
      target: l.target,
      rel: l.target === "_blank" ? l.rel ?? "noopener" : void 0,
      tabindex: l.disabled ? "-1" : typeof n.tabindex > "u" ? null : n.tabindex,
      "aria-disabled": l.disabled ? !0 : null
    })), v = h(() => ({
      [Hl]: l.active,
      disabled: l.disabled
    })), m = (B) => {
      var w, _, k;
      if (l.disabled) {
        B.preventDefault(), B.stopImmediatePropagation();
        return;
      }
      (((w = r == null ? void 0 : r.isNav) == null ? void 0 : w.value) === !0 && u === null || u !== null && ((_ = u.autoClose) == null ? void 0 : _.value) === !0) && ((k = r == null ? void 0 : r.hide) == null || k.call(r)), a("click", B);
    };
    return (B, w) => d.value === "router-link" ? (b(), L(fe(d.value), J({ key: 0 }, p.value, { custom: "" }), {
      default: R(({ href: _, navigate: k, isActive: g, isExactActive: $ }) => [
        (b(), L(fe(s(l).routerTag), J({
          href: _,
          class: {
            [Hl]: s(l).active,
            [s(l).activeClass]: g,
            [s(l).exactActiveClass]: $
          }
        }, B.$attrs, {
          onClick: (y) => {
            k(y), m(y);
          }
        }), {
          default: R(() => [
            V(B.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (b(), L(fe(d.value), J({
      key: 1,
      class: v.value
    }, p.value, { onClick: m }), {
      default: R(() => [
        V(B.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pi = ["aria-valuenow", "aria-valuemax"], Tn = /* @__PURE__ */ G({
  __name: "BProgressBar",
  props: {
    animated: { type: Boolean, default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: Boolean, default: !1 },
    showValue: { type: Boolean, default: !1 },
    striped: { type: Boolean, default: !1 },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = U(t, "BProgressBar"), l = Ve(Xo, null), a = st(e), n = h(() => [
      a.value,
      {
        "progress-bar-animated": e.animated || (l == null ? void 0 : l.animated.value),
        "progress-bar-striped": e.striped || (l == null ? void 0 : l.striped.value) || e.animated || (l == null ? void 0 : l.animated.value)
      }
    ]), r = Be(() => e.precision), u = Be(() => e.value), i = Be(() => e.max ?? NaN), d = Be(() => (l == null ? void 0 : l.max.value) ?? NaN), c = h(
      () => e.labelHtml !== void 0 ? e.labelHtml : e.showValue || l != null && l.showValue.value ? u.value.toFixed(r.value) : e.showProgress || l != null && l.showProgress.value ? (u.value * 100 / (i.value || 100)).toFixed(r.value) : e.label !== void 0 ? e.label : ""
    ), f = h(
      () => d.value ? `${u.value * 100 / d.value}%` : i.value ? `${u.value * 100 / i.value}%` : typeof e.value == "string" ? e.value : `${e.value}%`
    );
    return (p, v) => (b(), O("div", {
      class: W(["progress-bar", n.value]),
      role: "progressbar",
      "aria-valuenow": s(e).value,
      "aria-valuemin": "0",
      "aria-valuemax": s(e).max,
      style: ze({ width: f.value })
    }, [
      V(p.$slots, "default", {}, () => [
        ce(oe(c.value), 1)
      ])
    ], 14, pi));
  }
}), Sn = /* @__PURE__ */ G({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: Boolean, default: void 0 },
    max: { default: 100 },
    precision: { default: void 0 },
    showProgress: { type: Boolean, default: void 0 },
    showValue: { type: Boolean, default: void 0 },
    striped: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BProgress");
    return We(Xo, {
      animated: T(() => e.animated),
      max: T(() => e.max),
      showProgress: T(() => e.showProgress),
      showValue: T(() => e.showValue),
      striped: T(() => e.striped)
    }), (l, a) => (b(), O("div", {
      class: "progress",
      style: ze({ height: s(e).height })
    }, [
      V(l.$slots, "default", {}, () => [
        ge(Tn, {
          animated: s(e).animated,
          max: s(e).max,
          precision: s(e).precision,
          "show-progress": s(e).showProgress,
          "show-value": s(e).showValue,
          striped: s(e).striped,
          value: s(e).value,
          variant: s(e).variant,
          "text-variant": s(e).textVariant,
          "bg-variant": s(e).bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
}), mi = ["id", "role", "aria-live", "aria-atomic"], bi = { class: "me-auto" }, xn = /* @__PURE__ */ G({
  __name: "BToast",
  props: /* @__PURE__ */ be({
    body: { default: void 0 },
    bodyClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    id: { default: void 0 },
    interval: { default: 1e3 },
    isStatus: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, Number] },
    noCloseButton: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noHoverPause: { type: Boolean, default: !1 },
    progressProps: { default: void 0 },
    showOnPause: { type: Boolean, default: !0 },
    solid: { type: Boolean, default: !1 },
    title: { default: void 0 },
    toastClass: { default: void 0 },
    transProps: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  }, {
    modelValue: { type: [Boolean, Number], default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["close", "close-countdown", "hide", "hidden", "show", "shown", "show-prevented", "hide-prevented"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BToast"), n = e, r = H(null), u = ul(r), i = we(t, "modelValue"), { computedLink: d, computedLinkProps: c } = Ct(a), f = Be(() => a.interval), p = st(a), v = T(() => typeof i.value == "boolean" ? 0 : i.value), {
      isActive: m,
      pause: B,
      restart: w,
      resume: _,
      stop: k,
      isPaused: g,
      value: $
    } = fn(v, f, {
      immediate: typeof i.value == "number"
    });
    Et(() => {
      n("close-countdown", $.value);
    });
    const y = T(() => d.value ? it : "div"), A = T(
      () => typeof i.value == "boolean" ? i.value : m.value || a.showOnPause && g.value
    ), S = h(() => [
      p.value,
      {
        show: A.value
      }
    ]), Y = () => {
      a.noHoverPause || B();
    };
    de(u, (C) => {
      if (C) {
        Y();
        return;
      }
      _();
    });
    const K = (C, x = {}) => new wt(C, {
      cancelable: !1,
      target: r.value || null,
      relatedTarget: null,
      trigger: null,
      ...x,
      componentId: a.id
    }), P = () => {
      const C = K("show", { cancelable: !0 });
      if (n("show", C), C.defaultPrevented) {
        i.value && (i.value = !1), n("show-prevented");
        return;
      }
      i.value || (i.value = !0);
    }, j = (C = "") => {
      const x = K("hide", { cancelable: C !== "", trigger: C });
      if (n("hide", x), C === "close" && n("close", x), x.defaultPrevented) {
        n("hide-prevented"), i.value || (i.value = !0);
        return;
      }
      typeof i.value == "boolean" ? i.value = !1 : (i.value = 0, k());
    }, F = () => {
      P();
    }, N = () => {
      n("shown", K("shown"));
    }, z = () => {
      n("hidden", K("hidden"));
    };
    return de(m, (C) => {
      C === !1 && g.value === !1 && i.value && j();
    }), Qa(k), o({
      pause: B,
      restart: w,
      resume: _,
      stop: k
    }), (C, x) => (b(), L($a, J({
      "no-fade": s(a).noFade
    }, s(a).transProps, {
      onBeforeEnter: F,
      onAfterEnter: N,
      onAfterLeave: z
    }), {
      default: R(() => [
        A.value ? (b(), O("div", {
          key: 0,
          id: s(a).id,
          ref_key: "element",
          ref: r,
          class: W(["toast", [s(a).toastClass, S.value]]),
          tabindex: "0",
          role: A.value ? s(a).isStatus ? "status" : "alert" : void 0,
          "aria-live": A.value ? s(a).isStatus ? "polite" : "assertive" : void 0,
          "aria-atomic": A.value ? !0 : void 0
        }, [
          C.$slots.title || s(a).title ? (b(), L(fe(s(a).headerTag), {
            key: 0,
            class: W(["toast-header", s(a).headerClass])
          }, {
            default: R(() => [
              V(C.$slots, "title", { hide: j }, () => [
                ae("strong", bi, oe(s(a).title), 1)
              ]),
              s(a).noCloseButton ? ne("", !0) : (b(), L(zt, {
                key: 0,
                onClick: x[0] || (x[0] = (E) => j("close"))
              }))
            ]),
            _: 3
          }, 8, ["class"])) : ne("", !0),
          C.$slots.default || s(a).body ? (b(), L(fe(y.value), J({
            key: 1,
            class: ["toast-body", s(a).bodyClass],
            style: { display: "block" }
          }, s(c), {
            onClick: x[1] || (x[1] = (E) => s(d) ? j() : () => {
            })
          }), {
            default: R(() => [
              V(C.$slots, "default", { hide: j }, () => [
                ce(oe(s(a).body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : ne("", !0),
          typeof i.value == "number" && s(a).progressProps !== void 0 ? (b(), L(Sn, {
            key: 2,
            animated: s(a).progressProps.animated,
            precision: s(a).progressProps.precision,
            "show-progress": s(a).progressProps.showProgress,
            "show-value": s(a).progressProps.showValue,
            striped: s(a).progressProps.striped,
            variant: s(a).progressProps.variant,
            max: i.value,
            value: s($),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : ne("", !0)
        ], 10, mi)) : ne("", !0)
      ]),
      _: 3
    }, 16, ["no-fade"]));
  }
}), yi = "top-end", $n = {
  install(t) {
    const o = H([]), e = H(!1), l = (u) => {
      e.value = u;
    }, a = (u = {}) => {
      var f;
      const i = Symbol(), d = H(((f = xe(u.props)) == null ? void 0 : f.value) || 5e3), c = h({
        get: () => {
          const p = xe(u.props);
          return {
            component: xe(u.component) ?? xn,
            props: {
              ...p,
              pos: (p == null ? void 0 : p.pos) || yi,
              _modelValue: d.value,
              _self: i
            }
          };
        },
        set: (p) => {
          d.value = p.props._modelValue;
        }
      });
      return (c.value.props.appendToast !== void 0 ? c.value.props.appendToast : e.value) ? o.value.push(c) : o.value.unshift(c), i;
    }, n = (u) => {
      o.value = o.value.filter((i) => i.value.props._self !== u);
    }, r = (u) => {
      const i = o.value.find((d) => d.value.props._self === u);
      i !== void 0 && (i.value = {
        ...i.value,
        props: {
          ...i.value.props,
          _modelValue: !1
        }
      });
    };
    t.provide(an, {
      _setIsAppend: l,
      toasts: o,
      show: a,
      remove: n,
      leave: r
    });
  }
}, An = {
  install(t) {
    const o = H([]), e = () => {
      o.value.splice(0, o.value.length);
    };
    t.provide(on, { items: o, reset: e });
  }
}, Vn = {
  install(t, o) {
    (o == null ? void 0 : o.id) instanceof Object && typeof o.id.getId == "function" && t.provide(rn, o.id.getId);
  }
};
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var Fn = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], ha = /* @__PURE__ */ Fn.join(","), Nn = typeof Element > "u", ht = Nn ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Ba = !Nn && Element.prototype.getRootNode ? function(t) {
  var o;
  return t == null || (o = t.getRootNode) === null || o === void 0 ? void 0 : o.call(t);
} : function(t) {
  return t == null ? void 0 : t.ownerDocument;
}, _a = function t(o, e) {
  var l;
  e === void 0 && (e = !0);
  var a = o == null || (l = o.getAttribute) === null || l === void 0 ? void 0 : l.call(o, "inert"), n = a === "" || a === "true", r = n || e && o && t(o.parentNode);
  return r;
}, gi = function(o) {
  var e, l = o == null || (e = o.getAttribute) === null || e === void 0 ? void 0 : e.call(o, "contenteditable");
  return l === "" || l === "true";
}, On = function(o, e, l) {
  if (_a(o))
    return [];
  var a = Array.prototype.slice.apply(o.querySelectorAll(ha));
  return e && ht.call(o, ha) && a.unshift(o), a = a.filter(l), a;
}, Pn = function t(o, e, l) {
  for (var a = [], n = Array.from(o); n.length; ) {
    var r = n.shift();
    if (!_a(r, !1))
      if (r.tagName === "SLOT") {
        var u = r.assignedElements(), i = u.length ? u : r.children, d = t(i, !0, l);
        l.flatten ? a.push.apply(a, d) : a.push({
          scopeParent: r,
          candidates: d
        });
      } else {
        var c = ht.call(r, ha);
        c && l.filter(r) && (e || !o.includes(r)) && a.push(r);
        var f = r.shadowRoot || // check for an undisclosed shadow
        typeof l.getShadowRoot == "function" && l.getShadowRoot(r), p = !_a(f, !1) && (!l.shadowRootFilter || l.shadowRootFilter(r));
        if (f && p) {
          var v = t(f === !0 ? r.children : f.children, !0, l);
          l.flatten ? a.push.apply(a, v) : a.push({
            scopeParent: r,
            candidates: v
          });
        } else
          n.unshift.apply(n, r.children);
      }
  }
  return a;
}, In = function(o) {
  return !isNaN(parseInt(o.getAttribute("tabindex"), 10));
}, bt = function(o) {
  if (!o)
    throw new Error("No node provided");
  return o.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(o.tagName) || gi(o)) && !In(o) ? 0 : o.tabIndex;
}, hi = function(o, e) {
  var l = bt(o);
  return l < 0 && e && !In(o) ? 0 : l;
}, Bi = function(o, e) {
  return o.tabIndex === e.tabIndex ? o.documentOrder - e.documentOrder : o.tabIndex - e.tabIndex;
}, En = function(o) {
  return o.tagName === "INPUT";
}, _i = function(o) {
  return En(o) && o.type === "hidden";
}, wi = function(o) {
  var e = o.tagName === "DETAILS" && Array.prototype.slice.apply(o.children).some(function(l) {
    return l.tagName === "SUMMARY";
  });
  return e;
}, Ci = function(o, e) {
  for (var l = 0; l < o.length; l++)
    if (o[l].checked && o[l].form === e)
      return o[l];
}, ki = function(o) {
  if (!o.name)
    return !0;
  var e = o.form || Ba(o), l = function(u) {
    return e.querySelectorAll('input[type="radio"][name="' + u + '"]');
  }, a;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    a = l(window.CSS.escape(o.name));
  else
    try {
      a = l(o.name);
    } catch (r) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", r.message), !1;
    }
  var n = Ci(a, o.form);
  return !n || n === o;
}, Ti = function(o) {
  return En(o) && o.type === "radio";
}, Si = function(o) {
  return Ti(o) && !ki(o);
}, xi = function(o) {
  var e, l = o && Ba(o), a = (e = l) === null || e === void 0 ? void 0 : e.host, n = !1;
  if (l && l !== o) {
    var r, u, i;
    for (n = !!((r = a) !== null && r !== void 0 && (u = r.ownerDocument) !== null && u !== void 0 && u.contains(a) || o != null && (i = o.ownerDocument) !== null && i !== void 0 && i.contains(o)); !n && a; ) {
      var d, c, f;
      l = Ba(a), a = (d = l) === null || d === void 0 ? void 0 : d.host, n = !!((c = a) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(a));
    }
  }
  return n;
}, Dl = function(o) {
  var e = o.getBoundingClientRect(), l = e.width, a = e.height;
  return l === 0 && a === 0;
}, $i = function(o, e) {
  var l = e.displayCheck, a = e.getShadowRoot;
  if (getComputedStyle(o).visibility === "hidden")
    return !0;
  var n = ht.call(o, "details>summary:first-of-type"), r = n ? o.parentElement : o;
  if (ht.call(r, "details:not([open]) *"))
    return !0;
  if (!l || l === "full" || l === "legacy-full") {
    if (typeof a == "function") {
      for (var u = o; o; ) {
        var i = o.parentElement, d = Ba(o);
        if (i && !i.shadowRoot && a(i) === !0)
          return Dl(o);
        o.assignedSlot ? o = o.assignedSlot : !i && d !== o.ownerDocument ? o = d.host : o = i;
      }
      o = u;
    }
    if (xi(o))
      return !o.getClientRects().length;
    if (l !== "legacy-full")
      return !0;
  } else if (l === "non-zero-area")
    return Dl(o);
  return !1;
}, Ai = function(o) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(o.tagName))
    for (var e = o.parentElement; e; ) {
      if (e.tagName === "FIELDSET" && e.disabled) {
        for (var l = 0; l < e.children.length; l++) {
          var a = e.children.item(l);
          if (a.tagName === "LEGEND")
            return ht.call(e, "fieldset[disabled] *") ? !0 : !a.contains(o);
        }
        return !0;
      }
      e = e.parentElement;
    }
  return !1;
}, wa = function(o, e) {
  return !(e.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  _a(e) || _i(e) || $i(e, o) || // For a details element with a summary, the summary element gets the focus
  wi(e) || Ai(e));
}, qa = function(o, e) {
  return !(Si(e) || bt(e) < 0 || !wa(o, e));
}, Vi = function(o) {
  var e = parseInt(o.getAttribute("tabindex"), 10);
  return !!(isNaN(e) || e >= 0);
}, Fi = function t(o) {
  var e = [], l = [];
  return o.forEach(function(a, n) {
    var r = !!a.scopeParent, u = r ? a.scopeParent : a, i = hi(u, r), d = r ? t(a.candidates) : u;
    i === 0 ? r ? e.push.apply(e, d) : e.push(u) : l.push({
      documentOrder: n,
      tabIndex: i,
      item: a,
      isScope: r,
      content: d
    });
  }), l.sort(Bi).reduce(function(a, n) {
    return n.isScope ? a.push.apply(a, n.content) : a.push(n.content), a;
  }, []).concat(e);
}, Ni = function(o, e) {
  e = e || {};
  var l;
  return e.getShadowRoot ? l = Pn([o], e.includeContainer, {
    filter: qa.bind(null, e),
    flatten: !1,
    getShadowRoot: e.getShadowRoot,
    shadowRootFilter: Vi
  }) : l = On(o, e.includeContainer, qa.bind(null, e)), Fi(l);
}, Oi = function(o, e) {
  e = e || {};
  var l;
  return e.getShadowRoot ? l = Pn([o], e.includeContainer, {
    filter: wa.bind(null, e),
    flatten: !0,
    getShadowRoot: e.getShadowRoot
  }) : l = On(o, e.includeContainer, wa.bind(null, e)), l;
}, St = function(o, e) {
  if (e = e || {}, !o)
    throw new Error("No node provided");
  return ht.call(o, ha) === !1 ? !1 : qa(e, o);
}, Pi = /* @__PURE__ */ Fn.concat("iframe").join(","), Pa = function(o, e) {
  if (e = e || {}, !o)
    throw new Error("No node provided");
  return ht.call(o, Pi) === !1 ? !1 : wa(e, o);
};
/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function jl(t, o) {
  var e = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(t);
    o && (l = l.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), e.push.apply(e, l);
  }
  return e;
}
function Gl(t) {
  for (var o = 1; o < arguments.length; o++) {
    var e = arguments[o] != null ? arguments[o] : {};
    o % 2 ? jl(Object(e), !0).forEach(function(l) {
      Ii(t, l, e[l]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : jl(Object(e)).forEach(function(l) {
      Object.defineProperty(t, l, Object.getOwnPropertyDescriptor(e, l));
    });
  }
  return t;
}
function Ii(t, o, e) {
  return o = Li(o), o in t ? Object.defineProperty(t, o, {
    value: e,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[o] = e, t;
}
function Ei(t, o) {
  if (typeof t != "object" || t === null)
    return t;
  var e = t[Symbol.toPrimitive];
  if (e !== void 0) {
    var l = e.call(t, o || "default");
    if (typeof l != "object")
      return l;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (o === "string" ? String : Number)(t);
}
function Li(t) {
  var o = Ei(t, "string");
  return typeof o == "symbol" ? o : String(o);
}
var ql = {
  activateTrap: function(o, e) {
    if (o.length > 0) {
      var l = o[o.length - 1];
      l !== e && l.pause();
    }
    var a = o.indexOf(e);
    a === -1 || o.splice(a, 1), o.push(e);
  },
  deactivateTrap: function(o, e) {
    var l = o.indexOf(e);
    l !== -1 && o.splice(l, 1), o.length > 0 && o[o.length - 1].unpause();
  }
}, Ri = function(o) {
  return o.tagName && o.tagName.toLowerCase() === "input" && typeof o.select == "function";
}, zi = function(o) {
  return (o == null ? void 0 : o.key) === "Escape" || (o == null ? void 0 : o.key) === "Esc" || (o == null ? void 0 : o.keyCode) === 27;
}, qt = function(o) {
  return (o == null ? void 0 : o.key) === "Tab" || (o == null ? void 0 : o.keyCode) === 9;
}, Mi = function(o) {
  return qt(o) && !o.shiftKey;
}, Hi = function(o) {
  return qt(o) && o.shiftKey;
}, Wl = function(o) {
  return setTimeout(o, 0);
}, Ul = function(o, e) {
  var l = -1;
  return o.every(function(a, n) {
    return e(a) ? (l = n, !1) : !0;
  }), l;
}, Ht = function(o) {
  for (var e = arguments.length, l = new Array(e > 1 ? e - 1 : 0), a = 1; a < e; a++)
    l[a - 1] = arguments[a];
  return typeof o == "function" ? o.apply(void 0, l) : o;
}, aa = function(o) {
  return o.target.shadowRoot && typeof o.composedPath == "function" ? o.composedPath()[0] : o.target;
}, Di = [], ji = function(o, e) {
  var l = (e == null ? void 0 : e.document) || document, a = (e == null ? void 0 : e.trapStack) || Di, n = Gl({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0,
    isKeyForward: Mi,
    isKeyBackward: Hi
  }, e), r = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  }, u, i = function(F, N, z) {
    return F && F[N] !== void 0 ? F[N] : n[z || N];
  }, d = function(F, N) {
    var z = typeof (N == null ? void 0 : N.composedPath) == "function" ? N.composedPath() : void 0;
    return r.containerGroups.findIndex(function(C) {
      var x = C.container, E = C.tabbableNodes;
      return x.contains(F) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (z == null ? void 0 : z.includes(x)) || E.find(function(I) {
        return I === F;
      });
    });
  }, c = function(F) {
    var N = n[F];
    if (typeof N == "function") {
      for (var z = arguments.length, C = new Array(z > 1 ? z - 1 : 0), x = 1; x < z; x++)
        C[x - 1] = arguments[x];
      N = N.apply(void 0, C);
    }
    if (N === !0 && (N = void 0), !N) {
      if (N === void 0 || N === !1)
        return N;
      throw new Error("`".concat(F, "` was specified but was not a node, or did not return a node"));
    }
    var E = N;
    if (typeof N == "string" && (E = l.querySelector(N), !E))
      throw new Error("`".concat(F, "` as selector refers to no known node"));
    return E;
  }, f = function() {
    var F = c("initialFocus");
    if (F === !1)
      return !1;
    if (F === void 0 || !Pa(F, n.tabbableOptions))
      if (d(l.activeElement) >= 0)
        F = l.activeElement;
      else {
        var N = r.tabbableGroups[0], z = N && N.firstTabbableNode;
        F = z || c("fallbackFocus");
      }
    if (!F)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return F;
  }, p = function() {
    if (r.containerGroups = r.containers.map(function(F) {
      var N = Ni(F, n.tabbableOptions), z = Oi(F, n.tabbableOptions), C = N.length > 0 ? N[0] : void 0, x = N.length > 0 ? N[N.length - 1] : void 0, E = z.find(function(D) {
        return St(D);
      }), I = z.slice().reverse().find(function(D) {
        return St(D);
      }), X = !!N.find(function(D) {
        return bt(D) > 0;
      });
      return {
        container: F,
        tabbableNodes: N,
        focusableNodes: z,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: X,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: C,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: x,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: E,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: I,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(M) {
          var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Z = N.indexOf(M);
          return Z < 0 ? Q ? z.slice(z.indexOf(M) + 1).find(function(q) {
            return St(q);
          }) : z.slice(0, z.indexOf(M)).reverse().find(function(q) {
            return St(q);
          }) : N[Z + (Q ? 1 : -1)];
        }
      };
    }), r.tabbableGroups = r.containerGroups.filter(function(F) {
      return F.tabbableNodes.length > 0;
    }), r.tabbableGroups.length <= 0 && !c("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    if (r.containerGroups.find(function(F) {
      return F.posTabIndexesFound;
    }) && r.containerGroups.length > 1)
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
  }, v = function j(F) {
    var N = F.activeElement;
    if (N)
      return N.shadowRoot && N.shadowRoot.activeElement !== null ? j(N.shadowRoot) : N;
  }, m = function j(F) {
    if (F !== !1 && F !== v(document)) {
      if (!F || !F.focus) {
        j(f());
        return;
      }
      F.focus({
        preventScroll: !!n.preventScroll
      }), r.mostRecentlyFocusedNode = F, Ri(F) && F.select();
    }
  }, B = function(F) {
    var N = c("setReturnFocus", F);
    return N || (N === !1 ? !1 : F);
  }, w = function(F) {
    var N = F.target, z = F.event, C = F.isBackward, x = C === void 0 ? !1 : C;
    N = N || aa(z), p();
    var E = null;
    if (r.tabbableGroups.length > 0) {
      var I = d(N, z), X = I >= 0 ? r.containerGroups[I] : void 0;
      if (I < 0)
        x ? E = r.tabbableGroups[r.tabbableGroups.length - 1].lastTabbableNode : E = r.tabbableGroups[0].firstTabbableNode;
      else if (x) {
        var D = Ul(r.tabbableGroups, function(ie) {
          var te = ie.firstTabbableNode;
          return N === te;
        });
        if (D < 0 && (X.container === N || Pa(N, n.tabbableOptions) && !St(N, n.tabbableOptions) && !X.nextTabbableNode(N, !1)) && (D = I), D >= 0) {
          var M = D === 0 ? r.tabbableGroups.length - 1 : D - 1, Q = r.tabbableGroups[M];
          E = bt(N) >= 0 ? Q.lastTabbableNode : Q.lastDomTabbableNode;
        } else
          qt(z) || (E = X.nextTabbableNode(N, !1));
      } else {
        var Z = Ul(r.tabbableGroups, function(ie) {
          var te = ie.lastTabbableNode;
          return N === te;
        });
        if (Z < 0 && (X.container === N || Pa(N, n.tabbableOptions) && !St(N, n.tabbableOptions) && !X.nextTabbableNode(N)) && (Z = I), Z >= 0) {
          var q = Z === r.tabbableGroups.length - 1 ? 0 : Z + 1, se = r.tabbableGroups[q];
          E = bt(N) >= 0 ? se.firstTabbableNode : se.firstDomTabbableNode;
        } else
          qt(z) || (E = X.nextTabbableNode(N));
      }
    } else
      E = c("fallbackFocus");
    return E;
  }, _ = function(F) {
    var N = aa(F);
    if (!(d(N, F) >= 0)) {
      if (Ht(n.clickOutsideDeactivates, F)) {
        u.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: n.returnFocusOnDeactivate
        });
        return;
      }
      Ht(n.allowOutsideClick, F) || F.preventDefault();
    }
  }, k = function(F) {
    var N = aa(F), z = d(N, F) >= 0;
    if (z || N instanceof Document)
      z && (r.mostRecentlyFocusedNode = N);
    else {
      F.stopImmediatePropagation();
      var C, x = !0;
      if (r.mostRecentlyFocusedNode)
        if (bt(r.mostRecentlyFocusedNode) > 0) {
          var E = d(r.mostRecentlyFocusedNode), I = r.containerGroups[E].tabbableNodes;
          if (I.length > 0) {
            var X = I.findIndex(function(D) {
              return D === r.mostRecentlyFocusedNode;
            });
            X >= 0 && (n.isKeyForward(r.recentNavEvent) ? X + 1 < I.length && (C = I[X + 1], x = !1) : X - 1 >= 0 && (C = I[X - 1], x = !1));
          }
        } else
          r.containerGroups.some(function(D) {
            return D.tabbableNodes.some(function(M) {
              return bt(M) > 0;
            });
          }) || (x = !1);
      else
        x = !1;
      x && (C = w({
        // move FROM the MRU node, not event-related node (which will be the node that is
        //  outside the trap causing the focus escape we're trying to fix)
        target: r.mostRecentlyFocusedNode,
        isBackward: n.isKeyBackward(r.recentNavEvent)
      })), m(C || r.mostRecentlyFocusedNode || f());
    }
    r.recentNavEvent = void 0;
  }, g = function(F) {
    var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    r.recentNavEvent = F;
    var z = w({
      event: F,
      isBackward: N
    });
    z && (qt(F) && F.preventDefault(), m(z));
  }, $ = function(F) {
    if (zi(F) && Ht(n.escapeDeactivates, F) !== !1) {
      F.preventDefault(), u.deactivate();
      return;
    }
    (n.isKeyForward(F) || n.isKeyBackward(F)) && g(F, n.isKeyBackward(F));
  }, y = function(F) {
    var N = aa(F);
    d(N, F) >= 0 || Ht(n.clickOutsideDeactivates, F) || Ht(n.allowOutsideClick, F) || (F.preventDefault(), F.stopImmediatePropagation());
  }, A = function() {
    if (r.active)
      return ql.activateTrap(a, u), r.delayInitialFocusTimer = n.delayInitialFocus ? Wl(function() {
        m(f());
      }) : m(f()), l.addEventListener("focusin", k, !0), l.addEventListener("mousedown", _, {
        capture: !0,
        passive: !1
      }), l.addEventListener("touchstart", _, {
        capture: !0,
        passive: !1
      }), l.addEventListener("click", y, {
        capture: !0,
        passive: !1
      }), l.addEventListener("keydown", $, {
        capture: !0,
        passive: !1
      }), u;
  }, S = function() {
    if (r.active)
      return l.removeEventListener("focusin", k, !0), l.removeEventListener("mousedown", _, !0), l.removeEventListener("touchstart", _, !0), l.removeEventListener("click", y, !0), l.removeEventListener("keydown", $, !0), u;
  }, Y = function(F) {
    var N = F.some(function(z) {
      var C = Array.from(z.removedNodes);
      return C.some(function(x) {
        return x === r.mostRecentlyFocusedNode;
      });
    });
    N && m(f());
  }, K = typeof window < "u" && "MutationObserver" in window ? new MutationObserver(Y) : void 0, P = function() {
    K && (K.disconnect(), r.active && !r.paused && r.containers.map(function(F) {
      K.observe(F, {
        subtree: !0,
        childList: !0
      });
    }));
  };
  return u = {
    get active() {
      return r.active;
    },
    get paused() {
      return r.paused;
    },
    activate: function(F) {
      if (r.active)
        return this;
      var N = i(F, "onActivate"), z = i(F, "onPostActivate"), C = i(F, "checkCanFocusTrap");
      C || p(), r.active = !0, r.paused = !1, r.nodeFocusedBeforeActivation = l.activeElement, N == null || N();
      var x = function() {
        C && p(), A(), P(), z == null || z();
      };
      return C ? (C(r.containers.concat()).then(x, x), this) : (x(), this);
    },
    deactivate: function(F) {
      if (!r.active)
        return this;
      var N = Gl({
        onDeactivate: n.onDeactivate,
        onPostDeactivate: n.onPostDeactivate,
        checkCanReturnFocus: n.checkCanReturnFocus
      }, F);
      clearTimeout(r.delayInitialFocusTimer), r.delayInitialFocusTimer = void 0, S(), r.active = !1, r.paused = !1, P(), ql.deactivateTrap(a, u);
      var z = i(N, "onDeactivate"), C = i(N, "onPostDeactivate"), x = i(N, "checkCanReturnFocus"), E = i(N, "returnFocus", "returnFocusOnDeactivate");
      z == null || z();
      var I = function() {
        Wl(function() {
          E && m(B(r.nodeFocusedBeforeActivation)), C == null || C();
        });
      };
      return E && x ? (x(B(r.nodeFocusedBeforeActivation)).then(I, I), this) : (I(), this);
    },
    pause: function(F) {
      if (r.paused || !r.active)
        return this;
      var N = i(F, "onPause"), z = i(F, "onPostPause");
      return r.paused = !0, N == null || N(), S(), P(), z == null || z(), this;
    },
    unpause: function(F) {
      if (!r.paused || !r.active)
        return this;
      var N = i(F, "onUnpause"), z = i(F, "onPostUnpause");
      return r.paused = !1, N == null || N(), p(), A(), P(), z == null || z(), this;
    },
    updateContainerElements: function(F) {
      var N = [].concat(F).filter(Boolean);
      return r.containers = N.map(function(z) {
        return typeof z == "string" ? l.querySelector(z) : z;
      }), r.active && p(), P(), this;
    }
  }, u.updateContainerElements(o), u;
};
function Gi(t, o = {}) {
  let e;
  const { immediate: l, ...a } = o, n = H(!1), r = H(!1), u = (f) => e && e.activate(f), i = (f) => e && e.deactivate(f), d = () => {
    e && (e.pause(), r.value = !0);
  }, c = () => {
    e && (e.unpause(), r.value = !1);
  };
  return de(
    () => Le(t),
    (f) => {
      f && (e = ji(f, {
        ...a,
        onActivate() {
          n.value = !0, o.onActivate && o.onActivate();
        },
        onDeactivate() {
          n.value = !1, o.onDeactivate && o.onDeactivate();
        }
      }), l && u());
    },
    { flush: "post" }
  ), rt(() => i()), {
    hasFocus: n,
    isPaused: r,
    activate: u,
    deactivate: i,
    pause: d,
    unpause: c
  };
}
const Ln = ({
  element: t,
  isActive: o,
  noTrap: e,
  fallbackFocus: l
}, a = {
  allowOutsideClick: !0,
  fallbackFocus: l.ref.value ?? void 0
}) => {
  const n = Oe(T(o)), r = Oe(T(e)), u = () => {
    var f;
    const c = (f = t.value) == null ? void 0 : f.querySelectorAll(
      `a, button, input, select, textarea, [tabindex]:not([tabindex="-1"]):not(.${l.classSelector})`
    );
    return !c || c.length === 0;
  }, i = H(u());
  He(() => {
    Do(
      t,
      () => {
        i.value = u();
      },
      { childList: !0, subtree: !0 }
    );
  });
  const d = Gi(t, a);
  return de(n, async (c) => {
    await Ne(), c && r.value === !1 ? d.activate() : d.deactivate();
  }), de(r, (c) => {
    c === !0 && d.deactivate();
  }), {
    needsFallback: Oe(i)
  };
}, qi = {
  key: 0,
  class: "visually-hidden"
}, Aa = /* @__PURE__ */ G({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: Boolean, default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BSpinner"), l = De(), a = h(() => [
      `spinner-${e.type}`,
      {
        [`spinner-${e.type}-sm`]: e.small,
        [`text-${e.variant}`]: e.variant !== null
      }
    ]), n = T(() => !Pe(l.label));
    return (r, u) => (b(), L(fe(s(e).tag), {
      class: W(a.value),
      role: s(e).label || n.value ? s(e).role : null,
      "aria-hidden": s(e).label || n.value ? null : !0
    }, {
      default: R(() => [
        s(e).label || n.value ? (b(), O("span", qi, [
          V(r.$slots, "label", {}, () => [
            ce(oe(s(e).label), 1)
          ])
        ])) : ne("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), vt = /* @__PURE__ */ G({
  __name: "BButton",
  props: /* @__PURE__ */ be({
    loading: { type: Boolean, default: !1 },
    loadingFill: { type: Boolean, default: !1 },
    loadingText: { default: "Loading..." },
    pill: { type: Boolean, default: !1 },
    pressed: { type: Boolean },
    size: { default: "md" },
    squared: { type: Boolean, default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    routerTag: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  }, {
    pressed: { type: Boolean, default: void 0 },
    pressedModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["click"], ["update:pressed"]),
  setup(t, { emit: o }) {
    const l = U(t, "BButton"), a = o, n = we(t, "pressed"), { computedLink: r, computedLinkProps: u } = Ct(l, [
      "active-class",
      "exact-active-class",
      "replace",
      "routerComponentName",
      "routerTag"
    ]), i = T(() => typeof l.pressed == "boolean"), d = T(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), c = T(() => l.to !== void 0), f = T(() => l.href !== void 0 ? !1 : !d.value), p = h(() => c.value ? u.value : []), v = h(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        active: l.active || l.pressed,
        "rounded-pill": l.pill,
        "rounded-0": l.squared,
        disabled: l.disabled
      }
    ]), m = T(() => c.value ? it : l.href ? "a" : l.tag), B = (w) => {
      if (l.disabled) {
        w.preventDefault(), w.stopPropagation();
        return;
      }
      a("click", w), i.value && (n.value = !l.pressed);
    };
    return (w, _) => (b(), L(fe(m.value), J({ class: "btn" }, p.value, {
      class: v.value,
      "aria-disabled": f.value ? s(l).disabled : null,
      "aria-pressed": i.value ? s(l).pressed : null,
      autocomplete: i.value ? "off" : null,
      disabled: d.value ? s(l).disabled : null,
      href: s(l).href,
      rel: s(r) ? s(l).rel : null,
      role: f.value || s(r) ? "button" : null,
      target: s(r) ? s(l).target : null,
      type: d.value ? s(l).type : null,
      to: d.value ? null : s(l).to,
      onClick: B
    }), {
      default: R(() => [
        s(l).loading ? V(w.$slots, "loading", { key: 0 }, () => [
          s(l).loadingFill ? ne("", !0) : (b(), O(pe, { key: 0 }, [
            ce(oe(s(l).loadingText), 1)
          ], 64)),
          V(w.$slots, "loading-spinner", {}, () => [
            ge(Aa, {
              small: s(l).size !== "lg",
              label: s(l).loadingFill ? s(l).loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : V(w.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to"]));
  }
}), Wi = ["id", "aria-labelledby", "aria-describedby"], Ui = ["id"], Kl = "modal-fallback-focus", Xl = 1056, Ki = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BModal",
  props: /* @__PURE__ */ be({
    autofocus: { type: Boolean, default: !0 },
    autofocusButton: { default: void 0 },
    body: { default: void 0 },
    bodyAttrs: { default: void 0 },
    bodyBgVariant: { default: null },
    bodyClass: { default: null },
    bodyScrolling: { type: Boolean, default: !1 },
    bodyTextVariant: { default: null },
    bodyVariant: { default: null },
    busy: { type: Boolean, default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: Boolean, default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    footerVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerTextVariant: { default: null },
    headerVariant: { default: null },
    hideBackdrop: { type: Boolean, default: !1 },
    hideFooter: { type: Boolean, default: !1 },
    hideHeader: { type: Boolean, default: !1 },
    hideHeaderClose: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modalClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noTrap: { type: Boolean, default: !1 },
    noStacking: { type: Boolean },
    okDisabled: { type: Boolean, default: !1 },
    okOnly: { type: Boolean, default: !1 },
    okTitle: { default: "OK" },
    okVariant: { default: "primary" },
    scrollable: { type: Boolean, default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: Boolean, default: !1 },
    titleTag: { default: "h5" },
    transProps: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["backdrop", "cancel", "close", "esc", "hidden", "hide", "hide-prevented", "ok", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BModal"), n = e, r = De(), u = Ce(() => a.id, "modal"), i = we(t, "modelValue"), d = H(null), c = H(null), f = H(null), p = H(null), v = H(null), m = H(!1), B = H(!1), { needsFallback: w } = Ln({
      element: d,
      isActive: m,
      noTrap: () => a.noTrap,
      fallbackFocus: {
        ref: c,
        classSelector: Kl
      }
    }), _ = fi(!0);
    qe(
      "Escape",
      () => {
        M("esc");
      },
      { target: d }
    ), wn(i, () => a.bodyScrolling);
    const { focused: k } = Re(d, {
      initialValue: i.value && a.autofocusButton === void 0 && a.autofocus === !0
    }), { focused: g } = Re(f, {
      initialValue: i.value && a.autofocusButton === "ok" && a.autofocus === !0
    }), { focused: $ } = Re(p, {
      initialValue: i.value && a.autofocusButton === "cancel" && a.autofocus === !0
    }), { focused: y } = Re(v, {
      initialValue: i.value && a.autofocusButton === "close" && a.autofocus === !0
    }), A = h(() => [
      a.modalClass,
      {
        fade: !a.noFade,
        show: m.value
      }
    ]), S = T(
      () => a.lazy === !1 || a.lazy === !0 && B.value === !0 || a.lazy === !0 && i.value === !0
    ), Y = T(() => !Pe(r["header-close"])), K = h(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": a.centered,
        "modal-dialog-scrollable": a.scrollable
      }
    ]), P = st(() => ({
      bgVariant: a.bodyBgVariant,
      textVariant: a.bodyTextVariant,
      variant: a.bodyVariant
    })), j = h(() => [a.bodyClass, P.value]), F = st(() => ({
      bgVariant: a.headerBgVariant,
      textVariant: a.headerTextVariant,
      variant: a.headerVariant
    })), N = h(() => [
      a.headerClass,
      F.value,
      {
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null
      }
    ]), z = h(() => ({
      variant: Y.value ? a.headerCloseVariant : void 0,
      class: a.headerCloseClass
    })), C = st(() => ({
      bgVariant: a.footerBgVariant,
      textVariant: a.footerTextVariant,
      variant: a.footerVariant
    })), x = h(() => [
      a.footerClass,
      C.value,
      {
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null
      }
    ]), E = h(() => [
      a.titleClass,
      {
        "visually-hidden": a.titleSrOnly
      }
    ]), I = T(() => a.cancelDisabled || a.busy), X = T(() => a.okDisabled || a.busy), D = (ee, ye = {}) => new wt(ee, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...ye,
      componentId: u.value
    });
    de(i, (ee, ye) => {
      ee !== ye && (ee === !0 ? Q() : M());
    });
    const M = (ee = "") => {
      if (ee === "backdrop" && a.noCloseOnBackdrop || ee === "esc" && a.noCloseOnEsc) {
        n("hide-prevented");
        return;
      }
      const ye = D("hide", { cancelable: ee !== "", trigger: ee });
      if (ee === "ok" && n(ee, ye), ee === "cancel" && n(ee, ye), ee === "close" && n(ee, ye), ee === "backdrop" && n(ee, ye), ee === "esc" && n(ee, ye), n("hide", ye), ye.defaultPrevented) {
        n("hide-prevented"), i.value || (i.value = !0);
        return;
      }
      i.value && (i.value = !1);
    }, Q = () => {
      if (m.value)
        return;
      const ee = D("show", { cancelable: !0 });
      if (n("show", ee), ee.defaultPrevented) {
        i.value && (i.value = !1), n("show-prevented");
        return;
      }
      i.value || (i.value = !0);
    }, Z = () => {
      a.autofocus !== !1 && (a.autofocusButton === "ok" ? g.value = !0 : a.autofocusButton === "close" ? y.value = !0 : a.autofocusButton === "cancel" ? $.value = !0 : k.value = !0);
    }, q = () => {
      Q();
    }, se = () => {
      m.value = !0, Z(), n("shown", D("shown")), a.lazy === !0 && (B.value = !0);
    }, ie = H(!1), te = () => {
      m.value = !1, ie.value = !0;
    }, ve = () => {
      n("hidden", D("hidden")), a.lazy === !0 && (B.value = !1), ie.value = !1;
    }, { activePosition: ue, activeModalCount: me, stackWithoutSelf: le } = ui(
      m,
      i.value
    );
    de(le, (ee, ye) => {
      ee.length > ye.length && m.value === !0 && a.noStacking === !0 && M();
    });
    const re = h(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": m.value || ie.value ? (
        // Just for reference there is a single frame in which the modal is not active but still has a higher z-index than the active ones due to _when_ it calculates its position. It's a small visual effect
        Xl - (((me == null ? void 0 : me.value) ?? 0) - ((ue == null ? void 0 : ue.value) ?? 0))
      ) : Xl
    }));
    $e(d, "bv-toggle", () => {
      i.value ? M() : Q();
    });
    const he = h(() => ({
      cancel: () => {
        M("cancel");
      },
      close: () => {
        M("close");
      },
      hide: M,
      ok: () => {
        M("ok");
      },
      visible: i.value
    }));
    return o({
      hide: M,
      id: u,
      show: Q
    }), (ee, ye) => (b(), L(_t, {
      to: s(a).teleportTo,
      disabled: s(a).teleportDisabled
    }, [
      ge(el, J({ ...s(_), ...s(a).transProps, enterToClass: "show" }, {
        appear: i.value,
        onBeforeEnter: q,
        onAfterEnter: se,
        onLeave: te,
        onAfterLeave: ve
      }), {
        default: R(() => [
          dt(ae("div", J({
            id: s(u),
            ref_key: "element",
            ref: d,
            class: ["modal", A.value],
            role: "dialog",
            "aria-labelledby": s(a).hideHeader ? void 0 : `${s(u)}-label`,
            "aria-describedby": `${s(u)}-body`,
            tabindex: "-1"
          }, ee.$attrs, { style: re.value }), [
            ae("div", {
              class: W(["modal-dialog", K.value])
            }, [
              S.value ? (b(), O("div", {
                key: 0,
                class: W(["modal-content", s(a).contentClass])
              }, [
                s(a).hideHeader ? ne("", !0) : (b(), O("div", {
                  key: 0,
                  class: W(["modal-header", N.value])
                }, [
                  V(ee.$slots, "header", _e(Se(he.value)), () => [
                    (b(), L(fe(s(a).titleTag), {
                      id: `${s(u)}-label`,
                      class: W(["modal-title", E.value])
                    }, {
                      default: R(() => [
                        V(ee.$slots, "title", _e(Se(he.value)), () => [
                          ce(oe(s(a).title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    s(a).hideHeaderClose ? ne("", !0) : (b(), O(pe, { key: 0 }, [
                      Y.value ? (b(), L(vt, J({ key: 0 }, z.value, {
                        onClick: ye[0] || (ye[0] = (Te) => M("close"))
                      }), {
                        default: R(() => [
                          V(ee.$slots, "header-close", {}, void 0, !0)
                        ]),
                        _: 3
                      }, 16)) : (b(), L(zt, J({
                        key: 1,
                        "aria-label": s(a).headerCloseLabel
                      }, z.value, {
                        onClick: ye[1] || (ye[1] = (Te) => M("close"))
                      }), null, 16, ["aria-label"]))
                    ], 64))
                  ], !0)
                ], 2)),
                ae("div", J({
                  id: `${s(u)}-body`,
                  class: ["modal-body", j.value]
                }, s(a).bodyAttrs), [
                  V(ee.$slots, "default", _e(Se(he.value)), () => [
                    ce(oe(s(a).body), 1)
                  ], !0)
                ], 16, Ui),
                s(a).hideFooter ? ne("", !0) : (b(), O("div", {
                  key: 1,
                  class: W(["modal-footer", x.value])
                }, [
                  V(ee.$slots, "footer", _e(Se(he.value)), () => [
                    V(ee.$slots, "cancel", _e(Se(he.value)), () => [
                      s(a).okOnly ? ne("", !0) : (b(), L(vt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: p,
                        disabled: I.value,
                        size: s(a).buttonSize,
                        variant: s(a).cancelVariant,
                        onClick: ye[2] || (ye[2] = (Te) => M("cancel"))
                      }, {
                        default: R(() => [
                          ce(oe(s(a).cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    V(ee.$slots, "ok", _e(Se(he.value)), () => [
                      ge(vt, {
                        ref_key: "okButton",
                        ref: f,
                        disabled: X.value,
                        size: s(a).buttonSize,
                        variant: s(a).okVariant,
                        onClick: ye[3] || (ye[3] = (Te) => M("ok"))
                      }, {
                        default: R(() => [
                          ce(oe(s(a).okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : ne("", !0)
            ], 2),
            s(a).hideBackdrop ? ne("", !0) : V(ee.$slots, "backdrop", { key: 0 }, () => [
              ae("div", {
                class: "modal-backdrop fade show",
                onClick: ye[4] || (ye[4] = (Te) => M("backdrop"))
              })
            ], !0),
            s(w) ? (b(), O("div", {
              key: 1,
              ref_key: "fallbackFocusElement",
              ref: c,
              class: W(Kl),
              tabindex: "0",
              style: { width: "0", height: "0", overflow: "hidden" }
            }, null, 512)) : ne("", !0)
          ], 16, Wi), [
            [Kt, i.value]
          ])
        ]),
        _: 3
      }, 16, ["appear"])
    ], 8, ["to", "disabled"]));
  }
}), Rn = (t, o) => {
  const e = t.__vccOpts || t;
  for (const [l, a] of o)
    e[l] = a;
  return e;
}, Wa = /* @__PURE__ */ Rn(Ki, [["__scopeId", "data-v-4f028742"]]), zn = {
  install(t) {
    const o = H([]), e = () => {
      let i = () => {
      };
      return {
        value: new Promise((c) => {
          i = c;
        }),
        resolve: i
      };
    }, l = () => [e(), Symbol(), H(!0)], a = (i = {}) => {
      const [d, c, f] = l();
      return o.value.push(
        h({
          get: () => ({
            component: xe(i.component) ?? Wa,
            props: {
              ...xe(i.props),
              _isConfirm: !1,
              _promise: d,
              _self: c,
              _modelValue: f.value
            }
          }),
          set: (p) => {
            f.value = p.props._modelValue;
          }
        })
      ), d.value;
    }, n = (i = {}) => {
      const [d, c, f] = l();
      return o.value.push(
        h({
          get: () => ({
            component: xe(i.component) ?? Wa,
            props: {
              ...xe(i.props),
              _isConfirm: !0,
              _promise: d,
              _self: c,
              _modelValue: f.value
            }
          }),
          set: (p) => {
            f.value = p.props._modelValue;
          }
        })
      ), d.value;
    }, r = (i) => {
      const d = o.value.find((c) => c.value.props._self === i);
      d !== void 0 && (d.value = {
        ...d.value,
        props: {
          ...d.value.props,
          _modelValue: !1
        }
      });
    }, u = (i) => {
      o.value = o.value.filter((d) => d.value.props._self !== i);
    };
    t.provide(nn, {
      modals: o,
      remove: u,
      show: a,
      confirm: n,
      leave: r
    });
  }
}, Mn = {
  install(t) {
    const o = H(/* @__PURE__ */ new Map()), e = h(() => o.value.size), l = h(() => [...o.value.values()].pop()), a = (d) => {
      o.value.set(d.uid, d);
    }, n = (d) => {
      o.value.delete(d.uid);
    }, r = H(/* @__PURE__ */ new Map()), u = (d) => {
      r.value.set(d.uid, d);
    }, i = (d) => {
      r.value.delete(d.uid);
    };
    t.provide(sn, {
      stack: h(() => [...o.value.values()]),
      countStack: e,
      lastStack: l,
      registry: h(() => [...r.value.values()]),
      pushStack: a,
      removeStack: n,
      pushRegistry: u,
      removeRegistry: i
    });
  }
}, Hn = {
  install(t, o) {
    var i, d;
    const a = typeof (o == null ? void 0 : o.rtl) == "boolean" ? !1 : ((i = o == null ? void 0 : o.rtl) == null ? void 0 : i.rtlInitial) ?? !1, n = typeof (o == null ? void 0 : o.rtl) == "boolean" ? void 0 : ((d = o == null ? void 0 : o.rtl) == null ? void 0 : d.localeInitial) ?? void 0, r = H(a), u = H(n);
    t.provide(ln, { isRtl: r, locale: u });
  }
}, Dn = {
  install(t, o) {
    const e = (o == null ? void 0 : o.components) ?? {};
    t.provide(ra, H(e));
  }
}, ff = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  breadcrumbPlugin: An,
  defaultsPlugin: Dn,
  idPlugin: Vn,
  modalControllerPlugin: zn,
  modalManagerPlugin: Mn,
  rtlPlugin: Hn,
  toastPlugin: $n
}, Symbol.toStringTag, { value: "Module" })), jn = Object.freeze(
  Object.keys({
    BAccordion: "BAccordion",
    BAccordionItem: "BAccordionItem",
    BAlert: "BAlert",
    BAvatar: "BAvatar",
    BAvatarGroup: "BAvatarGroup",
    BBadge: "BBadge",
    BBreadcrumb: "BBreadcrumb",
    BBreadcrumbItem: "BBreadcrumbItem",
    BButton: "BButton",
    BButtonGroup: "BButtonGroup",
    BButtonToolbar: "BButtonToolbar",
    BCard: "BCard",
    BCardBody: "BCardBody",
    BCardFooter: "BCardFooter",
    BCardGroup: "BCardGroup",
    BCardHeader: "BCardHeader",
    BCardImg: "BCardImg",
    BCardSubtitle: "BCardSubtitle",
    BCardText: "BCardText",
    BCardTitle: "BCardTitle",
    BCarousel: "BCarousel",
    BCarouselSlide: "BCarouselSlide",
    BCloseButton: "BCloseButton",
    BCol: "BCol",
    BCollapse: "BCollapse",
    BContainer: "BContainer",
    BDropdown: "BDropdown",
    BDropdownDivider: "BDropdownDivider",
    BDropdownForm: "BDropdownForm",
    BDropdownGroup: "BDropdownGroup",
    BDropdownHeader: "BDropdownHeader",
    BDropdownItem: "BDropdownItem",
    BDropdownItemButton: "BDropdownItemButton",
    BDropdownText: "BDropdownText",
    BForm: "BForm",
    BFormCheckbox: "BFormCheckbox",
    BFormCheckboxGroup: "BFormCheckboxGroup",
    BFormDatalist: "BFormDatalist",
    BFormFile: "BFormFile",
    BFormFloatingLabel: "BFormFloatingLabel",
    BFormGroup: "BFormGroup",
    BFormInput: "BFormInput",
    BFormInvalidFeedback: "BFormInvalidFeedback",
    BFormRadio: "BFormRadio",
    BFormRadioGroup: "BFormRadioGroup",
    BFormRow: "BFormRow",
    BFormSelect: "BFormSelect",
    BFormSelectOption: "BFormSelectOption",
    BFormSelectOptionGroup: "BFormSelectOptionGroup",
    BFormSpinbutton: "BFormSpinbutton",
    BFormTag: "BFormTag",
    BFormTags: "BFormTags",
    BFormText: "BFormText",
    BFormTextarea: "BFormTextarea",
    BFormValidFeedback: "BFormValidFeedback",
    BImg: "BImg",
    BInput: "BInput",
    BInputGroup: "BInputGroup",
    BInputGroupText: "BInputGroupText",
    BListGroup: "BListGroup",
    BListGroupItem: "BListGroupItem",
    BModal: "BModal",
    BModalOrchestrator: "BModalOrchestrator",
    BNav: "BNav",
    BNavForm: "BNavForm",
    BNavItem: "BNavItem",
    BNavItemDropdown: "BNavItemDropdown",
    BNavText: "BNavText",
    BNavbar: "BNavbar",
    BNavbarBrand: "BNavbarBrand",
    BNavbarNav: "BNavbarNav",
    BNavbarToggle: "BNavbarToggle",
    BOffcanvas: "BOffcanvas",
    BOverlay: "BOverlay",
    BPagination: "BPagination",
    BPlaceholder: "BPlaceholder",
    BPlaceholderButton: "BPlaceholderButton",
    BPlaceholderCard: "BPlaceholderCard",
    BPlaceholderTable: "BPlaceholderTable",
    BPlaceholderWrapper: "BPlaceholderWrapper",
    BPopover: "BPopover",
    BProgress: "BProgress",
    BRow: "BRow",
    BSpinner: "BSpinner",
    BTab: "BTab",
    BTabs: "BTabs",
    BToast: "BToast",
    BToastOrchestrator: "BToastOrchestrator",
    BTooltip: "BTooltip",
    BLink: "BLink",
    BProgressBar: "BProgressBar",
    BTableSimple: "BTableSimple",
    BTableLite: "BTableLite",
    BTable: "BTable",
    BTbody: "BTbody",
    BTd: "BTd",
    BTh: "BTh",
    BThead: "BThead",
    BTfoot: "BTfoot",
    BTr: "BTr",
    BTransition: "BTransition"
  })
), Gn = Object.freeze(
  Object.keys({
    vBColorMode: "vBColorMode",
    vBModal: "vBModal",
    vBPopover: "vBPopover",
    vBScrollspy: "vBScrollspy",
    vBToggle: "vBToggle",
    vBTooltip: "vBTooltip"
  })
), Xi = Object.freeze(
  Object.keys({
    useBreadcrumb: "useBreadcrumb",
    useColorMode: "useColorMode",
    useModal: "useModal",
    useModalController: "useModalController",
    useScrollspy: "useScrollspy",
    useToast: "useToast"
  })
), Yi = ["id"], Zi = /* @__PURE__ */ G({
  __name: "BAccordion",
  props: /* @__PURE__ */ be({
    flush: { type: Boolean, default: !1 },
    free: { type: Boolean, default: !1 },
    id: { default: void 0 },
    modelValue: {}
  }, {
    modelValue: {
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t) {
    const e = U(t, "BAccordion"), l = we(t, "modelValue"), a = Ce(() => e.id, "accordion"), n = h(() => ({
      "accordion-flush": e.flush
    }));
    return We(Jo, {
      openItem: Oe(l),
      free: T(() => e.free),
      setOpenItem: (r) => {
        l.value = r;
      }
    }), (r, u) => (b(), O("div", {
      id: s(a),
      class: W(["accordion", n.value])
    }, [
      V(r.$slots, "default")
    ], 10, Yi));
  }
}), qn = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: /* @__PURE__ */ be({
    horizontal: { type: Boolean, default: !1 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    skipAnimation: { type: Boolean, default: !1 },
    tag: { default: "div" },
    toggle: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !1 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BCollapse"), n = e, r = (A, S = {}) => new wt(A, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...S,
      componentId: i.value
    }), u = we(t, "modelValue"), i = Ce(() => a.id, "collapse"), d = H(null), c = H(!1), f = H(u.value), p = h(() => ({
      show: f.value,
      "navbar-collapse": a.isNav,
      collapsing: c.value,
      closing: f.value && !u.value,
      "collapse-horizontal": a.horizontal
    })), v = () => {
      u.value = !1;
    }, m = () => {
      u.value = !0;
    }, B = () => {
      u.value = !u.value;
    }, w = h(() => ({
      toggle: B,
      show: m,
      hide: v,
      id: i.value,
      visible: u.value
    }));
    let _, k, g = a.skipAnimation;
    const $ = () => {
      const A = r("show", { cancelable: !0 });
      if (n("show", A), A.defaultPrevented) {
        n("show-prevented");
        return;
      }
      clearTimeout(k), clearTimeout(_), f.value = !0, !g && (c.value = !0, Ne(() => {
        d.value !== null && (a.horizontal ? d.value.style.width = `${d.value.scrollWidth}px` : d.value.style.height = `${d.value.scrollHeight}px`, _ = setTimeout(() => {
          c.value = !1, n("shown"), d.value !== null && (d.value.style.height = "", d.value.style.width = "");
        }, La(d.value)));
      }));
    }, y = () => {
      const A = r("hide", { cancelable: !0 });
      if (n("hide", A), A.defaultPrevented) {
        n("hide-prevented");
        return;
      }
      if (clearTimeout(_), clearTimeout(k), d.value !== null) {
        if (g) {
          f.value = !1;
          return;
        }
        c.value ? (d.value.style.height = "", d.value.style.width = "") : a.horizontal ? d.value.style.width = `${d.value.scrollWidth}px` : d.value.style.height = `${d.value.scrollHeight}px`, d.value.offsetHeight, c.value = !0, Ne(() => {
          d.value !== null && (d.value.style.height = "", d.value.style.width = "", k = setTimeout(() => {
            f.value = !1, c.value = !1, n("hidden");
          }, La(d.value)));
        });
      }
    };
    return de(u, () => {
      u.value ? $() : y();
    }), He(() => {
      d.value !== null && !u.value && a.toggle && Ne(() => {
        u.value = !0;
      });
    }), de(
      () => a.skipAnimation,
      (A) => {
        g = A;
      }
    ), a.visible && (g = !0, u.value = !0, Ne(() => {
      g = a.skipAnimation;
    })), de(
      () => a.visible,
      (A) => {
        g = !0, A ? m() : v(), Ne(() => {
          g = a.skipAnimation;
        });
      }
    ), $e(d, "bv-toggle", () => {
      u.value = !u.value;
    }), o({
      hide: v,
      isNav: a.isNav,
      show: m,
      toggle: B,
      visible: Oe(f)
    }), We(fl, {
      id: i,
      hide: v,
      show: m,
      toggle: B,
      visible: Oe(f),
      isNav: T(() => a.isNav)
    }), (A, S) => (b(), O(pe, null, [
      V(A.$slots, "header", _e(Se(w.value))),
      (b(), L(fe(s(a).tag), J({
        id: s(i),
        ref_key: "element",
        ref: d,
        class: ["collapse", p.value],
        "is-nav": s(a).isNav
      }, A.$attrs), {
        default: R(() => [
          V(A.$slots, "default", _e(Se(w.value)))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      V(A.$slots, "footer", _e(Se(w.value)))
    ], 64));
  }
}), Ji = ["aria-expanded", "aria-controls", "onClick"], Qi = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: /* @__PURE__ */ be({
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    buttonAttrs: { default: void 0 },
    buttonClass: { default: void 0 },
    collapseClass: { default: void 0 },
    headerAttrs: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "h2" },
    horizontal: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    tag: { default: void 0 },
    title: { default: void 0 },
    toggle: { type: Boolean, default: void 0 },
    visible: { type: Boolean, default: !1 },
    wrapperAttrs: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { emit: o }) {
    const { class: e, ...l } = Lt(), n = U(t, "BAccordionItem"), r = o, u = we(t, "modelValue"), i = Ve(Jo, null), d = Ce(() => n.id, "accordion_item");
    return He(() => {
      u.value && !(i != null && i.free.value) && (i == null || i.setOpenItem(d.value)), !u.value && (i == null ? void 0 : i.openItem.value) === d.value && (u.value = !0);
    }), de(
      () => i == null ? void 0 : i.openItem.value,
      () => u.value = (i == null ? void 0 : i.openItem.value) === d.value && !(i != null && i.free.value)
    ), de(u, () => {
      u.value && !(i != null && i.free.value) && (i == null || i.setOpenItem(d.value));
    }), (c, f) => (b(), O("div", J({ class: "accordion-item" }, s(n).wrapperAttrs, { class: s(e) }), [
      ge(qn, J({
        id: s(d),
        modelValue: u.value,
        "onUpdate:modelValue": f[0] || (f[0] = (p) => u.value = p),
        class: ["accordion-collapse", s(n).collapseClass],
        "aria-labelledby": `${s(d)}-heading`
      }, l, {
        tag: s(n).tag,
        toggle: s(n).toggle,
        horizontal: s(n).horizontal,
        visible: s(n).visible,
        "is-nav": s(n).isNav,
        onShow: f[1] || (f[1] = (p) => r("show", p)),
        onShown: f[2] || (f[2] = (p) => r("shown")),
        onHide: f[3] || (f[3] = (p) => r("hide", p)),
        onHidden: f[4] || (f[4] = (p) => r("hidden")),
        onHidePrevented: f[5] || (f[5] = (p) => r("hide-prevented")),
        onShowPrevented: f[6] || (f[6] = (p) => r("show-prevented"))
      }), {
        header: R(({ visible: p, toggle: v }) => [
          (b(), L(fe(s(n).headerTag), J({
            id: `${s(d)}-heading`,
            class: ["accordion-header", s(n).headerClass]
          }, s(n).headerAttrs), {
            default: R(() => [
              ae("button", J({ class: "accordion-button" }, s(n).buttonAttrs, {
                class: [{ collapsed: !p }, s(n).buttonClass],
                type: "button",
                "aria-expanded": p ? "true" : "false",
                "aria-controls": s(d),
                onClick: v
              }), [
                V(c.$slots, "title", {}, () => [
                  ce(oe(s(n).title), 1)
                ])
              ], 16, Ji)
            ]),
            _: 2
          }, 1040, ["id", "class"]))
        ]),
        default: R(() => [
          ae("div", J({ class: "accordion-body" }, s(n).bodyAttrs, {
            class: s(n).bodyClass
          }), [
            V(c.$slots, "default")
          ], 16)
        ]),
        _: 3
      }, 16, ["id", "modelValue", "class", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ], 16));
  }
}), eu = /* @__PURE__ */ G({
  __name: "BAlert",
  props: /* @__PURE__ */ be({
    closeClass: { default: void 0 },
    closeContent: { default: void 0 },
    closeLabel: { default: "Close" },
    closeVariant: { default: "secondary" },
    dismissible: { type: Boolean, default: !1 },
    fade: { type: Boolean, default: !1 },
    immediate: { type: Boolean, default: !0 },
    interval: { default: 1e3 },
    modelValue: { type: [Boolean, Number] },
    noHoverPause: { type: Boolean, default: !1 },
    showOnPause: { type: Boolean, default: !0 },
    variant: { default: "info" }
  }, {
    modelValue: { type: [Boolean, Number], default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["close", "close-countdown", "closed"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BAlert"), n = e, r = De(), u = H(null), i = we(t, "modelValue"), d = ul(u), c = Be(() => a.interval), f = T(() => !Pe(r.close)), p = T(() => typeof i.value == "boolean" ? 0 : i.value), v = h(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": a.dismissible
    })), m = h(() => [a.closeClass, { "btn-close-custom": f.value }]), {
      isActive: B,
      pause: w,
      restart: _,
      resume: k,
      stop: g,
      isPaused: $,
      value: y
    } = fn(p, c, {
      immediate: typeof i.value == "number" && a.immediate
    }), A = T(
      () => typeof i.value == "boolean" ? i.value : B.value || a.showOnPause && $.value
    ), S = h(() => ({
      variant: f.value ? a.closeVariant : void 0,
      class: m.value
    }));
    Et(() => {
      n("close-countdown", y.value);
    });
    const Y = () => {
      n("close"), typeof i.value == "boolean" ? i.value = !1 : (i.value = 0, g()), n("closed");
    }, K = () => {
      a.noHoverPause || w();
    };
    return de(d, (P) => {
      if (P) {
        K();
        return;
      }
      k();
    }), Qa(g), o({
      pause: w,
      restart: _,
      resume: k,
      stop: g
    }), (P, j) => (b(), L($a, {
      "no-fade": !s(a).fade,
      "trans-props": { enterToClass: "show" }
    }, {
      default: R(() => [
        A.value ? (b(), O("div", {
          key: 0,
          ref_key: "element",
          ref: u,
          class: W(["alert", v.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          V(P.$slots, "default", {}, void 0, !0),
          s(a).dismissible ? (b(), O(pe, { key: 0 }, [
            f.value || s(a).closeContent ? (b(), L(vt, J({ key: 0 }, S.value, { onClick: Y }), {
              default: R(() => [
                V(P.$slots, "close", {}, () => [
                  ce(oe(s(a).closeContent), 1)
                ], !0)
              ]),
              _: 3
            }, 16)) : (b(), L(zt, J({
              key: 1,
              "aria-label": s(a).closeLabel
            }, S.value, { onClick: Y }), null, 16, ["aria-label"]))
          ], 64)) : ne("", !0)
        ], 2)) : ne("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), tu = /* @__PURE__ */ Rn(eu, [["__scopeId", "data-v-96a91b13"]]), Yt = G({
  name: "RenderComponentOrSkip",
  inheritAttrs: !1,
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(t, { slots: o, attrs: e }) {
    return () => {
      var l, a, n;
      return t.skip ? (l = o.default) == null ? void 0 : l.call(o) : t.tag === "Teleport" ? Ie(_t, { to: t.to }, [(a = o.default) == null ? void 0 : a.call(o)]) : Ie(t.tag, { ...e }, [(n = o.default) == null ? void 0 : n.call(o)]);
    };
  }
}), Wn = /* @__PURE__ */ G({
  __name: "BBadge",
  props: {
    dotIndicator: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    placement: { default: void 0 },
    tag: { default: "span" },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = U(t, "BBadge"), l = st(e), { computedLink: a, computedLinkProps: n } = Ct(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), r = T(() => a.value ? it : e.tag), u = h(() => {
      const d = e.placement ?? (e.dotIndicator ? "top-end" : void 0);
      return [
        "position-absolute",
        "translate-middle",
        {
          "start-0 top-0": d === "top-start",
          "start-0 top-50": d === "start",
          "start-0 top-100": d === "bottom-start",
          "start-50 top-0": d === "top",
          "start-50 top-100": d === "bottom",
          "start-100 top-0": d === "top-end",
          "start-100 top-50": d === "end",
          "start-100 top-100": d === "bottom-end"
        }
      ];
    }), i = h(() => [
      l.value,
      e.placement !== void 0 || e.dotIndicator === !0 ? u.value : void 0,
      {
        active: e.active,
        disabled: e.disabled,
        "rounded-pill": e.pill,
        "p-2 border border-light rounded-circle": e.dotIndicator,
        "text-decoration-none": a.value
      }
    ]);
    return (d, c) => (b(), L(fe(r.value), J({
      class: ["badge", i.value]
    }, s(n)), {
      default: R(() => [
        ge(Yt, J({
          skip: s(e).dotIndicator !== !0,
          tag: "span"
        }, s(e).dotIndicator ? { class: "visually-hidden" } : {}), {
          default: R(() => [
            V(d.$slots, "default")
          ]),
          _: 3
        }, 16, ["skip"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), au = {
  key: 0,
  class: "b-avatar-custom"
}, lu = {
  key: 1,
  class: "b-avatar-img"
}, ou = ["src", "alt"], nu = {
  key: 3,
  class: "b-avatar-img"
}, su = /* @__PURE__ */ ae("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "80%",
  height: "80%",
  fill: "currentColor",
  class: "bi bi-person-fill",
  viewBox: "0 0 16 16"
}, [
  /* @__PURE__ */ ae("path", { d: "M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6" })
], -1), ru = [
  su
], Yl = 0.4, iu = /* @__PURE__ */ G({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: !1 },
    badgeBgVariant: { default: null },
    badgePlacement: { default: "bottom-end" },
    badgeTextVariant: { default: null },
    badgeVariant: { default: "primary" },
    badgePill: { type: Boolean, default: !1 },
    badgeDotIndicator: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonType: { default: "button" },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: {},
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: "circle" },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(t, { emit: o }) {
    const e = t, l = o, a = De(), { computedLink: n, computedLinkProps: r } = Ct(e), u = Ve(Zo, null), i = ["sm", null, "lg"], d = Yl * 0.7, c = T(() => !Pe(a.default)), f = T(() => !Pe(a.badge)), p = T(() => !!e.badge || e.badge === "" || f.value), v = T(() => (u == null ? void 0 : u.square.value) || e.square), m = ga(() => e.size), B = ga(() => u == null ? void 0 : u.size.value), w = h(() => B.value ?? m.value), _ = T(() => (u == null ? void 0 : u.variant.value) ?? e.variant), k = T(() => (u == null ? void 0 : u.rounded.value) ?? e.rounded), g = T(() => (u == null ? void 0 : u.roundedTop.value) ?? e.roundedTop), $ = T(() => (u == null ? void 0 : u.roundedBottom.value) ?? e.roundedBottom), y = T(() => (u == null ? void 0 : u.roundedStart.value) ?? e.roundedStart), A = T(() => (u == null ? void 0 : u.roundedEnd.value) ?? e.roundedEnd), S = yl(() => ({
      rounded: k.value,
      roundedTop: g.value,
      roundedBottom: $.value,
      roundedStart: y.value,
      roundedEnd: A.value
    })), Y = T(() => e.badge === !0 ? "" : e.badge), K = h(() => !Y.value && !f.value), P = T(() => (u == null ? void 0 : u.textVariant.value) ?? e.textVariant), j = T(() => (u == null ? void 0 : u.bgVariant.value) ?? e.bgVariant), F = st(() => ({
      bgVariant: j.value,
      textVariant: P.value,
      variant: _.value
    })), N = h(() => [
      F.value,
      // Square overwrites all else
      v.value === !0 ? void 0 : S.value,
      {
        [`b-avatar-${e.size}`]: !!e.size && i.indexOf(m.value) !== -1,
        [`btn-${_.value}`]: e.button ? _.value !== null : !1,
        badge: !e.button && _.value !== null && c.value,
        btn: e.button,
        // Square is the same as rounded-0 class
        "rounded-0": v.value === !0
      }
    ]), z = h(() => ({
      fontSize: i.indexOf(w.value || null) === -1 ? `calc(${w.value} * ${d})` : ""
    })), C = h(() => {
      const M = i.indexOf(w.value || null) === -1 ? `calc(${w.value} * ${Yl})` : null;
      return M ? { fontSize: M } : {};
    }), x = h(() => {
      var Z;
      const M = ((Z = u == null ? void 0 : u.overlapScale) == null ? void 0 : Z.value) || 0, Q = w.value && M ? `calc(${w.value} * -${M})` : null;
      return Q ? { marginLeft: Q, marginRight: Q } : {};
    }), E = T(() => n.value ? it : e.button ? "button" : "span"), I = h(() => ({
      ...x.value,
      width: w.value ?? void 0,
      height: w.value ?? void 0
    })), X = (M) => {
      !e.disabled && (n.value || e.button) && l("click", M);
    }, D = (M) => {
      l("img-error", M);
    };
    return (M, Q) => (b(), L(fe(E.value), J({
      class: ["b-avatar", N.value],
      style: I.value
    }, s(r), {
      type: e.button && !s(n) ? e.buttonType : void 0,
      disabled: e.disabled || null,
      onClick: X
    }), {
      default: R(() => [
        c.value ? (b(), O("span", au, [
          V(M.$slots, "default")
        ])) : e.src ? (b(), O("span", lu, [
          ae("img", {
            src: e.src,
            alt: e.alt,
            onError: D
          }, null, 40, ou)
        ])) : e.text ? (b(), O("span", {
          key: 2,
          class: "b-avatar-text",
          style: ze(C.value)
        }, oe(e.text), 5)) : (b(), O("span", nu, ru)),
        p.value ? (b(), L(Wn, {
          key: 4,
          pill: e.badgePill,
          "dot-indicator": e.badgeDotIndicator || K.value,
          variant: e.badgeVariant,
          "bg-variant": e.badgeBgVariant,
          "text-variant": e.badgeTextVariant,
          style: ze(z.value),
          placement: e.badgePlacement
        }, {
          default: R(() => [
            V(M.$slots, "badge", {}, () => [
              ce(oe(Y.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["pill", "dot-indicator", "variant", "bg-variant", "text-variant", "style", "placement"])) : ne("", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
}), uu = /* @__PURE__ */ G({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: "circle" },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = U(t, "BAvatarGroup"), l = Be(() => e.overlap), a = ga(() => e.size), n = T(() => Math.min(Math.max(l.value, 0), 1) / 2), r = h(() => {
      const u = a.value ? `calc(${a.value} * ${n.value})` : null;
      return u ? { paddingLeft: u, paddingRight: u } : {};
    });
    return We(Zo, {
      overlapScale: n,
      size: T(() => e.size),
      square: T(() => e.square),
      rounded: T(() => e.rounded),
      roundedTop: T(() => e.roundedTop),
      roundedBottom: T(() => e.roundedBottom),
      roundedStart: T(() => e.roundedStart),
      roundedEnd: T(() => e.roundedEnd),
      variant: T(() => e.variant),
      bgVariant: T(() => e.bgVariant),
      textVariant: T(() => e.textVariant)
    }), (u, i) => (b(), L(fe(s(e).tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: R(() => [
        ae("div", {
          class: "b-avatar-group-inner",
          style: ze(r.value)
        }, [
          V(u.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), Un = /* @__PURE__ */ G({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BBreadcrumbItem"), a = o, n = h(() => ({
      active: l.active
    })), r = T(() => l.active ? "span" : it), u = T(() => l.active ? l.ariaCurrent : void 0), i = h(
      () => r.value !== "span" ? pl(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), d = (c) => {
      if (l.disabled || l.active) {
        c.preventDefault(), c.stopImmediatePropagation();
        return;
      }
      l.disabled || a("click", c);
    };
    return (c, f) => (b(), O("li", {
      class: W(["breadcrumb-item", n.value])
    }, [
      (b(), L(fe(r.value), J({ "aria-current": u.value }, i.value, { onClick: d }), {
        default: R(() => [
          V(c.$slots, "default", {}, () => [
            ce(oe(s(l).text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), du = { "aria-label": "breadcrumb" }, cu = { class: "breadcrumb" }, fu = /* @__PURE__ */ G({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BBreadcrumb"), l = cn(), a = h(() => {
      var i;
      const n = e.items || ((i = l.items) == null ? void 0 : i.value) || [];
      let r = !1;
      return n.map((d, c) => (typeof d == "string" && (d = { text: d }, c < n.length - 1 && (d.href = "#")), d.active && (r = !0), !d.active && !r && (d.active = c + 1 === n.length), d));
    });
    return (n, r) => (b(), O("nav", du, [
      ae("ol", cu, [
        V(n.$slots, "prepend"),
        (b(!0), O(pe, null, ke(a.value, (u, i) => (b(), L(Un, J({
          key: i,
          ref_for: !0
        }, u), {
          default: R(() => [
            ce(oe(u.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        V(n.$slots, "default"),
        V(n.$slots, "append")
      ])
    ]));
  }
}), vu = /* @__PURE__ */ G({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = U(t, "BButtonGroup"), l = h(() => ({
      "btn-group": !e.vertical,
      [`btn-group-${e.size}`]: e.size !== "md",
      "btn-group-vertical": e.vertical
    }));
    return (a, n) => (b(), L(fe(s(e).tag), {
      class: W(l.value),
      role: "group",
      "aria-label": s(e).ariaLabel
    }, {
      default: R(() => [
        V(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), pu = ["role", "aria-label"], mu = /* @__PURE__ */ G({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: Boolean, default: !1 },
    role: { default: "toolbar" }
  },
  setup(t) {
    const e = U(t, "BButtonToolbar"), l = h(() => ({
      "justify-content-between": e.justify
    }));
    return (a, n) => (b(), O("div", {
      class: W([l.value, "btn-toolbar"]),
      role: s(e).role,
      "aria-label": s(e).ariaLabel
    }, [
      V(a.$slots, "default")
    ], 10, pu));
  }
}), gl = /* @__PURE__ */ G({
  __name: "BImg",
  props: {
    blank: { type: Boolean, default: !1 },
    blankColor: { default: "transparent" },
    block: { type: Boolean, default: !1 },
    fluid: { type: Boolean, default: !1 },
    fluidGrow: { type: Boolean, default: !1 },
    height: { default: void 0 },
    tag: { default: "img" },
    lazy: { type: Boolean, default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: Boolean, default: !1 },
    width: { default: void 0 },
    placement: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = U(t, "BImg"), l = Be(() => e.height ?? NaN), a = Be(() => e.width ?? NaN), n = yl(() => ({
      rounded: e.rounded,
      roundedTop: e.roundedTop,
      roundedBottom: e.roundedBottom,
      roundedStart: e.roundedStart,
      roundedEnd: e.roundedEnd
    })), r = h(
      () => typeof e.srcset == "string" ? e.srcset.split(",").filter((v) => v).join(",") : Array.isArray(e.srcset) ? e.srcset.filter((v) => v).join(",") : void 0
    ), u = h(
      () => typeof e.sizes == "string" ? e.sizes.split(",").filter((v) => v).join(",") : Array.isArray(e.sizes) ? e.sizes.filter((v) => v).join(",") : void 0
    ), i = h(() => {
      const v = Number.isNaN(a.value) ? void 0 : a.value, m = Number.isNaN(l.value) ? void 0 : l.value;
      if (e.blank) {
        if (v !== void 0 && m === void 0)
          return { height: v, width: v };
        if (v === void 0 && m !== void 0)
          return { height: m, width: m };
        if (v === void 0 && m === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: v,
        height: m
      };
    }), d = T(
      () => p(i.value.width, i.value.height, e.blankColor)
    ), c = h(() => ({
      "float-start": e.placement === "start",
      "float-end": e.placement === "end",
      "mx-auto": e.placement === "center"
    })), f = h(() => [
      n.value,
      c.value,
      {
        "img-thumbnail": e.thumbnail,
        "img-fluid": e.fluid || e.fluidGrow,
        "w-100": e.fluidGrow,
        "d-block": e.block || e.placement === "center"
      }
    ]), p = (v, m, B) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width="${v}" height="${m}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${v} ${m}" preserveAspectRatio="none">
    <rect width="100%" height="100%" style="fill:${B};"></rect>
    </svg>`)}`;
    return (v, m) => (b(), L(fe(s(e).tag), {
      class: W(f.value),
      src: s(e).blank ? d.value : s(e).src,
      width: i.value.width || void 0,
      height: i.value.height || void 0,
      srcset: s(e).blank ? void 0 : r.value,
      sizes: s(e).blank ? void 0 : u.value,
      loading: s(e).lazy ? "lazy" : "eager"
    }, null, 8, ["class", "src", "width", "height", "srcset", "sizes", "loading"]));
  }
}), hl = /* @__PURE__ */ G({
  __name: "BCardImg",
  props: {
    placement: { default: "top" },
    blank: { type: Boolean, default: void 0 },
    blankColor: { default: void 0 },
    block: { type: Boolean, default: void 0 },
    fluid: { type: Boolean, default: void 0 },
    fluidGrow: { type: Boolean, default: void 0 },
    height: { default: void 0 },
    tag: {},
    lazy: { type: Boolean, default: void 0 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: Boolean, default: void 0 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: void 0 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = U(t, "BCardImg"), l = h(() => ({
      "card-img-top": e.placement === "top",
      // TODO implement this class
      "card-img-end": e.placement === "end",
      "card-img-bottom": e.placement === "bottom",
      // TODO implement this class
      "card-img-start": e.placement === "start",
      "card-img": e.placement === "overlay"
    })), a = h(() => xa(e, ["placement"]));
    return (n, r) => (b(), L(gl, J(a.value, { class: l.value }), null, 16, ["class"]));
  }
}), bu = ["innerHTML"], Kn = /* @__PURE__ */ G({
  __name: "BCardHeadFoot",
  props: {
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const o = t, e = st(o), l = h(() => [
      e.value,
      {
        [`border-${o.borderVariant}`]: o.borderVariant !== null
      }
    ]);
    return (a, n) => (b(), L(fe(a.tag), {
      class: W(l.value)
    }, {
      default: R(() => [
        a.html ? (b(), O("div", {
          key: 0,
          innerHTML: a.html
        }, null, 8, bu)) : V(a.$slots, "default", { key: 1 }, () => [
          ce(oe(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Xn = /* @__PURE__ */ G({
  __name: "BCardHeader",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BCardHeader");
    return (l, a) => (b(), L(Kn, J({ class: "card-header" }, s(e)), {
      default: R(() => [
        V(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Yn = /* @__PURE__ */ G({
  __name: "BCardTitle",
  props: {
    tag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BCardTitle");
    return (l, a) => (b(), L(fe(s(e).tag), { class: "card-title" }, {
      default: R(() => [
        V(l.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Zn = /* @__PURE__ */ G({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(t) {
    const e = U(t, "BCardSubtitle"), l = h(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null
    }));
    return (a, n) => (b(), L(fe(s(e).tag), {
      class: W(["card-subtitle mb-2", l.value])
    }, {
      default: R(() => [
        V(a.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Jn = /* @__PURE__ */ G({
  __name: "BCardBody",
  props: {
    overlay: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = U(t, "BCardBody"), l = De(), a = st(e), n = T(() => !Pe(l.title)), r = T(() => !Pe(l.subtitle)), u = h(() => [
      a.value,
      e.overlay ? "card-img-overlay" : "card-body"
    ]);
    return (i, d) => (b(), L(fe(s(e).tag), {
      class: W(u.value)
    }, {
      default: R(() => [
        s(e).title || n.value ? (b(), L(Yn, {
          key: 0,
          tag: s(e).titleTag
        }, {
          default: R(() => [
            V(i.$slots, "title", {}, () => [
              ce(oe(s(e).title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : ne("", !0),
        s(e).subtitle || r.value ? (b(), L(Zn, {
          key: 1,
          tag: s(e).subtitleTag,
          "text-variant": s(e).subtitleTextVariant
        }, {
          default: R(() => [
            V(i.$slots, "subtitle", {}, () => [
              ce(oe(s(e).subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : ne("", !0),
        V(i.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Qn = /* @__PURE__ */ G({
  __name: "BCardFooter",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BCardFooter");
    return (l, a) => (b(), L(Kn, J({ class: "card-footer" }, s(e)), {
      default: R(() => [
        V(l.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), es = /* @__PURE__ */ G({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyText: { default: "" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    footerVariant: { default: null },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    headerVariant: { default: null },
    imgAlt: { default: void 0 },
    imgPlacement: { default: "top" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgWidth: { default: void 0 },
    noBody: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = U(t, "BCard"), l = De(), a = T(() => !Pe(l.header)), n = T(() => !Pe(l.footer)), r = st(e), u = h(() => [
      r.value,
      {
        [`text-${e.align}`]: e.align !== void 0,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "flex-row": e.imgPlacement === "start",
        "flex-row-reverse": e.imgPlacement === "end"
      }
    ]), i = h(() => ({
      src: e.imgSrc,
      alt: e.imgAlt,
      height: e.imgHeight,
      width: e.imgWidth,
      placement: e.imgPlacement
    })), d = va();
    return (c, f) => (b(), L(fe(s(e).tag), {
      class: W(["card", u.value])
    }, {
      default: R(() => [
        ge(s(d).define, null, {
          default: R(() => [
            V(c.$slots, "img", {}, () => [
              s(e).imgSrc ? (b(), L(hl, _e(J({ key: 0 }, i.value)), null, 16)) : ne("", !0)
            ])
          ]),
          _: 3
        }),
        s(e).imgPlacement !== "bottom" ? (b(), L(s(d).reuse, { key: 0 })) : ne("", !0),
        s(e).header || a.value || s(e).headerHtml ? (b(), L(Xn, {
          key: 1,
          "bg-variant": s(e).headerBgVariant,
          variant: s(e).headerVariant,
          "border-variant": s(e).headerBorderVariant,
          html: s(e).headerHtml,
          tag: s(e).headerTag,
          "text-variant": s(e).headerTextVariant,
          class: W(s(e).headerClass)
        }, {
          default: R(() => [
            V(c.$slots, "header", {}, () => [
              ce(oe(s(e).header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : ne("", !0),
        s(e).noBody ? V(c.$slots, "default", { key: 3 }, () => [
          ce(oe(s(e).bodyText), 1)
        ]) : (b(), L(Jn, {
          key: 2,
          overlay: s(e).imgPlacement === "overlay",
          "bg-variant": s(e).bodyBgVariant,
          tag: s(e).bodyTag,
          "text-variant": s(e).bodyTextVariant,
          subtitle: s(e).subtitle,
          "subtitle-tag": s(e).subtitleTag,
          "subtitle-text-variant": s(e).subtitleTextVariant,
          title: s(e).title,
          "title-tag": s(e).titleTag,
          class: W(s(e).bodyClass)
        }, {
          default: R(() => [
            V(c.$slots, "default", {}, () => [
              ce(oe(s(e).bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        s(e).footer || n.value || s(e).footerHtml ? (b(), L(Qn, {
          key: 4,
          "bg-variant": s(e).footerBgVariant,
          "border-variant": s(e).footerBorderVariant,
          variant: s(e).footerVariant,
          html: s(e).footerHtml,
          tag: s(e).footerTag,
          "text-variant": s(e).footerTextVariant,
          class: W(s(e).footerClass)
        }, {
          default: R(() => [
            V(c.$slots, "footer", {}, () => [
              ce(oe(s(e).footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : ne("", !0),
        s(e).imgPlacement === "bottom" ? (b(), L(s(d).reuse, { key: 5 })) : ne("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), yu = /* @__PURE__ */ G({
  __name: "BCardGroup",
  props: {
    columns: { type: Boolean, default: !1 },
    deck: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = U(t, "BCardGroup"), l = T(
      () => e.deck ? "card-deck" : e.columns ? "card-columns" : "card-group"
    );
    return (a, n) => (b(), L(fe(s(e).tag), {
      class: W(l.value)
    }, {
      default: R(() => [
        V(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), gu = /* @__PURE__ */ G({
  __name: "BCardText",
  props: {
    tag: { default: "p" },
    text: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BCardText");
    return (l, a) => (b(), L(fe(s(e).tag), { class: "card-text" }, {
      default: R(() => [
        V(l.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), hu = ["id"], Bu = {
  key: 0,
  class: "carousel-indicators"
}, _u = ["aria-current", "aria-label", "onClick"], wu = /* @__PURE__ */ ae("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Cu = { class: "visually-hidden" }, ku = /* @__PURE__ */ ae("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Tu = { class: "visually-hidden" }, Su = /* @__PURE__ */ G({
  __name: "BCarousel",
  props: /* @__PURE__ */ be({
    background: { default: void 0 },
    controls: { type: Boolean, default: !1 },
    controlsNextText: { default: "Next" },
    controlsPrevText: { default: "Previous" },
    fade: { type: Boolean, default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    indicators: { type: Boolean, default: !1 },
    indicatorsButtonLabel: { default: "Slide" },
    interval: { default: 5e3 },
    keyboard: { type: Boolean, default: !0 },
    modelValue: {},
    noHoverPause: { type: Boolean, default: !1 },
    noTouch: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    ride: { type: [Boolean, String], default: !1 },
    rideReverse: { type: Boolean, default: !1 },
    touchThreshold: { default: 50 }
  }, {
    modelValue: { default: 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["slide", "slid"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BCarousel"), n = e, r = De(), u = Ce(() => a.id, "carousel"), i = we(t, "modelValue"), d = H(null), c = Be(() => a.touchThreshold), f = H(null);
    He(() => {
      var Z, q;
      f.value = ((q = (Z = d.value) == null ? void 0 : Z.find((se) => se.$el.style.display !== "none")) == null ? void 0 : q._interval) ?? null;
    });
    const p = Be(() => f.value ?? a.interval), v = H(!1), m = H(!1), B = H(!0), w = H(null), _ = H(null), k = H(i.value), g = ul(_), $ = T(
      () => `carousel-item carousel-item-${B.value ? "prev" : "next"} carousel-item-${B.value ? "end" : "start"}`
    ), y = T(
      () => `carousel-item active carousel-item-${B.value ? "start" : "end"}`
    ), { pause: A, resume: S } = Mo(
      () => {
        a.rideReverse ? N() : z();
      },
      p,
      { immediate: a.ride === "carousel" }
    ), Y = T(
      () => a.ride === !0 && m.value === !0 || a.ride === "carousel"
    ), K = h(() => Dr(r.default, "BCarouselSlide")), P = h(() => ({ "carousel-fade": a.fade })), j = (Z) => {
      var q;
      return new po(Z, {
        componentId: u.value,
        cancelable: !1,
        target: _.value,
        direction: B.value ? "right" : "left",
        from: k.value,
        to: i.value,
        relatedTarget: ((q = w.value) == null ? void 0 : q.children[i.value]) ?? null
      });
    }, F = (Z) => {
      if (v.value !== !0) {
        if (a.ride === !0 && (m.value = !0), Y.value === !0 && S(), B.value = !(Z < i.value), Z >= K.value.length) {
          if (a.noWrap)
            return;
          i.value = 0;
          return;
        }
        if (Z < 0) {
          if (a.noWrap)
            return;
          i.value = K.value.length - 1;
          return;
        }
        k.value = i.value, i.value = Z;
      }
    }, N = () => {
      F(i.value - 1);
    }, z = () => {
      F(i.value + 1);
    }, C = (Z) => {
      a.keyboard !== !1 && Z();
    }, x = () => {
      a.noHoverPause || A();
    }, E = () => {
      Y.value && S();
    }, { lengthX: I } = Pr(_, {
      passive: !0,
      onSwipeStart() {
        a.noTouch !== !0 && A();
      },
      onSwipeEnd() {
        if (a.noTouch === !0)
          return;
        const Z = () => {
          Y.value !== !1 && S();
        };
        if (I.value >= c.value) {
          z(), Z();
          return;
        }
        I.value <= -c.value && (N(), Z());
      }
    }), X = () => {
      n("slide", j("slide")), v.value = !0;
    }, D = () => {
      n("slid", j("slid")), v.value = !1;
    }, M = (Z) => {
      i.value !== 0 && Z.classList.add("carousel-item");
    }, Q = (Z) => {
      var q, se;
      f.value = ((se = (q = d.value) == null ? void 0 : q.find((ie) => ie.$el === Z)) == null ? void 0 : se._interval) ?? null;
    };
    return qe(
      "ArrowLeft",
      () => {
        C(N);
      },
      { target: _ }
    ), qe(
      "ArrowRight",
      () => {
        C(z);
      },
      { target: _ }
    ), de(
      () => a.ride,
      () => {
        m.value = !1;
      }
    ), de(g, (Z) => {
      if (Z) {
        x();
        return;
      }
      E();
    }), o({
      next: z,
      pause: A,
      prev: N,
      resume: S
    }), We(Uo, {
      background: T(() => a.background),
      width: T(() => a.imgWidth),
      height: T(() => a.imgHeight)
    }), (Z, q) => (b(), O("div", {
      id: s(u),
      ref_key: "element",
      ref: _,
      class: W(["carousel slide pointer-event", P.value])
    }, [
      s(a).indicators ? (b(), O("div", Bu, [
        (b(!0), O(pe, null, ke(K.value.length, (se, ie) => (b(), O("button", {
          key: ie,
          type: "button",
          "data-bs-target": "",
          class: W(ie === i.value ? "active" : ""),
          "aria-current": ie === i.value ? !0 : void 0,
          "aria-label": `${s(a).indicatorsButtonLabel} ${ie}`,
          onClick: (te) => F(ie)
        }, null, 10, _u))), 128))
      ])) : ne("", !0),
      ae("div", {
        ref_key: "relatedTarget",
        ref: w,
        class: "carousel-inner"
      }, [
        ge(vo, {
          "enter-from-class": $.value,
          "enter-active-class": $.value,
          "enter-to-class": $.value,
          "leave-from-class": y.value,
          "leave-active-class": y.value,
          "leave-to-class": y.value,
          onBeforeLeave: X,
          onAfterLeave: D,
          onAfterEnter: M,
          onEnter: Q
        }, {
          default: R(() => [
            (b(!0), O(pe, null, ke(K.value, (se, ie) => dt((b(), L(fe(se), {
              key: ie,
              ref_for: !0,
              ref_key: "slideValues",
              ref: d,
              class: W({ active: ie === i.value && v.value === !1 })
            }, null, 8, ["class"])), [
              [Kt, ie === i.value]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      s(a).controls ? (b(), O(pe, { key: 1 }, [
        ae("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: N
        }, [
          wu,
          ae("span", Cu, oe(s(a).controlsPrevText), 1)
        ]),
        ae("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: z
        }, [
          ku,
          ae("span", Tu, oe(s(a).controlsNextText), 1)
        ])
      ], 64)) : ne("", !0)
    ], 10, hu));
  }
}), xu = ["innerHTML"], $u = { key: 1 }, Au = ["innerHTML"], Vu = { key: 1 }, Fu = /* @__PURE__ */ G({
  __name: "BCarouselSlide",
  props: {
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: Boolean, default: !1 },
    imgBlankColor: { default: "transparent" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(t, { expose: o }) {
    const l = U(t, "BCarouselSlide"), a = De(), n = Ve(Uo, null), r = T(() => l.text || l.textHtml || !Pe(a.text)), u = T(() => l.caption || l.captionHtml || !Pe(a.caption)), i = T(() => r.value || u.value || !Pe(a.default)), d = h(() => ({
      background: `${l.background || (n == null ? void 0 : n.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), c = h(() => ({
      "d-none": l.contentVisibleUp !== void 0,
      [`d-${l.contentVisibleUp}-block`]: l.contentVisibleUp !== void 0
    }));
    return o({
      _interval: T(() => l.interval)
    }), (f, p) => (b(), O("div", {
      class: "carousel-item",
      style: ze(d.value)
    }, [
      V(f.$slots, "img", {}, () => {
        var v, m;
        return [
          ge(gl, {
            class: "d-block w-100",
            alt: s(l).imgAlt,
            srcset: s(l).imgSrcset,
            src: s(l).imgSrc,
            width: s(l).imgWidth || ((v = s(n)) == null ? void 0 : v.width.value),
            height: s(l).imgHeight || ((m = s(n)) == null ? void 0 : m.height.value),
            blank: s(l).imgBlank,
            "blank-color": s(l).imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      i.value ? (b(), L(fe(s(l).contentTag), {
        key: 0,
        class: W(["carousel-caption", c.value])
      }, {
        default: R(() => [
          u.value ? (b(), L(fe(s(l).captionTag), { key: 0 }, {
            default: R(() => [
              V(f.$slots, "caption", {}, () => [
                s(l).captionHtml ? (b(), O("span", {
                  key: 0,
                  innerHTML: s(l).captionHtml
                }, null, 8, xu)) : (b(), O("span", $u, oe(s(l).caption), 1))
              ])
            ]),
            _: 3
          })) : ne("", !0),
          r.value ? (b(), L(fe(s(l).textTag), { key: 1 }, {
            default: R(() => [
              V(f.$slots, "text", {}, () => [
                s(l).textHtml ? (b(), O("span", {
                  key: 0,
                  innerHTML: s(l).textHtml
                }, null, 8, Au)) : (b(), O("span", Vu, oe(s(l).text), 1))
              ])
            ]),
            _: 3
          })) : ne("", !0),
          V(f.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : ne("", !0)
    ], 4));
  }
}), Dt = /* @__PURE__ */ G({
  __name: "BCol",
  props: {
    alignSelf: { default: void 0 },
    tag: { default: "div" },
    order: { default: void 0 },
    offset: { default: void 0 },
    cols: { default: void 0 },
    col: { type: Boolean, default: !1 },
    offsetSm: { default: void 0 },
    offsetMd: { default: void 0 },
    offsetLg: { default: void 0 },
    offsetXl: { default: void 0 },
    offsetXxl: { default: void 0 },
    orderSm: { default: void 0 },
    orderMd: { default: void 0 },
    orderLg: { default: void 0 },
    orderXl: { default: void 0 },
    orderXxl: { default: void 0 },
    sm: { type: [Boolean, Number, String], default: !1 },
    md: { type: [Boolean, Number, String], default: !1 },
    lg: { type: [Boolean, Number, String], default: !1 },
    xl: { type: [Boolean, Number, String], default: !1 },
    xxl: { type: [Boolean, Number, String], default: !1 }
  },
  setup(t) {
    const e = U(t, "BCol"), l = h(() => [
      ...la(
        {
          sm: e.sm,
          md: e.md,
          lg: e.lg,
          xl: e.xl,
          xxl: e.xxl
        },
        ["sm", "md", "lg", "xl", "xxl"],
        "col"
      ),
      ...la(
        {
          order: e.order,
          orderLg: e.orderLg,
          orderMd: e.orderMd,
          orderSm: e.orderSm,
          orderXl: e.orderXl,
          orderXxl: e.orderXxl
        },
        ["order", "orderLg", "orderMd", "orderSm", "orderXl", "orderXxl"],
        "order"
      ),
      ...la(
        {
          offset: e.offset,
          offsetLg: e.offsetLg,
          offsetMd: e.offsetMd,
          offsetSm: e.offsetSm,
          offsetXl: e.offsetXl,
          offsetXxl: e.offsetXxl
        },
        ["offset", "offsetLg", "offsetMd", "offsetSm", "offsetXl", "offsetXxl"],
        "offset"
      )
    ]), a = h(() => [
      l.value,
      {
        col: e.col || !l.value.some((n) => n.startsWith("col-")) && !e.cols,
        [`col-${e.cols}`]: e.cols !== void 0,
        [`offset-${e.offset}`]: e.offset !== void 0,
        [`order-${e.order}`]: e.order !== void 0,
        [`align-self-${e.alignSelf}`]: e.alignSelf !== void 0
      }
    ]);
    return (n, r) => (b(), L(fe(s(e).tag), {
      class: W(a.value)
    }, {
      default: R(() => [
        V(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Nu = /* @__PURE__ */ G({
  __name: "BContainer",
  props: {
    fluid: { type: [Boolean, String], default: !1 },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = U(t, "BContainer"), l = h(() => ({
      container: e.fluid === !1,
      "container-fluid": e.fluid === !0,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== void 0,
      [`gy-${e.gutterY}`]: e.gutterY !== void 0
    }));
    return (a, n) => (b(), L(fe(s(e).tag), {
      class: W(l.value)
    }, {
      default: R(() => [
        V(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ou = { class: "visually-hidden" }, Pu = ["aria-labelledby", "role"], ts = /* @__PURE__ */ G({
  __name: "BDropdown",
  props: /* @__PURE__ */ be({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    skipWrapper: { type: Boolean, default: !1 },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    wrapperClass: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BDropdown"), n = e, r = Ce(() => a.id, "dropdown"), u = we(t, "modelValue"), i = Ve(un, !1), d = T(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), c = Be(d), f = H(null), p = H(null), v = H(null), m = H(null), B = h(
      () => cl(a.boundary) ? a.boundary : void 0
    ), w = h(
      () => Go(a.boundary) ? a.boundary : void 0
    ), _ = T(() => a.split ? p.value : v.value);
    qe(
      "Escape",
      () => {
        u.value = !u.value;
      },
      { target: _ }
    ), qe(
      "Escape",
      () => {
        u.value = !u.value;
      },
      { target: f }
    );
    const k = (x, E) => {
      var X, D, M, Q, Z, q, se;
      if ((D = f.value) != null && D.contains((X = x.target) == null ? void 0 : X.closest("form")) || /input|select|option|textarea|form/i.test((M = x.target) == null ? void 0 : M.tagName))
        return;
      if (x.preventDefault(), !u.value) {
        open(), Ne(() => k(x, E));
        return;
      }
      const I = (Q = f.value) == null ? void 0 : Q.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (I)
        if ((Z = f.value) != null && Z.contains(document.activeElement)) {
          const ie = f.value.querySelector(".dropdown-item:focus"), te = Array.prototype.indexOf.call(I, ie) + E;
          te >= 0 && te < (I == null ? void 0 : I.length) && ((q = I[te]) == null || q.focus());
        } else
          (se = I[E === -1 ? I.length - 1 : 0]) == null || se.focus();
    };
    qe("ArrowUp", (x) => k(x, -1), { target: _ }), qe("ArrowDown", (x) => k(x, 1), { target: _ }), qe("ArrowUp", (x) => k(x, -1), { target: f }), qe("ArrowDown", (x) => k(x, 1), { target: f });
    const g = h(
      () => Mr({
        top: a.dropup,
        start: a.dropstart,
        end: a.dropend,
        alignCenter: a.center,
        alignEnd: a.end
      })
    ), $ = H({}), y = h(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const x = typeof a.offset == "string" || typeof a.offset == "number" ? c.value : a.offset, E = [Bo(x)];
      return a.noFlip === !1 && E.push(
        go({
          boundary: B.value,
          rootBoundary: w.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === !1 && E.push(
        _o({
          boundary: B.value,
          rootBoundary: w.value,
          padding: a.boundaryPadding
        })
      ), a.noSize === !1 && E.push(
        wo({
          boundary: B.value,
          rootBoundary: w.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: I, availableHeight: X }) {
            $.value = {
              maxHeight: X && u.value ? `${X}px` : void 0,
              maxWidth: I && u.value ? `${I}px` : void 0
            };
          }
        })
      ), E;
    }), { update: A, floatingStyles: S } = Po(_, f, {
      placement: g,
      middleware: y,
      strategy: T(() => a.strategy),
      whileElementsMounted: Fo
    }), Y = h(() => [
      a.wrapperClass,
      {
        "btn-group": !a.wrapperClass && a.split,
        dropdown: !a.wrapperClass && !a.split,
        dropup: a.dropup,
        dropend: a.dropend,
        dropstart: a.dropstart,
        "position-static": a.boundary !== "clippingAncestors" && !a.isNav
      }
    ]), K = h(() => [
      a.split ? a.splitClass : a.toggleClass,
      {
        "nav-link": a.isNav,
        "dropdown-toggle": !a.split,
        "dropdown-toggle-no-caret": a.noCaret && !a.split,
        show: a.split ? void 0 : u.value
      }
    ]), P = () => {
      C();
    }, j = (x) => {
      a.split ? n("click", x) : P();
    };
    Ho(
      f,
      () => {
        u.value && (a.autoClose === !0 || a.autoClose === "outside") && C();
      },
      { ignore: [p, v] }
    );
    const F = () => {
      u.value && (a.autoClose === !0 || a.autoClose === "inside") && C();
    }, N = () => {
      u.value && C();
    }, z = () => {
      u.value || C();
    }, C = () => {
      var I, X;
      n("toggle");
      const x = u.value, E = new wt(x ? "hide" : "show");
      if (n(x ? "hide" : "show", E), E.defaultPrevented) {
        n(x ? "hide-prevented" : "show-prevented");
        return;
      }
      u.value = !x, n(x ? "hidden" : "shown"), (X = (I = m.value) == null ? void 0 : I.dispatchEvent) == null || X.call(I, new Event("forceHide"));
    };
    return de(u, () => {
      A();
    }), o({
      hide: N,
      show: z,
      toggle: C
    }), We(tn, {
      id: r,
      show: z,
      hide: N,
      toggle: C,
      visible: T(() => u.value),
      isNav: T(() => a.isNav)
    }), (x, E) => (b(), L(Yt, {
      ref_key: "wrapper",
      ref: m,
      skip: s(i) || s(a).skipWrapper,
      class: W(Y.value)
    }, {
      default: R(() => [
        ge(vt, {
          id: s(r),
          ref_key: "splitButton",
          ref: v,
          variant: s(a).splitVariant || s(a).variant,
          size: s(a).size,
          class: W(K.value),
          disabled: s(a).splitDisabled || s(a).disabled,
          type: s(a).splitButtonType,
          "aria-label": s(a).ariaLabel,
          "aria-expanded": s(a).split ? void 0 : u.value,
          "aria-haspopup": s(a).split ? void 0 : "menu",
          href: s(a).split ? s(a).splitHref : void 0,
          to: s(a).split && s(a).splitTo ? s(a).splitTo : void 0,
          onClick: j
        }, {
          default: R(() => [
            V(x.$slots, "button-content", {}, () => [
              ce(oe(s(a).text), 1)
            ])
          ]),
          _: 3
        }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
        s(a).split ? (b(), L(vt, {
          key: 0,
          ref_key: "button",
          ref: p,
          variant: s(a).variant,
          size: s(a).size,
          disabled: s(a).disabled,
          class: W([[s(a).toggleClass, { show: u.value }], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": u.value,
          "aria-haspopup": "menu",
          onClick: P
        }, {
          default: R(() => [
            ae("span", Ou, [
              V(x.$slots, "toggle-text", {}, () => [
                ce(oe(s(a).toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : ne("", !0),
        (b(), L(_t, {
          to: s(a).teleportTo,
          disabled: !s(a).teleportTo || s(a).teleportDisabled
        }, [
          !s(a).lazy || u.value ? dt((b(), O("ul", {
            key: 0,
            ref_key: "floating",
            ref: f,
            style: ze([s(S), $.value]),
            class: W(["dropdown-menu overflow-auto", [s(a).menuClass, { show: u.value }]]),
            "aria-labelledby": s(r),
            role: s(a).role,
            onClick: F
          }, [
            V(x.$slots, "default", {
              hide: N,
              show: z
            })
          ], 14, Pu)), [
            [Kt, s(a).lazy || u.value]
          ]) : ne("", !0)
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Iu = { role: "presentation" }, Eu = /* @__PURE__ */ G({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(t) {
    const e = U(t, "BDropdownDivider");
    return (l, a) => (b(), O("li", Iu, [
      (b(), L(fe(s(e).tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), Lu = { role: "presentation" }, Ru = /* @__PURE__ */ G({
  __name: "BDropdownForm",
  setup(t) {
    return (o, e) => (b(), O("li", Lu, [
      ae("form", J({ class: "dropdown-item-text" }, o.$attrs), [
        V(o.$slots, "default")
      ], 16)
    ]));
  }
}), zu = { role: "presentation" }, Mu = ["id", "aria-describedby"], Hu = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null },
    id: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BDropdownGroup"), l = T(() => e.id ? `${e.id}_group_dd_header` : void 0), a = T(() => e.headerTag === "header" ? void 0 : "heading"), n = h(() => [
      e.headerClass,
      {
        [`text-${e.headerVariant}`]: e.headerVariant !== null
      }
    ]);
    return (r, u) => (b(), O("li", zu, [
      (b(), L(fe(s(e).headerTag), {
        id: l.value,
        class: W(["dropdown-header", n.value]),
        role: a.value
      }, {
        default: R(() => [
          V(r.$slots, "header", {}, () => [
            ce(oe(s(e).header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      ae("ul", J({
        id: s(e).id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": s(e).ariaDescribedby || l.value
      }), [
        V(r.$slots, "default")
      ], 16, Mu)
    ]));
  }
}), Du = { class: "dropdown-header" }, ju = /* @__PURE__ */ G({
  __name: "BDropdownHeader",
  setup(t) {
    return (o, e) => (b(), O("li", null, [
      ae("h6", Du, [
        V(o.$slots, "default")
      ])
    ]));
  }
}), Gu = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    wrapperAttrs: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BDropdownItem"), a = o, { class: n, ...r } = Lt(), { computedLink: u, computedLinkProps: i } = Ct(l), d = h(() => [
      l.linkClass,
      {
        active: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), c = T(() => u.value ? it : l.href ? "a" : "button"), f = Ve(fl, null), p = Ve(tn, null), v = Ve(vl, null), m = (B) => {
      var w, _, k;
      a("click", B), v !== null && ((w = v == null ? void 0 : v.autoClose) == null ? void 0 : w.value) === !0 && ((_ = f == null ? void 0 : f.hide) == null || _.call(f)), (k = p == null ? void 0 : p.hide) == null || k.call(p);
    };
    return (B, w) => (b(), O("li", J({
      role: "presentation",
      class: s(n)
    }, s(l).wrapperAttrs), [
      (b(), L(fe(c.value), J({
        class: ["dropdown-item", d.value],
        disabled: s(l).disabled,
        "aria-disabled": s(l).disabled ? !0 : null,
        "aria-current": s(l).active ? !0 : null,
        href: c.value === "a" ? s(l).href : null,
        rel: s(l).rel,
        role: "menuitem",
        type: c.value === "button" ? "button" : null,
        target: s(l).target
      }, { ...s(i), ...r }, { onClick: m }), {
        default: R(() => [
          V(B.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ], 16));
  }
}), qu = { role: "presentation" }, Wu = ["disabled"], Uu = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    active: { type: Boolean, default: !1 },
    activeClass: { default: "active" },
    buttonClass: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BDropdownItemButton"), a = o, n = h(() => [
      l.buttonClass,
      {
        [l.activeClass]: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), r = (u) => {
      a("click", u);
    };
    return (u, i) => (b(), O("li", qu, [
      ae("button", {
        role: "menu",
        type: "button",
        class: W(["dropdown-item", n.value]),
        disabled: s(l).disabled,
        onClick: r
      }, [
        V(u.$slots, "default")
      ], 10, Wu)
    ]));
  }
}), Ku = { role: "presentation" }, Xu = /* @__PURE__ */ G({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(t) {
    const e = U(t, "BDropdownText");
    return (l, a) => (b(), O("li", Ku, [
      ae("span", J({ class: "dropdown-item-text" }, l.$attrs), [
        V(l.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ], 16)
    ]));
  }
}), Yu = ["id", "novalidate"], as = /* @__PURE__ */ G({
  __name: "BForm",
  props: {
    floating: { type: Boolean, default: !1 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: !1 },
    validated: { type: Boolean, default: !1 }
  },
  setup(t, { expose: o }) {
    const l = U(t, "BForm"), a = H(null), n = h(() => ({
      "form-floating": l.floating,
      "was-validated": l.validated
    }));
    return o({
      element: a
    }), (r, u) => (b(), O("form", {
      id: s(l).id,
      ref_key: "element",
      ref: a,
      novalidate: s(l).novalidate,
      class: W(n.value)
    }, [
      V(r.$slots, "default")
    ], 10, Yu));
  }
}), Zu = ["value", "disabled"], Va = /* @__PURE__ */ G({
  __name: "BFormSelectOption",
  props: {
    disabled: { type: Boolean, default: !1 },
    value: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BFormSelectOption");
    return (l, a) => (b(), O("option", {
      value: s(e).value,
      disabled: s(e).disabled
    }, [
      V(l.$slots, "default")
    ], 8, Zu));
  }
}), Ju = ["id"], Qu = ["innerHTML"], ed = /* @__PURE__ */ G({
  __name: "BFormDatalist",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    id: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(t) {
    const e = U(t, "BFormDatalist"), l = Ce(() => e.id, "datalist"), { normalizedOptions: a, isComplex: n } = ml(
      () => e.options,
      h(() => ({ ...e, optionsField: "options", labelField: "label" }))
    ), r = h(
      () => (
        // Datalist doesn't support complex options
        a.value.filter((u) => !n(u))
      )
    );
    return (u, i) => (b(), O("datalist", { id: s(l) }, [
      V(u.$slots, "first"),
      (b(!0), O(pe, null, ke(r.value, (d, c) => (b(), L(Va, {
        key: c,
        value: d.value,
        disabled: d.disabled
      }, {
        default: R(() => [
          d.html ? (b(), O("span", {
            key: 0,
            innerHTML: d.html
          }, null, 8, Qu)) : (b(), O(pe, { key: 1 }, [
            ce(oe(d.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["value", "disabled"]))), 128)),
      V(u.$slots, "default")
    ], 8, Ju));
  }
}), td = { class: "form-floating" }, ad = ["for"], ld = /* @__PURE__ */ G({
  __name: "BFormFloatingLabel",
  props: {
    label: { default: void 0 },
    labelFor: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BFormFloatingLabel");
    return (l, a) => (b(), O("div", td, [
      V(l.$slots, "default"),
      ae("label", {
        for: s(e).labelFor
      }, [
        V(l.$slots, "label", {}, () => [
          ce(oe(s(e).label), 1)
        ])
      ], 8, ad)
    ]));
  }
}), Ua = /* @__PURE__ */ G({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = U(t, "BFormInvalidFeedback"), l = T(() => e.forceShow === !0 || e.state === !1), a = h(() => ({
      "d-block": l.value,
      "invalid-feedback": !e.tooltip,
      "invalid-tooltip": e.tooltip
    }));
    return (n, r) => (b(), L(fe(s(e).tag), {
      id: s(e).id,
      role: s(e).role,
      "aria-live": s(e).ariaLive,
      "aria-atomic": s(e).ariaLive ? !0 : void 0,
      class: W(a.value)
    }, {
      default: R(() => [
        V(n.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), ia = /* @__PURE__ */ G({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(t) {
    const e = U(t, "BFormRow");
    return (l, a) => (b(), L(fe(s(e).tag), { class: "row d-flex flex-wrap" }, {
      default: R(() => [
        V(l.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Ka = /* @__PURE__ */ G({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(t) {
    const e = U(t, "BFormText"), l = h(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null,
      "form-text": !e.inline
    }));
    return (a, n) => (b(), L(fe(s(e).tag), {
      id: s(e).id,
      class: W(l.value)
    }, {
      default: R(() => [
        V(a.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Xa = /* @__PURE__ */ G({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = U(t, "BFormInvalidFeedback"), l = T(() => e.forceShow === !0 || e.state === !0), a = h(() => ({
      "d-block": l.value,
      "valid-feedback": !e.tooltip,
      "valid-tooltip": e.tooltip
    }));
    return (n, r) => (b(), L(fe(s(e).tag), {
      id: s(e).id,
      role: s(e).role,
      "aria-live": s(e).ariaLive,
      "aria-atomic": s(e).ariaLive ? !0 : void 0,
      class: W(a.value)
    }, {
      default: R(() => [
        V(n.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), od = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "true-value", "false-value", "indeterminate"], nd = ["for"], ls = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: /* @__PURE__ */ be({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    indeterminate: { type: Boolean },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: void 0 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    switch: { type: Boolean, default: !1 },
    uncheckedValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: !1 },
    wrapperAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    value: { type: [String, Boolean, Array, Set, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: void 0 },
    modelModifiers: {},
    indeterminate: { type: Boolean, default: !1 },
    indeterminateModifiers: {}
  }),
  emits: ["update:modelValue", "update:indeterminate"],
  setup(t, { expose: o }) {
    const { class: e, ...l } = Lt(), n = U(t, "BFormCheckbox"), r = De(), u = we(t, "modelValue"), i = we(t, "indeterminate"), d = Ce(() => n.id, "form-check"), c = Ve(Qo, null), f = H(null), { focused: p } = Re(f, {
      initialValue: n.autofocus
    }), v = T(() => !Pe(r.default)), m = h({
      get: () => c ? c.modelValue.value : u.value,
      set: (S) => {
        if (S !== void 0) {
          if (i.value = !1, c !== null && Array.isArray(S)) {
            c.modelValue.value = S;
            return;
          }
          u.value = S;
        }
      }
    }), B = T(
      () => !!(n.name ?? (c == null ? void 0 : c.name.value)) && (n.required || (c == null ? void 0 : c.required.value))
    ), w = T(() => n.buttonGroup || ((c == null ? void 0 : c.buttons.value) ?? !1)), _ = h(() => ({
      plain: n.plain || ((c == null ? void 0 : c.plain.value) ?? !1),
      button: n.button || ((c == null ? void 0 : c.buttons.value) ?? !1),
      inline: n.inline || ((c == null ? void 0 : c.inline.value) ?? !1),
      reverse: n.reverse || ((c == null ? void 0 : c.reverse.value) ?? !1),
      switch: n.switch || ((c == null ? void 0 : c.switch.value) ?? !1),
      state: n.state === !0 || n.state === !1 ? n.state : (c == null ? void 0 : c.state.value) ?? null,
      size: n.size ?? (c == null ? void 0 : c.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: n.buttonVariant ?? (c == null ? void 0 : c.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: v.value
    })), k = mn(_), g = h(() => [k.value, e]), $ = bn(_), y = h(() => [$.value, n.inputClass]), A = yn(_);
    return o({
      blur: () => {
        p.value = !1;
      },
      element: f,
      focus: () => {
        p.value = !0;
      }
    }), (S, Y) => (b(), L(Yt, J({ skip: w.value }, s(n).wrapperAttrs, { class: g.value }), {
      default: R(() => {
        var K, P, j;
        return [
          dt(ae("input", J({
            id: s(d),
            ref_key: "input",
            ref: f,
            "onUpdate:modelValue": Y[0] || (Y[0] = (F) => m.value = F),
            class: y.value,
            type: "checkbox",
            disabled: s(n).disabled || ((K = s(c)) == null ? void 0 : K.disabled.value),
            required: B.value || void 0,
            name: s(n).name || ((P = s(c)) == null ? void 0 : P.name.value),
            form: s(n).form || ((j = s(c)) == null ? void 0 : j.form.value),
            "aria-label": s(n).ariaLabel,
            "aria-labelledby": s(n).ariaLabelledby,
            "aria-required": B.value || void 0,
            value: s(n).value,
            "true-value": s(n).value,
            "false-value": s(n).uncheckedValue,
            indeterminate: s(n).indeterminate
          }, l), null, 16, od), [
            [Bs, m.value]
          ]),
          v.value || s(n).plain === !1 ? (b(), O("label", {
            key: 0,
            for: s(d),
            class: W(s(A))
          }, [
            V(S.$slots, "default")
          ], 10, nd)) : ne("", !0)
        ];
      }),
      _: 3
    }, 16, ["skip", "class"]));
  }
}), sd = ["id"], rd = ["innerHTML"], id = /* @__PURE__ */ G({
  __name: "BFormCheckboxGroup",
  props: /* @__PURE__ */ be({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: {},
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    switches: { type: Boolean, default: !1 },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const l = U(t, "BFormCheckboxGroup"), a = we(t, "modelValue"), n = Ce(() => l.id, "checkbox"), r = Ce(() => l.name, "checkbox"), u = H(null), { focused: i } = Re(u, {
      initialValue: l.autofocus
    });
    We(Qo, {
      modelValue: a,
      switch: T(() => l.switches),
      buttonVariant: T(() => l.buttonVariant),
      form: T(() => l.form),
      name: r,
      state: T(() => l.state),
      plain: T(() => l.plain),
      size: T(() => l.size),
      inline: T(() => !l.stacked),
      reverse: T(() => l.reverse),
      required: T(() => l.required),
      buttons: T(() => l.buttons),
      disabled: T(() => l.disabled)
    });
    const d = h(
      () => l.options.map(
        (v, m) => typeof v == "string" || typeof v == "number" ? {
          props: {
            value: v,
            disabled: l.disabled
          },
          text: v.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${m}`)
        } : {
          props: {
            value: v[l.valueField],
            disabled: v[l.disabledField],
            ...v.props ? v.props : {}
          },
          text: v[l.textField],
          html: v[l.htmlField],
          self: Symbol(`checkboxGroupOptionItem${m}`)
        }
      )
    ), c = h(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), f = gn(c), p = hn(c);
    return o({
      blur: () => {
        i.value = !1;
      },
      focus: () => {
        i.value = !0;
      }
    }), (v, m) => (b(), O("div", J(s(f), {
      id: s(n),
      ref_key: "element",
      ref: u,
      role: "group",
      class: [s(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      V(v.$slots, "first"),
      (b(!0), O(pe, null, ke(d.value, (B) => (b(), L(ls, J({
        key: B.self,
        ref_for: !0
      }, B.props), {
        default: R(() => [
          B.html ? (b(), O("span", {
            key: 0,
            innerHTML: B.html
          }, null, 8, rd)) : (b(), O(pe, { key: 1 }, [
            ce(oe(B.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040))), 128)),
      V(v.$slots, "default")
    ], 16, sd));
  }
}), ud = ["for"], dd = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-label", "aria-labelledby", "aria-required", "directory", "webkitdirectory"], cd = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: /* @__PURE__ */ be({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    accept: { default: "" },
    autofocus: { type: Boolean, default: !1 },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    label: { default: "" },
    labelClass: { default: void 0 },
    modelValue: {},
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    noButton: { type: Boolean, default: !1 },
    noDrop: { type: Boolean, default: !1 },
    noTraverse: { type: Boolean, default: !1 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const e = De(), a = U(t, "BFormFile"), n = we(t, "modelValue"), r = Ce(() => a.id), u = kt(() => a.state), i = H(null), { focused: d } = Re(i, { initialValue: a.autofocus }), c = T(() => !Pe(e.label)), f = h(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), p = h(() => [
      u.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0,
        "form-control": !a.plain,
        "form-control-input-file-hide-button": a.noButton
      }
    ]), v = () => {
      var _, k;
      const w = ((_ = i.value) == null ? void 0 : _.files) === null || ((k = i.value) == null ? void 0 : k.files) === void 0 ? null : [...i.value.files];
      n.value = w === null ? null : a.multiple === !0 ? w : w[0];
    }, m = (w) => {
      a.noDrop === !0 && w.preventDefault();
    }, B = () => {
      n.value = null;
    };
    return de(n, (w) => {
      w === null && i.value !== null && (i.value.value = "");
    }), o({
      blur: () => {
        d.value = !1;
      },
      element: i,
      focus: () => {
        d.value = !0;
      },
      reset: B
    }), (w, _) => (b(), O(pe, null, [
      c.value || s(a).label ? (b(), O("label", {
        key: 0,
        class: W(["form-label", s(a).labelClass]),
        for: s(r)
      }, [
        V(w.$slots, "label", {}, () => [
          ce(oe(s(a).label), 1)
        ])
      ], 10, ud)) : ne("", !0),
      ae("input", J({ id: s(r) }, w.$attrs, {
        ref_key: "input",
        ref: i,
        type: "file",
        class: p.value,
        form: s(a).form,
        name: s(a).name,
        multiple: s(a).multiple,
        disabled: s(a).disabled,
        capture: s(a).capture,
        accept: f.value || void 0,
        required: s(a).required || void 0,
        "aria-label": s(a).ariaLabel,
        "aria-labelledby": s(a).ariaLabelledby,
        "aria-required": s(a).required || void 0,
        directory: s(a).directory,
        webkitdirectory: s(a).directory,
        onChange: v,
        onDrop: m
      }), null, 16, dd)
    ], 64));
  }
}), os = ["input", "select", "textarea"], fd = os.map((t) => `${t}:not([disabled])`).join(), vd = [...os, "a", "button", "label"], pd = "label", md = "invalid-feedback", bd = "valid-feedback", yd = "description", gd = "default", hd = G({
  components: { BCol: Dt, BFormInvalidFeedback: Ua, BFormRow: ia, BFormText: Ka, BFormValidFeedback: Xa },
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: Boolean, default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    floating: { type: Boolean, default: !1 },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [String], default: void 0 },
    labelAlignLg: { type: [String], default: void 0 },
    labelAlignMd: { type: [String], default: void 0 },
    labelAlignSm: { type: [String], default: void 0 },
    labelAlignXl: { type: [String], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelVisuallyHidden: { type: Boolean, default: !1 },
    state: { type: Boolean, default: null },
    tooltip: { type: Boolean, default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = ["xs", "sm", "md", "lg", "xl"], l = (m, B) => e.reduce((w, _) => {
      const k = zl(_ === "xs" ? "" : _, `${B}Align`), g = m[k] || null;
      return g && (_ === "xs" ? w.push(`text-${g}`) : w.push(`text-${_}-${g}`)), w;
    }, []), a = (m, B) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      e.reduce((w, _) => {
        const k = zl(_ === "xs" ? "" : _, `${B}Cols`);
        let g = m[k];
        if (g = g === "" ? !0 : g || !1, typeof g != "boolean" && g !== "auto") {
          const $ = Number.parseInt(g);
          g = Number.isNaN($) ? 0 : $, g = g > 0 ? g : !1;
        }
        return g && (_ === "xs" ? w[typeof g == "boolean" ? "col" : "cols"] = g : w[_ || (typeof g == "boolean" ? "col" : "cols")] = g), w;
      }, {})
    ), n = H(null), r = (m, B = null) => {
      if (al && t.labelFor && n.value !== null) {
        const w = n.value.querySelector(`#${CSS.escape(t.labelFor)}`);
        if (w) {
          const _ = "aria-describedby", k = (m || "").split(oa), g = (B || "").split(oa), $ = (w.getAttribute(_) || "").split(oa).filter((y) => !g.includes(y)).concat(k).filter((y, A, S) => S.indexOf(y) === A).filter((y) => y).join(" ").trim();
          $ ? w.setAttribute(_, $) : w.removeAttribute(_);
        }
      }
    }, u = h(() => a(t, "content")), i = h(() => l(t, "label")), d = h(() => a(t, "label")), c = h(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(u.value).length > 0 || Object.keys(d.value).length > 0
      )
    ), f = kt(() => t.state), p = ka(
      () => t.ariaInvalid,
      () => t.state
    );
    return de(
      () => null,
      (m, B) => {
        m !== B && r(m, B);
      }
    ), He(() => {
      Ne(() => {
        r(null);
      });
    }), {
      ariaDescribedby: null,
      computedAriaInvalid: p,
      contentColProps: u,
      isHorizontal: c,
      labelAlignClasses: i,
      labelColProps: d,
      onLegendClick: (m) => {
        if (t.labelFor || n.value === null)
          return;
        const { target: B } = m, w = B ? B.tagName : "";
        if (vd.indexOf(w) !== -1)
          return;
        const _ = [...n.value.querySelectorAll(fd)].filter(Ts), [k] = _;
        _.length === 1 && k instanceof HTMLElement && ks(k);
      },
      stateClass: f
    };
  },
  render() {
    const t = this.$props, o = this.$slots, e = Ce(), l = !t.labelFor;
    let a = null;
    const n = Mt(pd, {}, o) || t.label, r = n ? Ce(void 0, "_BV_label_").value : null;
    if (n || this.isHorizontal) {
      const $ = l ? "legend" : "label";
      if (t.labelVisuallyHidden)
        n && (a = Ie(
          $,
          {
            class: "visually-hidden",
            id: r,
            for: t.labelFor || null
          },
          n
        )), this.isHorizontal ? a = Ie(Dt, this.labelColProps, { default: () => a }) : a = Ie("div", {}, [a]);
      else {
        const y = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? $ : null,
          id: r,
          for: t.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${t.labelSize}`]: !!t.labelSize
            },
            this.labelAlignClasses,
            t.labelClass
          ]
        };
        this.isHorizontal ? a = Ie(Dt, y, { default: () => n }) : a = Ie($, y, n);
      }
    }
    let u = null;
    const i = Mt(md, {}, o) || this.invalidFeedback, d = i ? Ce(void 0, "_BV_feedback_invalid_").value : void 0;
    i && (u = Ie(
      Ua,
      {
        ariaLive: t.feedbackAriaLive,
        id: d,
        state: t.state,
        tooltip: t.tooltip
      },
      { default: () => i }
    ));
    let c = null;
    const f = Mt(bd, {}, o) || this.validFeedback, p = f ? Ce(void 0, "_BV_feedback_valid_").value : void 0;
    f && (c = Ie(
      Xa,
      {
        ariaLive: t.feedbackAriaLive,
        id: p,
        state: t.state,
        tooltip: t.tooltip
      },
      { default: () => f }
      // validFeedbackContent
    ));
    let v = null;
    const m = Mt(yd, {}, o) || this.description, B = m ? Ce(void 0, "_BV_description_").value : void 0;
    m && (v = Ie(
      Ka,
      {
        id: B
      },
      { default: () => m }
    ));
    const w = this.ariaDescribedby = [
      B,
      t.state === !1 ? d : null,
      t.state === !0 ? p : null
    ].filter(($) => $).join(" ") || null, _ = [
      Mt(gd, { ariaDescribedby: w, descriptionId: B, id: e, labelId: r }, o) || "",
      u,
      c,
      v
    ];
    !this.isHorizontal && t.floating && _.push(a);
    let k = Ie(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && t.floating
          }
        ]
      },
      _
    );
    this.isHorizontal && (k = Ie(Dt, { ref: "content", ...this.contentColProps }, { default: () => _ }));
    const g = {
      class: [
        this.stateClass,
        {
          "was-validated": t.validated
        }
      ],
      id: Ce(() => t.id).value,
      disabled: l ? t.disabled : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": l && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !l ? Ie(ia, g, { default: () => [a, k] }) : Ie(
      l ? "fieldset" : "div",
      g,
      this.isHorizontal && l ? [Ie(ia, null, { default: () => [a, k] })] : this.isHorizontal || !t.floating ? [a, k] : [k]
    );
  }
}), Bd = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Zl = /* @__PURE__ */ G({
  __name: "BFormInput",
  props: /* @__PURE__ */ be({
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    modelValue: {
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const l = U(t, "BFormInput"), [a, n] = we(t, "modelValue", {
      set: (_) => dn(_, n)
    }), { input: r, computedId: u, computedAriaInvalid: i, onInput: d, onChange: c, onBlur: f, focus: p, blur: v } = Bn(l, a, n), m = kt(() => l.state), B = H(!1), w = h(() => {
      const _ = l.type === "range", k = l.type === "color";
      return [
        m.value,
        {
          "form-control-highlighted": B.value,
          "form-range": _,
          "form-control": k || !l.plaintext && !_,
          "form-control-color": k,
          "form-control-plaintext": l.plaintext && !_ && !k,
          [`form-control-${l.size}`]: !!l.size
        }
      ];
    });
    return o({
      blur: v,
      element: r,
      focus: p
    }), (_, k) => (b(), O("input", {
      id: s(u),
      ref_key: "input",
      ref: r,
      value: s(a),
      class: W(w.value),
      name: s(l).name || void 0,
      form: s(l).form || void 0,
      type: s(l).type,
      disabled: s(l).disabled,
      placeholder: s(l).placeholder,
      required: s(l).required || void 0,
      autocomplete: s(l).autocomplete || void 0,
      readonly: s(l).readonly || s(l).plaintext,
      min: s(l).min,
      max: s(l).max,
      step: s(l).step,
      list: s(l).type !== "password" ? s(l).list : void 0,
      "aria-required": s(l).required || void 0,
      "aria-invalid": s(i),
      onInput: k[0] || (k[0] = (g) => s(d)(g)),
      onChange: k[1] || (k[1] = (g) => s(c)(g)),
      onBlur: k[2] || (k[2] = (g) => s(f)(g))
    }, null, 42, Bd));
  }
}), _d = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], wd = ["for"], ns = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: /* @__PURE__ */ be({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    value: { type: [Boolean, String, Array, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const l = U(t, "BFormRadio"), a = De(), n = we(t, "modelValue"), r = Ce(() => l.id, "form-check"), u = Ve(en, null), i = H(null), { focused: d } = Re(i, {
      initialValue: l.autofocus
    }), c = T(() => !Pe(a.default)), f = h({
      get: () => u ? u.modelValue.value : n.value,
      set: (k) => {
        if (k !== void 0) {
          if (u !== null) {
            u.modelValue.value = k;
            return;
          }
          n.value = k;
        }
      }
    }), p = T(
      () => !!(l.name ?? (u == null ? void 0 : u.name.value)) && (l.required || (u == null ? void 0 : u.required.value))
    ), v = T(() => l.buttonGroup || ((u == null ? void 0 : u.buttons.value) ?? !1)), m = h(() => ({
      plain: l.plain || ((u == null ? void 0 : u.plain.value) ?? !1),
      button: l.button || ((u == null ? void 0 : u.buttons.value) ?? !1),
      inline: l.inline || ((u == null ? void 0 : u.inline.value) ?? !1),
      state: l.state || (u == null ? void 0 : u.state.value),
      reverse: l.reverse || ((u == null ? void 0 : u.reverse.value) ?? !1),
      size: l.size ?? (u == null ? void 0 : u.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (u == null ? void 0 : u.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: c.value
    })), B = mn(m), w = bn(m), _ = yn(m);
    return o({
      blur: () => {
        d.value = !1;
      },
      element: i,
      focus: () => {
        d.value = !0;
      }
    }), (k, g) => (b(), L(Yt, {
      skip: v.value,
      class: W(s(B))
    }, {
      default: R(() => {
        var $, y, A;
        return [
          dt(ae("input", J({ id: s(r) }, k.$attrs, {
            ref_key: "input",
            ref: i,
            "onUpdate:modelValue": g[0] || (g[0] = (S) => f.value = S),
            class: s(w),
            type: "radio",
            disabled: s(l).disabled || (($ = s(u)) == null ? void 0 : $.disabled.value),
            required: p.value || void 0,
            name: s(l).name || ((y = s(u)) == null ? void 0 : y.name.value),
            form: s(l).form || ((A = s(u)) == null ? void 0 : A.form.value),
            "aria-label": s(l).ariaLabel,
            "aria-labelledby": s(l).ariaLabelledby,
            value: s(l).value,
            "aria-required": p.value || void 0
          }), null, 16, _d), [
            [_s, f.value]
          ]),
          c.value || s(l).plain === !1 ? (b(), O("label", {
            key: 0,
            for: s(r),
            class: W(s(_))
          }, [
            V(k.$slots, "default")
          ], 10, wd)) : ne("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Cd = ["id"], kd = ["innerHTML"], Td = /* @__PURE__ */ G({
  __name: "BFormRadioGroup",
  props: /* @__PURE__ */ be({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: null },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const l = U(t, "BFormRadioGroup"), a = we(t, "modelValue"), n = Ce(() => l.id, "radio"), r = Ce(() => l.name, "checkbox"), u = H(null), { focused: i } = Re(u, {
      initialValue: l.autofocus
    });
    We(en, {
      modelValue: a,
      buttonVariant: T(() => l.buttonVariant),
      form: T(() => l.form),
      name: r,
      buttons: T(() => l.buttons),
      state: T(() => l.state),
      plain: T(() => l.plain),
      size: T(() => l.size),
      inline: T(() => !l.stacked),
      reverse: T(() => l.reverse),
      required: T(() => l.required),
      disabled: T(() => l.disabled)
    });
    const d = h(
      () => l.options.map(
        (v, m) => typeof v == "string" || typeof v == "number" ? {
          value: v,
          disabled: l.disabled,
          text: v.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${m}`)
        } : {
          value: v[l.valueField],
          disabled: v[l.disabledField],
          ...v.props ? v.props : {},
          text: v[l.textField],
          html: v[l.htmlField],
          self: Symbol(`radioGroupOptionItem${m}`)
        }
      )
    ), c = h(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), f = gn(c), p = hn(c);
    return o({
      blur: () => {
        i.value = !1;
      },
      focus: () => {
        i.value = !0;
      }
    }), (v, m) => (b(), O("div", J(s(f), {
      id: s(n),
      ref_key: "element",
      ref: u,
      role: "radiogroup",
      class: [s(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      V(v.$slots, "first"),
      (b(!0), O(pe, null, ke(d.value, (B) => (b(), L(ns, {
        key: B.self,
        disabled: B.disabled,
        value: B.value
      }, {
        default: R(() => [
          B.html ? (b(), O("span", {
            key: 0,
            innerHTML: B.html
          }, null, 8, kd)) : (b(), O(pe, { key: 1 }, [
            ce(oe(B.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["disabled", "value"]))), 128)),
      V(v.$slots, "default")
    ], 16, Cd));
  }
}), Sd = ["label"], xd = ["innerHTML"], ss = /* @__PURE__ */ G({
  __name: "BFormSelectOptionGroup",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    label: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(t) {
    const e = U(t, "BFormSelectOptionGroup"), { normalizedOptions: l } = ml(() => e.options, e), a = h(() => l.value);
    return (n, r) => (b(), O("optgroup", {
      label: s(e).label
    }, [
      V(n.$slots, "first"),
      (b(!0), O(pe, null, ke(a.value, (u, i) => (b(), L(Va, J({
        key: i,
        disabled: u.disabled,
        value: u.value,
        ref_for: !0
      }, n.$attrs), {
        default: R(() => [
          u.html ? (b(), O("span", {
            key: 0,
            innerHTML: u.html
          }, null, 8, xd)) : (b(), O(pe, { key: 1 }, [
            ce(oe(u.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040, ["disabled", "value"]))), 128)),
      V(n.$slots, "default")
    ], 8, Sd));
  }
}), $d = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Ad = ["innerHTML"], Vd = /* @__PURE__ */ G({
  __name: "BFormSelect",
  props: /* @__PURE__ */ be({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" }
  }, {
    modelValue: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const l = U(t, "BFormSelect"), a = we(t, "modelValue"), n = Ce(() => l.id, "input"), r = Be(() => l.selectSize), u = kt(() => l.state), i = H(null), { focused: d } = Re(i, {
      initialValue: l.autofocus
    }), c = h(() => [
      u.value,
      {
        "form-control": l.plain,
        [`form-control-${l.size}`]: l.size !== "md" && l.plain,
        "form-select": !l.plain,
        [`form-select-${l.size}`]: l.size !== "md" && !l.plain
      }
    ]), f = T(
      () => r.value || l.plain ? r.value : void 0
    ), p = ka(
      () => l.ariaInvalid,
      () => l.state
    ), { normalizedOptions: v, isComplex: m } = ml(() => l.options, l), B = h(
      () => v.value
    ), w = h({
      get: () => a.value,
      set: (_) => {
        a.value = _;
      }
    });
    return o({
      blur: () => {
        d.value = !1;
      },
      element: i,
      focus: () => {
        d.value = !0;
      }
    }), (_, k) => dt((b(), O("select", {
      id: s(n),
      ref_key: "input",
      ref: i,
      "onUpdate:modelValue": k[0] || (k[0] = (g) => w.value = g),
      class: W(c.value),
      name: s(l).name,
      form: s(l).form || void 0,
      multiple: s(l).multiple || void 0,
      size: f.value,
      disabled: s(l).disabled,
      required: s(l).required || void 0,
      "aria-required": s(l).required || void 0,
      "aria-invalid": s(p)
    }, [
      V(_.$slots, "first"),
      (b(!0), O(pe, null, ke(B.value, (g, $) => (b(), O(pe, { key: $ }, [
        s(m)(g) ? (b(), L(ss, {
          key: 0,
          label: g.label,
          options: g.options,
          "value-field": s(l).valueField,
          "text-field": s(l).textField,
          "html-field": s(l).htmlField,
          "disabled-field": s(l).disabledField
        }, null, 8, ["label", "options", "value-field", "text-field", "html-field", "disabled-field"])) : (b(), L(Va, {
          key: 1,
          value: g.value,
          disabled: g.disabled
        }, {
          default: R(() => [
            g.html ? (b(), O("span", {
              key: 0,
              innerHTML: g.html
            }, null, 8, Ad)) : (b(), O(pe, { key: 1 }, [
              ce(oe(g.text), 1)
            ], 64))
          ]),
          _: 2
        }, 1032, ["value", "disabled"]))
      ], 64))), 128)),
      V(_.$slots, "default")
    ], 10, $d)), [
      [ws, w.value]
    ]);
  }
}), Ia = "ArrowDown", Jl = "End", Ql = "Home", eo = "PageDown", to = "PageUp", Ea = "ArrowUp", Fd = ["lang", "tabindex", "title"], Nd = ["name", "form", "value"], Od = ["id", "dir", "tabindex", "aria-label", "aria-invalid", "aria-required", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext"], Ge = {
  min: 1,
  max: 100,
  step: 1,
  repeatDelay: 500,
  repeatInterval: 100,
  repeatThreshold: 10,
  repeatMultiplier: 4
}, Pd = /* @__PURE__ */ G({
  __name: "BFormSpinbutton",
  props: /* @__PURE__ */ be({
    ariaControls: { default: void 0 },
    ariaLabel: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatterFn: { type: Function, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    labelDecrement: { default: "Decrement" },
    labelIncrement: { default: "Increment" },
    locale: { default: void 0 },
    max: { default: Ge.max },
    min: { default: Ge.min },
    modelValue: {},
    name: { default: void 0 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: !1 },
    repeatDelay: { default: Ge.repeatDelay },
    repeatInterval: { default: Ge.repeatInterval },
    repeatStepMultiplier: { default: Ge.repeatMultiplier },
    repeatThreshold: { default: Ge.repeatThreshold },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    step: { default: Ge.step },
    vertical: { type: Boolean, default: !1 },
    wrap: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["change"], ["update:modelValue"]),
  setup(t, { emit: o }) {
    const e = [Ea, Ia, Ql, Jl, to, eo], a = U(t, "BFormSpinbutton"), n = o, r = we(t, "modelValue"), u = H(null), { focused: i } = Re(u), d = Ce(() => a.id, "spinbutton"), c = h(() => ({
      disabled: a.disabled,
      readonly: a.readonly,
      focus: i.value,
      "d-inline-flex": a.inline || a.vertical,
      "d-flex": !a.inline && !a.vertical,
      "align-items-stretch": !a.vertical,
      "flex-column": a.vertical,
      [`form-control-${a.size}`]: a.size !== void 0
    })), f = h(() => ({
      "d-flex": a.vertical,
      "align-self-center": !a.vertical,
      "align-items-center": a.vertical,
      "border-top": a.vertical,
      "border-bottom": a.vertical,
      "border-start": !a.vertical,
      "border-end": !a.vertical
    }));
    let p, v, m = !1;
    const B = Be(() => a.step), w = T(
      () => Number.isNaN(B.value) ? Ge.step : B.value
    ), _ = Be(() => a.min), k = T(
      () => Number.isNaN(_.value) ? Ge.min : _.value
    ), g = Be(() => a.max), $ = T(() => {
      const le = w.value, re = k.value;
      return Math.floor((g.value - re) / le) * le + re;
    }), y = Be(() => a.repeatDelay, {
      nanToZero: !0,
      method: "parseInt"
    }), A = T(
      () => y.value > 0 ? y.value : Ge.repeatDelay
    ), S = Be(() => a.repeatInterval, {
      nanToZero: !0,
      method: "parseInt"
    }), Y = T(
      () => S.value > 0 ? S.value : Ge.repeatInterval
    ), K = Be(() => a.repeatThreshold, {
      nanToZero: !0,
      method: "parseInt"
    }), P = T(
      () => Math.max(
        Number.isNaN(K.value) ? Ge.repeatThreshold : K.value,
        1
      )
    ), j = Be(() => a.repeatStepMultiplier, {
      nanToZero: !0,
      method: "parseInt"
    }), F = T(
      () => Math.max(
        Number.isNaN(j.value) ? Ge.repeatMultiplier : j.value,
        1
      )
    ), N = T(() => {
      const le = w.value;
      return Math.floor(le) === le ? 0 : (le.toString().split(".")[1] || "").length;
    }), z = T(() => Math.pow(10, N.value || 0)), C = T(
      () => r.value === null ? "" : r.value.toFixed(N.value)
    ), { isRtl: x, locale: E } = ci(), I = h(() => {
      const re = [(a.locale ?? (E == null ? void 0 : E.value)) || "locale"];
      return new Intl.NumberFormat(re).resolvedOptions().locale;
    }), X = () => new Intl.NumberFormat(I.value, {
      style: "decimal",
      useGrouping: !1,
      minimumIntegerDigits: 1,
      minimumFractionDigits: N.value,
      maximumFractionDigits: N.value,
      notation: "standard"
    }).format, D = T(() => a.formatterFn ?? X()), M = (le) => {
      let { value: re } = r;
      if (!a.disabled && re !== null) {
        const he = w.value * le, ee = k.value, ye = $.value, Te = z.value, { wrap: Ae } = a;
        re = Math.round((re - ee) / he) * he + ee + he, re = Math.round(re * Te) / Te, r.value = re > ye ? Ae ? ee : ye : re < ee ? Ae ? ye : ee : re;
      }
    }, Q = (le = 1) => {
      if (r.value === null) {
        r.value = k.value;
        return;
      }
      M(1 * le);
    }, Z = (le = 1) => {
      if (r.value === null) {
        r.value = a.wrap ? $.value : k.value;
        return;
      }
      M(-1 * le);
    }, q = (le) => {
      le.preventDefault(), le.stopImmediatePropagation();
    };
    qe(
      e,
      (le) => {
        const { code: re, altKey: he, ctrlKey: ee, metaKey: ye } = le;
        if (!(a.disabled || a.readonly || he || ee || ye) && (q(le), !m)) {
          if (ue(), [Ea, Ia].includes(re)) {
            if (m = !0, re === Ea) {
              se(le, Q);
              return;
            }
            re === Ia && se(le, Z);
            return;
          }
          if (re === to) {
            Q(F.value);
            return;
          }
          if (re === eo) {
            Z(F.value);
            return;
          }
          if (re === Ql) {
            r.value = k.value;
            return;
          }
          re === Jl && (r.value = $.value);
        }
      },
      { target: u, eventName: "keydown" }
    ), qe(
      e,
      (le) => {
        const { altKey: re, ctrlKey: he, metaKey: ee } = le;
        a.disabled || a.readonly || re || he || ee || (q(le), ue(), m = !1, n("change", r.value));
      },
      { target: u, eventName: "keyup" }
    );
    const se = (le, re) => {
      const { type: he } = le || {};
      if (!a.disabled && !a.readonly) {
        if (ie(le) && he === "mousedown" && le.button)
          return;
        ue(), re(1);
        const ee = P.value, ye = F.value, Te = A.value, Ae = Y.value;
        p = setTimeout(() => {
          let Ze = 0;
          v = setInterval(() => {
            re(Ze < ee ? 1 : ye), Ze++;
          }, Ae);
        }, Te);
      }
    }, ie = (le) => le.type === "mouseup" || le.type === "mousedown", te = (le) => {
      ie(le) && le.type === "mouseup" && le.button || (q(le), ue(), ve(!1), n("change", r.value));
    }, ve = (le) => {
      try {
        wl(le, [document.body, "mouseup", te, !1]), wl(le, [document.body, "touchend", te, !1]);
      } catch {
      }
    }, ue = () => {
      clearTimeout(p), clearInterval(v), p = void 0, v = void 0;
    }, me = h(() => {
      const le = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-plus",
          viewBox: "0 0 16 16"
        },
        path: {
          d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
        }
      }, re = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-dash",
          viewBox: "0 0 16 16"
        },
        path: { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" }
      }, he = {
        class: [{ "py-0": !a.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
        tabindex: "-1",
        type: "button",
        disabled: a.disabled || a.readonly,
        "aria-disabled": a.disabled || a.readonly ? !0 : void 0,
        "aria-controls": d.value
      }, ee = {
        "aria-hidden": !0,
        scale: i.value ? 1.5 : 1.25
      }, ye = (Ze, ps) => {
        !a.disabled && !a.readonly && (q(Ze), ve(!0), i.value = !0, se(Ze, ps));
      }, Te = {
        button: {
          ...he,
          "aria-label": a.labelIncrement || void 0,
          "aria-keyshortcuts": "ArrowUp"
        },
        svg: {
          ...ee,
          ...le.svg
        },
        path: {
          ...le.path
        },
        slot: {
          name: "increment"
        },
        handler: (Ze) => ye(Ze, Q)
      }, Ae = {
        button: {
          ...he,
          "aria-label": a.labelDecrement || void 0,
          "aria-keyshortcuts": "ArrowDown"
        },
        svg: {
          ...ee,
          ...re.svg
        },
        path: {
          ...re.path
        },
        slot: {
          name: "decrement"
        },
        handler: (Ze) => ye(Ze, Z)
      };
      return {
        top: {
          ...a.vertical ? Te : Ae
        },
        bottom: {
          ...a.vertical ? Ae : Te
        }
      };
    });
    return (le, re) => (b(), O("div", {
      ref_key: "element",
      ref: u,
      class: W(["b-form-spinbutton form-control", c.value]),
      role: "group",
      lang: I.value,
      tabindex: s(a).disabled ? void 0 : "-1",
      title: s(a).ariaLabel,
      onClick: re[4] || (re[4] = (he) => i.value = !0)
    }, [
      V(le.$slots, me.value.top.slot.name, { hasFocus: s(i) }, () => [
        ae("button", J(me.value.top.button, {
          onMousedown: re[0] || (re[0] = //@ts-ignore
          (...he) => me.value.top.handler && me.value.top.handler(...he)),
          onTouchstart: re[1] || (re[1] = //@ts-ignore
          (...he) => me.value.top.handler && me.value.top.handler(...he))
        }), [
          (b(), O("svg", _e(Se(me.value.top.svg)), [
            ae("path", _e(Se(me.value.top.path)), null, 16)
          ], 16))
        ], 16)
      ]),
      s(a).name && !s(a).disabled ? (b(), O("input", {
        key: "hidden",
        type: "hidden",
        name: s(a).name,
        form: s(a).form,
        value: C.value
      }, null, 8, Nd)) : ne("", !0),
      ae("output", {
        id: s(d),
        key: "output",
        class: W(["flex-grow-1", f.value]),
        dir: s(x) ?? !1 ? "rtl" : "ltr",
        tabindex: s(a).disabled ? void 0 : "0",
        role: "spinbutton",
        "aria-live": "off",
        "aria-label": s(a).ariaLabel || void 0,
        "aria-invalid": s(a).state === !1 || !r.value !== null && s(a).required ? !0 : void 0,
        "aria-required": s(a).required ? !0 : void 0,
        "aria-valuemin": k.value,
        "aria-valuemax": $.value,
        "aria-valuenow": r.value !== null ? r.value : void 0,
        "aria-valuetext": r.value !== null ? D.value(r.value) : void 0
      }, [
        ae("bdi", null, oe((r.value !== null ? D.value(r.value) : s(a).placeholder) || ""), 1)
      ], 10, Od),
      V(le.$slots, me.value.bottom.slot.name, { hasFocus: s(i) }, () => [
        ae("button", J(me.value.bottom.button, {
          onMousedown: re[2] || (re[2] = //@ts-ignore
          (...he) => me.value.bottom.handler && me.value.bottom.handler(...he)),
          onTouchstart: re[3] || (re[3] = //@ts-ignore
          (...he) => me.value.bottom.handler && me.value.bottom.handler(...he))
        }), [
          (b(), O("svg", _e(Se(me.value.bottom.svg)), [
            ae("path", _e(Se(me.value.bottom.path)), null, 16)
          ], 16))
        ], 16)
      ])
    ], 10, Fd));
  }
}), Id = ["id"], rs = /* @__PURE__ */ G({
  __name: "BFormTag",
  props: {
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noRemove: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    title: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(t, { emit: o }) {
    const l = U(t, "BFormTag"), a = o, n = De(), r = Ce(() => l.id), u = h(
      () => {
        var c;
        return ((((c = n.default) == null ? void 0 : c.call(n, {})[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), i = T(() => `${r.value}taglabel__`), d = h(() => ({
      [`text-bg-${l.variant}`]: l.variant !== null,
      "rounded-pill": l.pill,
      disabled: l.disabled
    }));
    return (c, f) => (b(), L(fe(s(l).tag), {
      id: s(r),
      title: u.value,
      class: W(["badge b-form-tag d-inline-flex align-items-center mw-100", d.value]),
      "aria-labelledby": i.value
    }, {
      default: R(() => [
        ae("span", {
          id: i.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          V(c.$slots, "default", {}, () => [
            ce(oe(u.value), 1)
          ])
        ], 8, Id),
        !s(l).disabled && !s(l).noRemove ? (b(), L(zt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": s(l).removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": i.value,
          "aria-controls": s(l).id,
          onClick: f[0] || (f[0] = (p) => a("remove", u.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : ne("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Ed = ["id"], Ld = ["id", "for", "aria-live"], Rd = ["id", "aria-live"], zd = ["id"], Md = ["aria-controls"], Hd = {
  role: "group",
  class: "d-flex"
}, Dd = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], jd = ["disabled"], Gd = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, qd = {
  key: 0,
  class: "d-block invalid-feedback"
}, Wd = {
  key: 1,
  class: "form-text text-body-secondary"
}, Ud = {
  key: 2,
  class: "form-text text-body-secondary"
}, Kd = ["name", "value"], Xd = /* @__PURE__ */ G({
  __name: "BFormTags",
  props: /* @__PURE__ */ be({
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: Boolean, default: !1 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    form: { default: void 0 },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: {},
    name: { default: void 0 },
    noAddOnEnter: { type: Boolean, default: !1 },
    noOuterFocus: { type: Boolean, default: !1 },
    noTagRemove: { type: Boolean, default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    separator: { default: void 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    tagClass: { default: void 0 },
    tagPills: { type: Boolean, default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["blur", "focus", "focusin", "focusout", "tag-state"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BFormTags"), n = e, r = we(t, "modelValue"), u = Ce(), i = Be(() => a.limit ?? NaN), d = kt(() => a.state), c = H(null), { focused: f } = Re(c, {
      initialValue: a.autofocus
    }), p = T(() => a.inputId || `${u.value}input__`), v = H([...r.value]), m = H(""), B = H(r.value.length > 0), w = H(""), _ = H([]), k = H([]), g = H([]);
    ja(r, v, {
      direction: "ltr",
      transform: {
        ltr: (D) => [...D]
      }
    });
    const $ = h(() => [
      d.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: a.disabled,
        focus: f.value
      }
    ]), y = h(() => v.value.includes(m.value)), A = h(
      () => m.value === "" ? !1 : !a.tagValidator(m.value)
    ), S = T(() => v.value.length === i.value), Y = T(() => !A.value && !y.value), K = h(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: I,
      disableAddButton: Y.value,
      disabled: a.disabled,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: g.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: a.disabled,
        form: a.form,
        id: p.value,
        value: m.value
      },
      inputClass: a.inputClass,
      inputHandlers: {
        input: N,
        keydown: C,
        change: z
      },
      inputId: p.value,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: k.value,
      isDuplicate: y.value,
      isInvalid: A.value,
      isLimitReached: S.value,
      limitTagsText: a.limitTagsText,
      limit: i.value,
      noTagRemove: a.noTagRemove,
      placeholder: a.placeholder,
      removeTag: X,
      required: a.required,
      separator: a.separator,
      size: a.size,
      state: a.state,
      tagClass: a.tagClass,
      tagPills: a.tagPills,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: v.value
    })), P = (D) => {
      if (a.disabled) {
        D.target.blur();
        return;
      }
      n("focusin", D);
    }, j = (D) => {
      a.disabled || a.noOuterFocus || (f.value = !0, n("focus", D));
    }, F = (D) => {
      f.value = !1, n("blur", D);
    }, N = (D) => {
      var Q, Z;
      const M = typeof D == "string" ? D : D.target.value;
      if (B.value = !1, (Q = a.separator) != null && Q.includes(M.charAt(0)) && M.length > 0) {
        c.value && (c.value.value = "");
        return;
      }
      if (m.value = M, (Z = a.separator) != null && Z.includes(M.charAt(M.length - 1))) {
        I(M.slice(0, M.length - 1));
        return;
      }
      _.value = a.tagValidator(M) && !y.value ? [M] : [], k.value = a.tagValidator(M) ? [] : [M], g.value = y.value ? [M] : [], n("tag-state", _.value, k.value, g.value);
    }, z = (D) => {
      a.addOnChange && (N(D), y.value || I(m.value));
    }, C = (D) => {
      if (D.key === "Enter" && !a.noAddOnEnter) {
        I(m.value);
        return;
      }
      (D.key === "Backspace" || D.key === "Delete") && a.removeOnDelete && m.value === "" && B.value && v.value.length > 0 ? X(v.value[v.value.length - 1]) : B.value = !0;
    };
    qe(C, { target: c });
    const x = h(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), E = h(() => {
      if (x.value)
        return new RegExp(`[${Jr(x.value)}]+`);
    }), I = (D) => {
      D = (D ?? m.value).trim();
      const M = E.value ? D.split(E.value).map((q) => q.trim()) : [D], Q = [];
      for (const q of M)
        if (!(q === "" || y.value || !a.tagValidator(q))) {
          if (i.value && S.value)
            break;
          Q.push(q);
        }
      const Z = [...r.value, ...Q];
      m.value = "", B.value = !0, r.value = Z, f.value = !0;
    }, X = (D) => {
      const M = v.value.indexOf((D == null ? void 0 : D.toString()) ?? "");
      M !== -1 && (w.value = v.value.splice(M, 1).toString(), r.value = v.value);
    };
    return o({
      blur: () => {
        f.value = !1;
      },
      element: c,
      focus: () => {
        f.value = !0;
      }
    }), (D, M) => (b(), O("div", {
      id: s(u),
      class: W(["b-form-tags form-control h-auto", $.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: P,
      onFocusout: M[1] || (M[1] = (Q) => n("focusout", Q))
    }, [
      ae("output", {
        id: `${s(u)}selected_tags__`,
        class: "visually-hidden",
        for: p.value,
        "aria-live": s(f) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, oe(v.value.join(", ")), 9, Ld),
      ae("div", {
        id: `${s(u)}removed_tags__`,
        role: "status",
        "aria-live": s(f) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + oe(s(a).tagRemovedLabel) + ") " + oe(w.value), 9, Rd),
      V(D.$slots, "default", _e(Se(K.value)), () => [
        ae("ul", {
          id: `${s(u)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (b(!0), O(pe, null, ke(v.value, (Q, Z) => V(D.$slots, "tag", {
            key: Z,
            tag: Q,
            tagClass: s(a).tagClass,
            tagVariant: s(a).tagVariant,
            tagPills: s(a).tagPills,
            removeTag: X
          }, () => [
            (b(), L(rs, {
              key: Q,
              class: W(s(a).tagClass),
              tag: "li",
              variant: s(a).tagVariant,
              pill: s(a).tagPills,
              onRemove: X
            }, {
              default: R(() => [
                ce(oe(Q), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          ae("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${s(u)}tag_list__`
          }, [
            ae("div", Hd, [
              ae("input", J({
                id: p.value,
                ref_key: "input",
                ref: c,
                disabled: s(a).disabled,
                value: m.value,
                type: s(a).inputType,
                placeholder: s(a).placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, s(a).inputAttrs, {
                form: s(a).form,
                required: s(a).required || void 0,
                "aria-required": s(a).required || void 0,
                onInput: N,
                onChange: z,
                onFocus: j,
                onBlur: F
              }), null, 16, Dd),
              Y.value ? (b(), O("button", {
                key: 0,
                type: "button",
                class: W(["btn b-form-tags-button py-0", [
                  D.inputClass,
                  {
                    [`btn-${s(a).addButtonVariant}`]: s(a).addButtonVariant !== null,
                    "disabled invisible": m.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: s(a).disabled || m.value.length === 0 || S.value,
                onClick: M[0] || (M[0] = (Q) => I(m.value))
              }, [
                V(D.$slots, "add-button-text", {}, () => [
                  ce(oe(s(a).addButtonText), 1)
                ])
              ], 10, jd)) : ne("", !0)
            ])
          ], 8, Md)
        ], 8, zd),
        ae("div", Gd, [
          A.value ? (b(), O("div", qd, oe(s(a).invalidTagText) + ": " + oe(m.value), 1)) : ne("", !0),
          y.value ? (b(), O("small", Wd, oe(s(a).duplicateTagText) + ": " + oe(m.value), 1)) : ne("", !0),
          v.value.length === s(a).limit ? (b(), O("small", Ud, oe(s(a).limitTagsText), 1)) : ne("", !0)
        ])
      ]),
      s(a).name ? (b(!0), O(pe, { key: 0 }, ke(v.value, (Q, Z) => (b(), O("input", {
        key: Z,
        type: "hidden",
        name: s(a).name,
        value: Q
      }, null, 8, Kd))), 128)) : ne("", !0)
    ], 42, Ed));
  }
}), Yd = ["id", "name", "form", "value", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], Zd = /* @__PURE__ */ G({
  __name: "BFormTextarea",
  props: /* @__PURE__ */ be({
    noResize: { type: Boolean, default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    modelValue: {
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    const l = U(t, "BFormTextarea"), [a, n] = we(t, "modelValue", {
      set: (_) => dn(_, n)
    }), { input: r, computedId: u, computedAriaInvalid: i, onInput: d, onChange: c, onBlur: f, focus: p, blur: v } = Bn(l, a, n), m = kt(() => l.state), B = h(() => [
      m.value,
      l.plaintext ? "form-control-plaintext" : "form-control",
      {
        [`form-control-${l.size}`]: !!l.size
      }
    ]), w = h(() => ({
      resize: l.noResize ? "none" : void 0
    }));
    return o({
      blur: v,
      element: r,
      focus: p
    }), (_, k) => (b(), O("textarea", {
      id: s(u),
      ref_key: "input",
      ref: r,
      class: W(B.value),
      name: s(l).name || void 0,
      form: s(l).form || void 0,
      value: s(a) ?? void 0,
      disabled: s(l).disabled,
      placeholder: s(l).placeholder,
      required: s(l).required || void 0,
      autocomplete: s(l).autocomplete || void 0,
      readonly: s(l).readonly || s(l).plaintext,
      "aria-required": s(l).required || void 0,
      "aria-invalid": s(i),
      rows: s(l).rows,
      style: ze(w.value),
      wrap: s(l).wrap || void 0,
      onInput: k[0] || (k[0] = (g) => s(d)(g)),
      onChange: k[1] || (k[1] = (g) => s(c)(g)),
      onBlur: k[2] || (k[2] = (g) => s(f)(g))
    }, null, 46, Yd));
  }
}), Jd = {
  key: 0,
  class: "input-group-text"
}, Qd = ["innerHTML"], ec = { key: 1 }, tc = {
  key: 0,
  class: "input-group-text"
}, ac = ["innerHTML"], lc = { key: 1 }, oc = /* @__PURE__ */ G({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(t) {
    We(un, !0);
    const e = U(t, "BInputGroup"), l = h(() => ({
      [`input-group-${e.size}`]: e.size !== "md"
    })), a = T(() => !!e.append || !!e.appendHtml), n = T(() => !!e.prepend || !!e.prependHtml);
    return (r, u) => (b(), L(fe(s(e).tag), {
      id: s(e).id,
      class: W(["input-group", l.value]),
      role: "group"
    }, {
      default: R(() => [
        V(r.$slots, "prepend", {}, () => [
          n.value ? (b(), O("span", Jd, [
            s(e).prependHtml ? (b(), O("span", {
              key: 0,
              innerHTML: s(e).prependHtml
            }, null, 8, Qd)) : (b(), O("span", ec, oe(s(e).prepend), 1))
          ])) : ne("", !0)
        ]),
        V(r.$slots, "default"),
        V(r.$slots, "append", {}, () => [
          a.value ? (b(), O("span", tc, [
            s(e).appendHtml ? (b(), O("span", {
              key: 0,
              innerHTML: s(e).appendHtml
            }, null, 8, ac)) : (b(), O("span", lc, oe(s(e).append), 1))
          ])) : ne("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), nc = /* @__PURE__ */ G({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BInputGroupText");
    return (l, a) => (b(), L(fe(s(e).tag), { class: "input-group-text" }, {
      default: R(() => [
        V(l.$slots, "default", {}, () => [
          ce(oe(s(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), sc = /* @__PURE__ */ G({
  __name: "BListGroup",
  props: {
    flush: { type: Boolean, default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = U(t, "BListGroup"), l = h(() => {
      const n = e.flush ? !1 : e.horizontal;
      return {
        "list-group-flush": e.flush,
        "list-group-horizontal": n === !0,
        [`list-group-horizontal-${n}`]: typeof n == "string",
        "list-group-numbered": e.numbered
      };
    }), a = T(() => e.numbered === !0 ? "ol" : e.tag);
    return We(Yo, {
      numbered: T(() => e.numbered)
    }), (n, r) => (b(), L(fe(a.value), {
      class: W(["list-group", l.value])
    }, {
      default: R(() => [
        V(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), rc = /* @__PURE__ */ G({
  __name: "BListGroupItem",
  props: {
    action: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    tag: { default: "div" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BListGroupItem"), l = Lt(), a = Ve(Yo, null), { computedLink: n } = Ct(e), r = T(() => !e.button && n.value), u = T(
      () => a != null && a.numbered.value ? "li" : e.button ? "button" : r.value ? it : e.tag
    ), i = h(
      () => e.action || r.value || e.button || ["a", "router-link", "button", "b-link"].includes(e.tag)
    ), d = h(() => ({
      [`list-group-item-${e.variant}`]: e.variant !== null && e.variant !== void 0,
      "list-group-item-action": i.value,
      active: e.active,
      disabled: e.disabled
    })), c = h(() => {
      const f = {};
      return e.button && ((!l || !l.type) && (f.type = "button"), e.disabled && (f.disabled = !0)), f;
    });
    return (f, p) => (b(), L(fe(u.value), J({
      class: ["list-group-item", d.value],
      "aria-current": s(e).active ? !0 : void 0,
      "aria-disabled": s(e).disabled ? !0 : void 0,
      target: r.value ? s(e).target : void 0,
      href: s(e).button ? void 0 : s(e).href,
      to: s(e).button ? void 0 : s(e).to
    }, c.value), {
      default: R(() => [
        V(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), ic = { id: "__BVID__modal-container" }, uc = /* @__PURE__ */ G({
  __name: "BModalOrchestrator",
  props: {
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(t, { expose: o }) {
    const l = U(t, "BModalOrchestrator"), { modals: a, remove: n, show: r, confirm: u, leave: i } = _n(), d = (c) => xa(c, ["_promise", "_self", "_isConfirm", "_modelValue"]);
    return o({
      modals: a,
      show: r,
      confirm: u
    }), (c, f) => (b(), L(_t, {
      to: s(l).teleportTo,
      disabled: s(l).teleportDisabled
    }, [
      ae("div", ic, [
        (b(!0), O(pe, null, ke(s(a), (p, v) => (b(), L(fe(p.value.component), J({
          key: v,
          modelValue: p.value.props._modelValue,
          "onUpdate:modelValue": (m) => p.value.props._modelValue = m,
          ref_for: !0
        }, d(p.value.props), {
          "teleport-disabled": !0,
          "onUpdate:modelValue": (m) => {
            var B;
            return (B = s(i)) == null ? void 0 : B(p.value.props._self);
          },
          onHide: (m) => {
            if (p.value.props._isConfirm === !0) {
              if (m.trigger === "ok") {
                p.value.props._promise.resolve(!0);
                return;
              }
              if (m.trigger === "cancel") {
                p.value.props._promise.resolve(!1);
                return;
              }
              p.value.props._promise.resolve(null);
            }
            p.value.props._promise.resolve(!0);
          },
          onHidden: (m) => {
            var B;
            return (B = s(n)) == null ? void 0 : B(p.value.props._self);
          }
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onHide", "onHidden"]))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), dc = /* @__PURE__ */ G({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tabs: { type: Boolean, default: !1 },
    tag: { default: "ul" },
    underline: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = U(t, "BNav"), l = Xt(() => e.align), a = h(() => ({
      "nav-tabs": e.tabs,
      "nav-pills": e.pills && !e.tabs,
      "card-header-tabs": !e.vertical && e.cardHeader && e.tabs,
      "card-header-pills": !e.vertical && e.cardHeader && e.pills && !e.tabs,
      "flex-column": e.vertical,
      "nav-fill": !e.vertical && e.fill,
      "nav-justified": !e.vertical && e.justified,
      [l.value]: !e.vertical && e.align !== void 0,
      small: e.small,
      "nav-underline": e.underline
    }));
    return (n, r) => (b(), L(fe(s(e).tag), {
      class: W(["nav", a.value])
    }, {
      default: R(() => [
        V(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), cc = { class: "d-flex flex-row align-items-center flex-wrap" }, fc = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    floating: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: void 0 },
    validated: { type: Boolean, default: void 0 }
  },
  emits: ["submit"],
  setup(t, { emit: o }) {
    const l = U(t, "BNavForm"), a = o, n = (r) => {
      a("submit", r);
    };
    return (r, u) => (b(), O("li", cc, [
      ge(as, J(r.$attrs, {
        id: s(l).id,
        floating: s(l).floating,
        role: s(l).role,
        novalidate: s(l).novalidate,
        validated: s(l).validated,
        class: "d-flex",
        onSubmit: xt(n, ["prevent"])
      }), {
        default: R(() => [
          V(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated"])
    ]));
  }
}), vc = { class: "nav-item" }, pc = /* @__PURE__ */ G({
  __name: "BNavItem",
  props: {
    linkAttrs: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BNavItem"), a = o, n = h(
      () => pl(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return n.value.activeClass, (r, u) => (b(), O("li", vc, [
      ge(it, J({
        class: ["nav-link", r.linkClass],
        tabindex: s(l).disabled ? -1 : void 0,
        "aria-disabled": s(l).disabled ? !0 : void 0
      }, { ...n.value, ...r.linkAttrs }, {
        onClick: u[0] || (u[0] = (i) => a("click", i))
      }), {
        default: R(() => [
          V(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
}), mc = { class: "nav-item dropdown" }, bc = /* @__PURE__ */ G({
  __name: "BNavItemDropdown",
  props: /* @__PURE__ */ be({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !0 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    skipWrapper: { type: Boolean },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" },
    wrapperClass: {},
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BNavItemDropdown"), n = e, r = we(t, "modelValue"), u = H(null), i = () => {
      var f;
      (f = u.value) == null || f.hide();
    }, d = () => {
      var f;
      (f = u.value) == null || f.show();
    };
    return o({
      hide: i,
      show: d,
      toggle: () => {
        var f;
        (f = u.value) == null || f.toggle();
      }
    }), (f, p) => (b(), O("li", mc, [
      ge(ts, J({
        ref_key: "dropdown",
        ref: u
      }, s(a), {
        modelValue: r.value,
        "onUpdate:modelValue": p[0] || (p[0] = (v) => r.value = v),
        "is-nav": "",
        onShow: p[1] || (p[1] = (v) => n("show", v)),
        onShown: p[2] || (p[2] = (v) => n("shown")),
        onHide: p[3] || (p[3] = (v) => n("hide", v)),
        onHidden: p[4] || (p[4] = (v) => n("hidden")),
        onHidePrevented: p[5] || (p[5] = (v) => n("hide-prevented")),
        onShowPrevented: p[6] || (p[6] = (v) => n("show-prevented")),
        onClick: p[7] || (p[7] = (v) => n("click", v)),
        onToggle: p[8] || (p[8] = (v) => n("toggle"))
      }), {
        "button-content": R(() => [
          V(f.$slots, "button-content")
        ]),
        "toggle-text": R(() => [
          V(f.$slots, "toggle-text")
        ]),
        default: R(() => [
          V(f.$slots, "default", {
            hide: i,
            show: d
          })
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), yc = { class: "navbar-text" }, gc = /* @__PURE__ */ G({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BNavText");
    return (l, a) => (b(), O("li", yc, [
      V(l.$slots, "default", {}, () => [
        ce(oe(s(e).text), 1)
      ])
    ]));
  }
}), hc = /* @__PURE__ */ G({
  __name: "BNavbar",
  props: {
    autoClose: { type: Boolean, default: !0 },
    container: { type: [Boolean, String], default: "fluid" },
    fixed: { default: void 0 },
    print: { type: Boolean, default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BNavbar"), l = T(() => e.tag === "nav" ? void 0 : "navigation"), a = li(() => e.container), n = h(() => ({
      "d-print": e.print,
      [`sticky-${e.sticky}`]: e.sticky !== void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`fixed-${e.fixed}`]: e.fixed !== void 0,
      "navbar-expand": e.toggleable === !1,
      [`navbar-expand-${e.toggleable}`]: typeof e.toggleable == "string"
    }));
    return We(vl, {
      tag: T(() => e.tag),
      autoClose: T(() => e.autoClose)
    }), (r, u) => (b(), L(fe(s(e).tag), {
      class: W(["navbar", n.value]),
      role: l.value
    }, {
      default: R(() => [
        s(e).container !== !1 ? (b(), O("div", {
          key: 0,
          class: W(s(a))
        }, [
          V(r.$slots, "default")
        ], 2)) : V(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Bc = /* @__PURE__ */ G({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    noRel: { type: Boolean },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BNavbarBrand"), { computedLink: l, computedLinkProps: a } = Ct(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), n = T(() => l.value ? it : e.tag);
    return (r, u) => (b(), L(fe(n.value), J({ class: "navbar-brand" }, s(a)), {
      default: R(() => [
        V(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _c = /* @__PURE__ */ G({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "ul" }
  },
  setup(t) {
    const e = U(t, "BNavbarNav"), l = Xt(() => e.align), a = h(() => ({
      "nav-fill": e.fill,
      "nav-justified": e.justified,
      [l.value]: e.align !== void 0,
      small: e.small
    }));
    return (n, r) => (b(), O("ul", {
      class: W(["navbar-nav", a.value])
    }, [
      V(n.$slots, "default")
    ], 2));
  }
}), ao = (t, o) => t.setAttribute("data-bs-theme", o), wc = {
  mounted(t, o) {
    ao(t, o.value);
  },
  updated(t, o) {
    ao(t, o.value);
  }
}, Cc = (t, o) => {
  const { modifiers: e, arg: l, value: a } = t, n = Object.keys(e || {}), r = typeof a == "string" ? a.split(oa) : a;
  if (o.tagName.toLowerCase() === "a") {
    const u = o.getAttribute("href") || "";
    Ur.test(u) && n.push(u.replace(Wr, ""));
  }
  return Array.prototype.concat.apply([], [l, r]).forEach((u) => typeof u == "string" && n.push(u)), n.filter((u, i, d) => u && d.indexOf(u) === i);
}, kc = (t, o) => {
  t.forEach((e) => {
    const l = document.getElementById(e);
    l !== null && l.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => is(t, o), 50);
}, is = (t, o) => {
  let e = !1;
  t.forEach((l) => {
    const a = document.getElementById(l);
    a != null && a.classList.contains("show") && (e = !0), a != null && a.classList.contains("closing") && (e = !1);
  }), o.setAttribute("aria-expanded", e ? "true" : "false"), o.classList.remove(e ? "collapsed" : "not-collapsed"), o.classList.add(e ? "not-collapsed" : "collapsed");
}, lo = (t, o) => {
  const e = Cc(o, t);
  e.length !== 0 && (t.__toggle && t.removeEventListener("click", t.__toggle), t.__toggle = () => kc(e, t), t.addEventListener("click", t.__toggle), t.setAttribute("aria-controls", e.join(" ")), is(e, t));
}, Ya = {
  mounted: lo,
  updated: lo,
  unmounted(t) {
    t.removeEventListener("click", t.__toggle), t.removeAttribute("aria-controls"), t.removeAttribute("aria-expanded");
  }
}, Tc = {
  mounted(t, o) {
    if (!Ut(o.value))
      return;
    const l = pa(o.value, t);
    !l.content && !l.title || ba(t, o, {
      ...ma(o, t),
      ...l
    });
  },
  updated(t, o) {
    if (!Ut(o.value))
      return;
    const l = pa(o.value, t);
    !l.content && !l.title || (ya(t), ba(t, o, {
      ...ma(o, t),
      ...l
    }));
  },
  beforeUnmount(t) {
    ya(t);
  }
}, oo = (t, o) => {
  t.$__scrollspy && t.$__scrollspy.cleanup();
  const { arg: e, value: l } = o, a = typeof l == "object" && l !== null, n = e || (typeof l == "string" ? l : a ? l.content || l.element : null);
  t.$__scrollspy = Cn(n, t, a ? xa(l, ["content", "element"]) : {});
}, Sc = {
  mounted: oo,
  updated: oo,
  beforeUnmount(t) {
    t.$__scrollspy && t.$__scrollspy.cleanup();
  }
}, xc = {
  mounted(t, o) {
    const e = Ut(o.value);
    if (!e)
      return;
    const l = pa(o.value, t);
    !l.content && !l.title || ba(t, o, {
      noninteractive: !0,
      ...ma(o, t),
      title: l.title ?? l.content ?? "",
      tooltip: e
    });
  },
  updated(t, o) {
    const e = Ut(o.value);
    if (!e)
      return;
    const l = pa(o.value, t);
    !l.content && !l.title || (ya(t), ba(t, o, {
      noninteractive: !0,
      ...ma(o, t),
      title: l.title ?? l.content ?? "",
      tooltip: e
    }));
  },
  beforeUnmount(t) {
    ya(t);
  }
}, vf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: wc,
  vBModal: Ya,
  vBPopover: Tc,
  vBScrollspy: Sc,
  vBToggle: Ya,
  vBTooltip: xc
}, Symbol.toStringTag, { value: "Module" })), $c = ["disabled", "aria-label"], Ac = /* @__PURE__ */ ae("span", { class: "navbar-toggler-icon" }, null, -1), Vc = /* @__PURE__ */ G({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: Boolean, default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: o }) {
    const l = U(t, "BNavbarToggle"), a = o, n = h(() => ({
      disabled: l.disabled
    })), r = (u) => {
      l.disabled || a("click", u);
    };
    return (u, i) => dt((b(), O("button", {
      class: W(["navbar-toggler", n.value]),
      type: "button",
      disabled: s(l).disabled,
      "aria-label": s(l).label,
      onClick: r
    }, [
      V(u.$slots, "default", {}, () => [
        Ac
      ])
    ], 10, $c)), [
      [s(Ya), s(l).disabled ? void 0 : s(l).target]
    ]);
  }
}), Fc = ["id", "aria-labelledby"], Nc = ["id"], no = "offcanvas-fallback-focus", Oc = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: /* @__PURE__ */ be({
    hideBackdrop: { type: Boolean, default: !1 },
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: Boolean, default: !1 },
    footerClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFocus: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noTrap: { type: Boolean, default: !1 },
    noHeaderClose: { type: Boolean, default: !1 },
    placement: { default: "start" },
    shadow: { type: [String, Boolean], default: !1 },
    title: { default: void 0 },
    responsive: {},
    width: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["close", "esc", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BOffcanvas"), n = e, r = De(), u = we(t, "modelValue"), i = Ce(() => a.id, "offcanvas"), d = _r(Br), c = d.greaterOrEqual(() => a.responsive ?? "xs"), f = d.smallerOrEqual(() => a.responsive ?? "xs"), p = h(
      () => a.responsive !== void 0 && c.value
    );
    wn(u, () => a.bodyScrolling || p.value);
    const v = H(null), m = H(null);
    qe(
      "Escape",
      () => {
        C("esc");
      },
      { target: v }
    );
    const { focused: B } = Re(v, {
      initialValue: u.value && a.noFocus === !1
    }), w = H(u.value), { needsFallback: _ } = Ln({
      element: v,
      isActive: w,
      noTrap: () => a.noTrap || p.value,
      fallbackFocus: {
        classSelector: no,
        ref: m
      }
    }), k = H(!1), g = H(!1), $ = h(
      () => (a.responsive === void 0 || !p.value) && a.hideBackdrop === !1 && u.value === !0
    ), y = h(
      () => a.lazy === !1 || a.lazy === !0 && k.value === !0 || a.lazy === !0 && u.value === !0
    ), A = T(() => !Pe(r["header-close"])), S = h(() => [
      { "text-reset": !A.value },
      a.headerCloseClass
    ]), Y = h(() => ({
      variant: A.value ? a.headerCloseVariant : void 0,
      class: S.value
    })), K = h(
      () => g.value === !0 ? null : {
        enterToClass: "showing",
        enterFromClass: "",
        leaveToClass: "hiding show",
        leaveFromClass: "show"
      }
    ), P = T(() => !Pe(r.footer)), j = h(() => [
      a.responsive === void 0 ? "offcanvas" : `offcanvas-${a.responsive}`,
      `offcanvas-${a.placement}`,
      {
        show: u.value && w.value === !0,
        [`shadow-${a.shadow}`]: !!a.shadow
      }
    ]), F = h(() => ({
      width: a.width
    })), N = h(() => ({
      visible: u.value,
      placement: a.placement,
      hide: C
    })), z = (Q, Z = {}) => new wt(Q, {
      cancelable: !1,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...Z,
      componentId: i.value
    }), C = (Q = "") => {
      if (Q === "backdrop" && a.noCloseOnBackdrop || Q === "esc" && a.noCloseOnEsc) {
        n("hide-prevented");
        return;
      }
      const Z = z("hide", { cancelable: Q !== "", trigger: Q });
      if (Q === "close" && n(Q, Z), Q === "esc" && n(Q, Z), n("hide", Z), Z.defaultPrevented) {
        n("hide-prevented");
        return;
      }
      u.value = !1;
    }, x = () => {
      const Q = z("show", { cancelable: !0 });
      if (n("show", Q), Q.defaultPrevented) {
        u.value = !1, n("show-prevented");
        return;
      }
      u.value = !0;
    }, E = () => {
      Ne(() => {
        a.noFocus === !1 && (B.value = !0);
      });
    }, I = () => x(), X = () => {
      w.value = !0, E(), n("shown", z("shown")), a.lazy === !0 && (k.value = !0);
    }, D = () => {
      g.value = !1, w.value = !1;
    }, M = () => {
      n("hidden", z("hidden")), a.lazy === !0 && (k.value = !1);
    };
    return $e(v, "bv-toggle", () => {
      u.value ? C() : x();
    }), de(c, (Q) => {
      a.responsive !== void 0 && (u.value = Q);
    }), de(f, (Q) => {
      a.responsive === void 0 && Q === !0 || (g.value = !0);
    }), o({
      hide: C,
      show: x
    }), (Q, Z) => (b(), L(_t, {
      to: s(a).teleportTo,
      disabled: s(a).teleportDisabled || p.value
    }, [
      ge(el, J(K.value, {
        onBeforeEnter: I,
        onAfterEnter: X,
        onLeave: D,
        onAfterLeave: M
      }), {
        default: R(() => [
          dt(ae("div", J({
            id: s(i),
            ref_key: "element",
            ref: v,
            "aria-modal": "true",
            role: "dialog",
            class: j.value,
            style: F.value,
            tabindex: "-1",
            "aria-labelledby": `${s(i)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, Q.$attrs), [
            y.value ? (b(), O(pe, { key: 0 }, [
              s(a).noHeader ? ne("", !0) : (b(), O("div", {
                key: 0,
                class: W(["offcanvas-header", s(a).headerClass])
              }, [
                V(Q.$slots, "header", _e(Se(N.value)), () => [
                  ae("h5", {
                    id: `${s(i)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    V(Q.$slots, "title", _e(Se(N.value)), () => [
                      ce(oe(s(a).title), 1)
                    ])
                  ], 8, Nc),
                  s(a).noHeaderClose ? ne("", !0) : (b(), O(pe, { key: 0 }, [
                    A.value ? (b(), L(vt, J({ key: 0 }, Y.value, {
                      onClick: Z[0] || (Z[0] = (q) => C("close"))
                    }), {
                      default: R(() => [
                        V(Q.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (b(), L(zt, J({
                      key: 1,
                      "aria-label": s(a).headerCloseLabel
                    }, Y.value, {
                      onClick: Z[1] || (Z[1] = (q) => C("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              ae("div", J({
                class: ["offcanvas-body", s(a).bodyClass]
              }, s(a).bodyAttrs), [
                V(Q.$slots, "default", _e(Se(N.value)))
              ], 16),
              P.value ? (b(), O("div", {
                key: 1,
                class: W(s(a).footerClass)
              }, [
                V(Q.$slots, "footer", _e(Se(N.value)))
              ], 2)) : ne("", !0)
            ], 64)) : ne("", !0),
            s(_) ? (b(), O("div", {
              key: 1,
              ref_key: "fallbackFocusElement",
              ref: m,
              class: W(no),
              tabindex: "0",
              style: { width: "0", height: "0", overflow: "hidden" }
            }, null, 512)) : ne("", !0)
          ], 16, Fc), [
            [Kt, u.value || p.value]
          ])
        ]),
        _: 3
      }, 16),
      $.value ? V(Q.$slots, "backdrop", { key: 0 }, () => [
        ae("div", {
          class: "offcanvas-backdrop fade show",
          onClick: Z[2] || (Z[2] = (q) => C("backdrop"))
        })
      ]) : ne("", !0)
    ], 8, ["to", "disabled"]));
  }
}), us = /* @__PURE__ */ G({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: Boolean, default: !1 },
    noCenter: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noSpinner: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    show: { type: Boolean, default: !1 },
    spinnerSmall: { type: Boolean, default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "hidden", "shown"],
  setup(t, { emit: o }) {
    const l = U(t, "BOverlay"), a = o, n = { top: 0, left: 0, bottom: 0, right: 0 }, r = yl(() => ({
      rounded: l.rounded,
      roundedTop: l.roundedTop,
      roundedBottom: l.roundedBottom,
      roundedStart: l.roundedStart,
      roundedEnd: l.roundedEnd
    })), u = T(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), i = T(() => l.show ? !0 : null), d = h(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: l.spinnerSmall
    })), c = h(() => ({
      ...n,
      zIndex: l.zIndex || 10
    })), f = h(() => ({
      "position-absolute": !l.noWrap || !l.fixed,
      "position-fixed": l.noWrap && l.fixed
    })), p = h(() => [u.value, r.value]), v = h(() => ({
      ...n,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), m = h(
      () => l.noCenter ? n : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (B, w) => (b(), L(Yt, {
      tag: s(l).wrapTag,
      class: "b-overlay-wrap position-relative",
      "aria-busy": i.value,
      skip: s(l).noWrap
    }, {
      default: R(() => [
        V(B.$slots, "default"),
        ge($a, {
          "no-fade": s(l).noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onAfterEnter: w[1] || (w[1] = (_) => a("shown")),
          onAfterLeave: w[2] || (w[2] = (_) => a("hidden"))
        }, {
          default: R(() => [
            s(l).show ? (b(), L(fe(s(l).overlayTag), {
              key: 0,
              class: W(["b-overlay", f.value]),
              style: ze(c.value),
              onClick: w[0] || (w[0] = (_) => a("click", _))
            }, {
              default: R(() => [
                ae("div", {
                  class: W(["position-absolute", p.value]),
                  style: ze(v.value)
                }, null, 6),
                ae("div", {
                  class: "position-absolute",
                  style: ze(m.value)
                }, [
                  V(B.$slots, "overlay", _e(Se(d.value)), () => [
                    s(l).noSpinner ? ne("", !0) : (b(), L(Aa, _e(J({ key: 0 }, d.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : ne("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["tag", "aria-busy", "skip"]));
  }
}), Pc = ["aria-disabled", "aria-label"], so = 20, ro = 0, Ic = /* @__PURE__ */ G({
  __name: "BPagination",
  props: /* @__PURE__ */ be({
    align: { default: "start" },
    ariaControls: { default: void 0 },
    ariaLabel: { default: "Pagination" },
    disabled: { type: Boolean, default: !1 },
    ellipsisClass: { default: void 0 },
    ellipsisText: { default: "…" },
    firstClass: { default: void 0 },
    firstNumber: { type: Boolean, default: !1 },
    firstText: { default: "«" },
    hideEllipsis: { type: Boolean, default: !1 },
    hideGotoEndButtons: { type: Boolean, default: !1 },
    labelFirstPage: { default: "Go to first page" },
    labelLastPage: { default: "Go to last page" },
    labelNextPage: { default: "Go to next page" },
    labelPage: { default: "Go to page" },
    labelPrevPage: { default: "Go to previous page" },
    lastClass: { default: void 0 },
    lastNumber: { type: Boolean, default: !1 },
    lastText: { default: "»" },
    limit: { default: 5 },
    modelValue: {},
    nextClass: { default: void 0 },
    nextText: { default: "›" },
    pageClass: { default: void 0 },
    perPage: { default: so },
    pills: { type: Boolean, default: !1 },
    prevClass: { default: void 0 },
    prevText: { default: "‹" },
    size: { default: void 0 },
    totalRows: { default: ro }
  }, {
    modelValue: { default: 1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["page-click"], ["update:modelValue"]),
  setup(t, { emit: o }) {
    const d = U(t, "BPagination"), c = o, f = we(t, "modelValue"), p = Be(() => d.limit, { nanToZero: !0, method: "parseInt" }), v = Be(() => d.perPage, { nanToZero: !0, method: "parseInt" }), m = Be(() => d.totalRows, { nanToZero: !0, method: "parseInt" }), B = Be(f, { nanToZero: !0, method: "parseInt" }), w = T(() => Math.max(v.value || so, 1)), _ = T(() => Math.max(m.value || ro, 0)), k = T(() => Math.ceil(_.value / w.value)), g = T(() => d.align === "fill"), $ = T(() => d.align === "fill" ? "start" : d.align), y = Xt($), A = (te) => te === B.value, S = (te) => d.disabled ? null : A(te) ? "0" : "-1", Y = (te) => d.disabled || A(te) || B.value < 1 || // Check if the number is out of bounds
    te < 1 || te > k.value, K = h(() => Y(1)), P = h(() => Y(B.value - 1)), j = h(() => Y(k.value)), F = h(() => Y(B.value + 1)), N = ({
      page: te,
      classVal: ve,
      dis: ue,
      slotName: me,
      textValue: le,
      tabIndex: re,
      label: he,
      position: ee,
      isActive: ye,
      role: Te,
      hidden: Ae
    }) => ({
      li: {
        class: [
          "page-item",
          {
            active: ye,
            disabled: ue,
            "flex-fill": g.value,
            "d-flex": g.value && !ue
          },
          ve
        ],
        role: Te,
        "aria-hidden": Ae
      },
      button: {
        is: ue ? "span" : "button",
        class: ["page-link", { "flex-grow-1": !ue && g.value }],
        "aria-label": he,
        "aria-controls": d.ariaControls || void 0,
        "aria-disabled": ue ? !0 : void 0,
        "aria-posinset": ee,
        "aria-setsize": ee ? k.value : void 0,
        role: "menuitem",
        type: ue ? void 0 : "button",
        tabindex: ue ? void 0 : re
      },
      text: {
        name: me,
        active: ye,
        value: le ?? te,
        page: te,
        disabled: ue,
        index: te - 1,
        content: le ? void 0 : te
      },
      clickHandler: (Ze) => se(Ze, te)
    }), z = ({
      page: te,
      classVal: ve,
      dis: ue,
      slotName: me,
      textValue: le,
      label: re
    }) => N({ page: te, classVal: ve, dis: ue, slotName: me, textValue: le, label: re, tabIndex: "-1" }), C = (te) => N({
      page: te,
      dis: d.disabled,
      classVal: d.pageClass,
      slotName: "page",
      label: d.labelPage ? `${d.labelPage} ${te}` : void 0,
      tabIndex: S(te) ?? void 0,
      position: te,
      isActive: A(te)
    }), x = h(
      () => z({
        page: 1,
        dis: K.value,
        classVal: d.firstClass,
        slotName: "first-text",
        textValue: d.firstText,
        label: d.labelFirstPage
      })
    ), E = h(
      () => z({
        page: Math.max(B.value - 1, 1),
        dis: P.value,
        classVal: d.prevClass,
        slotName: "prev-text",
        textValue: d.prevText,
        label: d.labelPrevPage
      })
    ), I = h(
      () => z({
        page: Math.min(B.value + 1, k.value),
        dis: F.value,
        classVal: d.nextClass,
        slotName: "next-text",
        textValue: d.nextText,
        label: d.labelNextPage
      })
    ), X = h(
      () => z({
        page: k.value,
        dis: j.value,
        classVal: d.lastClass,
        slotName: "last-text",
        textValue: d.lastText,
        label: d.labelLastPage
      })
    ), D = va(), M = va(), Q = h(() => ({
      li: {
        class: [
          "page-item",
          "disabled",
          "bv-d-xs-down-none",
          g.value ? "flex-fill" : "",
          d.ellipsisClass
        ],
        role: "separator"
      },
      span: {
        class: ["page-link"]
      }
    })), Z = h(() => [
      y.value,
      {
        [`pagination-${d.size}`]: d.size !== void 0,
        "b-pagination-pills": d.pills
      }
    ]), q = h(() => ({
      pageSize: w.value,
      totalRows: m.value,
      numberOfPages: k.value
    })), se = (te, ve) => {
      if (ve === B.value)
        return;
      const ue = new ut("page-click", {
        cancelable: !0,
        target: te.target
      });
      c("page-click", ue, ve), !ue.defaultPrevented && (f.value = ve);
    };
    de(B, (te) => {
      const ue = ((me, le) => {
        const re = me || 1;
        return re > le ? le : re < 1 ? 1 : re;
      })(te, k.value);
      ue !== f.value && (f.value = ue);
    }), de(q, (te, ve) => {
      (ve.pageSize !== te.pageSize && ve.totalRows === te.totalRows || ve.numberOfPages !== te.numberOfPages && B.value > ve.numberOfPages) && (f.value = 1);
    });
    const ie = h(() => {
      const te = k.value, { value: ve } = B, ue = p.value, me = d.firstNumber ? 1 : 0, le = d.lastNumber ? 1 : 0, re = d.hideEllipsis || ue <= 3, he = d.hideGotoEndButtons ? 1 : 0;
      if (te < ue + me + le)
        return [
          !me && !he ? -1 : null,
          -2,
          ...Array.from({ length: te }, (Te, Ae) => Ae + 1),
          -3,
          !le && !he ? -4 : null
        ].filter((Te) => Te !== null);
      const ee = Array.from({ length: ue + 4 - he * 2 });
      he ? (ee[0] = -2, ee[ee.length - 1] = -3) : (me ? (ee[0] = -2, ee[1] = 1) : (ee[0] = -1, ee[1] = -2), le ? (ee[ee.length - 1] = -3, ee[ee.length - 2] = te) : (ee[ee.length - 1] = -4, ee[ee.length - 2] = -3));
      const ye = Math.floor(ue / 2);
      if (ve <= ye + me) {
        for (let Te = 1; Te <= ue; Te++)
          ee[Te + 1 - he] = Te + me;
        re || (ee[ee.length - 3] = -5);
      }
      if (ve > te - ye - le) {
        const Te = te - (ue - 1) - le;
        for (let Ae = 0; Ae < ue; Ae++)
          ee[Ae + 2 - he] = Te + Ae;
        re || (ee[2] = -5);
      }
      if (!ee[2]) {
        const Te = ve - Math.floor(ue / 2);
        for (let Ae = 0; Ae < ue; Ae++)
          ee[Ae + 2 - he] = Te + Ae;
        re || (ee[2] = -5, ee[ee.length - 3] = -5);
      }
      return ee;
    });
    return (te, ve) => (b(), O("ul", {
      class: W(["pagination", Z.value]),
      role: "menubar",
      "aria-disabled": s(d).disabled,
      "aria-label": s(d).ariaLabel || void 0
    }, [
      ge(s(D).define, null, {
        default: R(({ button: ue, li: me, text: le, clickHandler: re }) => [
          ae("li", _e(Se(me)), [
            (b(), L(fe(ue.is), J(ue, { onClick: re }), {
              default: R(() => [
                V(te.$slots, le.name, {
                  disabled: le.disabled,
                  page: le.page,
                  index: le.index,
                  active: le.active,
                  content: le.value
                }, () => [
                  ce(oe(le.value), 1)
                ])
              ]),
              _: 2
            }, 1040, ["onClick"]))
          ], 16)
        ]),
        _: 3
      }),
      ge(s(M).define, null, {
        default: R(() => [
          ae("li", _e(Se(Q.value.li)), [
            ae("span", _e(Se(Q.value.span)), [
              V(te.$slots, "ellipsis-text", {}, () => [
                ce(oe(s(d).ellipsisText || "..."), 1)
              ])
            ], 16)
          ], 16)
        ]),
        _: 3
      }),
      (b(!0), O(pe, null, ke(ie.value, (ue) => (b(), O(pe, {
        key: `page-${ue}`
      }, [
        ue === -1 ? (b(), L(s(D).reuse, J({
          key: 0,
          ref_for: !0
        }, x.value), null, 16)) : ue === -2 ? (b(), L(s(D).reuse, J({
          key: 1,
          ref_for: !0
        }, E.value), null, 16)) : ue === -3 ? (b(), L(s(D).reuse, J({
          key: 2,
          ref_for: !0
        }, I.value), null, 16)) : ue === -4 ? (b(), L(s(D).reuse, J({
          key: 3,
          ref_for: !0
        }, X.value), null, 16)) : ue === -5 ? (b(), L(s(M).reuse, { key: 4 })) : ue !== null ? (b(), L(s(D).reuse, J({
          key: 5,
          ref_for: !0
        }, C(ue)), null, 16)) : ne("", !0)
      ], 64))), 128))
    ], 10, Pc));
  }
}), Ue = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    animation: { default: void 0 },
    cols: { default: 12 },
    size: { default: "md" },
    tag: { default: "span" },
    variant: { default: null },
    width: { default: void 0 },
    wrapperTag: { default: "span" }
  },
  setup(t) {
    const e = U(t, "BPlaceholder"), l = T(
      () => e.width === void 0 ? void 0 : typeof e.width == "number" ? e.width.toString() : e.width.replace("%", "")
    ), a = T(
      () => e.cols === void 0 ? void 0 : typeof e.cols == "number" ? e.cols.toString() : e.cols
    ), n = h(() => ({
      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`placeholder-${e.size}`]: e.size !== "md"
    })), r = h(() => ({
      [`placeholder-${e.animation}`]: e.animation !== void 0
    })), u = h(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (i, d) => (b(), L(fe(s(e).wrapperTag), {
      class: W(r.value)
    }, {
      default: R(() => [
        (b(), L(fe(i.tag), J(i.$attrs, {
          class: ["placeholder", n.value],
          style: u.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), ds = /* @__PURE__ */ G({
  __name: "BPlaceholderButton",
  props: {
    animation: { default: void 0 },
    cols: { default: void 0 },
    tag: { default: "div" },
    variant: { default: "primary" },
    width: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BPlaceholderButton"), l = h(() => ({
      [`btn-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (b(), L(Ue, {
      class: W(["btn disabled", l.value]),
      animation: s(e).animation,
      width: s(e).width,
      cols: s(e).cols,
      tag: s(e).tag,
      style: { cursor: "wait", "pointer-events": "auto" }
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
}), Ec = /* @__PURE__ */ G({
  __name: "BPlaceholderCard",
  props: {
    animation: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    footerWidth: { default: 100 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    headerWidth: { default: 100 },
    imgBlankColor: { default: "#868e96" },
    imgPlacement: { default: "top" },
    imgHeight: { default: 100 },
    imgSrc: { default: void 0 },
    noButton: { type: Boolean, default: !1 },
    noFooter: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noImg: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BPlaceholderCard"), l = h(() => ({
      animation: e.animation,
      size: e.size,
      variant: e.variant
    })), a = T(() => e.noButton ? Ue : ds);
    return (n, r) => (b(), L(es, {
      "img-placement": s(e).imgPlacement
    }, tl({
      default: R(() => [
        V(n.$slots, "default", {}, () => [
          ge(Ue, J({ cols: "7" }, l.value), null, 16),
          ge(Ue, J({ cols: "4" }, l.value), null, 16),
          ge(Ue, J({ cols: "4" }, l.value), null, 16),
          ge(Ue, J({ cols: "6" }, l.value), null, 16),
          ge(Ue, J({ cols: "8" }, l.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      s(e).noImg ? void 0 : {
        name: "img",
        fn: R(() => [
          V(n.$slots, "img", {}, () => [
            ge(hl, {
              blank: !s(e).imgSrc,
              "blank-color": s(e).imgBlankColor,
              height: s(e).imgSrc ? void 0 : s(e).imgHeight,
              src: s(e).imgSrc,
              "img-placement": s(e).imgPlacement,
              style: { cursor: "wait" }
            }, null, 8, ["blank", "blank-color", "height", "src", "img-placement"])
          ])
        ]),
        key: "0"
      },
      s(e).noHeader ? void 0 : {
        name: "header",
        fn: R(() => [
          V(n.$slots, "header", {}, () => [
            ge(Ue, {
              width: s(e).headerWidth,
              variant: s(e).headerVariant,
              animation: s(e).headerAnimation,
              size: s(e).headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      s(e).noFooter ? void 0 : {
        name: "footer",
        fn: R(() => [
          V(n.$slots, "footer", {}, () => [
            (b(), L(fe(a.value), {
              width: s(e).footerWidth,
              animation: s(e).footerAnimation,
              size: s(e).noButton ? s(e).footerSize : void 0,
              variant: s(e).footerVariant
            }, null, 8, ["width", "animation", "size", "variant"]))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-placement"]));
  }
}), Lc = "300px", Bl = /* @__PURE__ */ G({
  __name: "BTableSimple",
  props: {
    bordered: { type: Boolean, default: !1 },
    borderless: { type: Boolean, default: !1 },
    borderVariant: { default: null },
    captionTop: { type: Boolean, default: !1 },
    dark: { type: Boolean, default: !1 },
    fixed: { type: Boolean, default: !1 },
    hover: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: !1 },
    outlined: { type: Boolean, default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: Boolean, default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    stickyHeader: { type: [Boolean, String, Number], default: !1 },
    striped: { type: Boolean, default: !1 },
    stripedColumns: { type: Boolean, default: !1 },
    variant: { default: null },
    tableAttrs: { default: void 0 },
    tableClass: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BTableSimple"), l = h(() => [
      e.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": e.bordered,
        "table-borderless": e.borderless,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "caption-top": e.captionTop,
        "table-dark": e.dark,
        "table-hover": e.hover,
        "b-table-stacked": e.stacked === !0,
        [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
        "table-striped": e.striped,
        "table-sm": e.small,
        [`table-${e.variant}`]: e.variant !== null,
        "table-striped-columns": e.stripedColumns
      }
    ]), a = h(() => ({
      id: e.id,
      class: l.value,
      ...e.tableAttrs
    })), n = ga(
      h(
        () => (e.stickyHeader === !0 ? Lc : e.stickyHeader) || NaN
      )
    ), r = h(() => e.stickyHeader !== !1), u = h(() => e.responsive !== !1 || r.value), i = h(
      () => r.value ? { maxHeight: n.value } : void 0
    ), d = h(() => ({
      "table-responsive": e.responsive === !0,
      [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
      "b-table-sticky-header": r.value
    }));
    return (c, f) => u.value ? (b(), O("div", {
      key: 0,
      class: W(d.value),
      style: ze(i.value)
    }, [
      ae("table", _e(Se(a.value)), [
        V(c.$slots, "default")
      ], 16)
    ], 6)) : (b(), O("table", _e(J({ key: 1 }, a.value)), [
      V(c.$slots, "default")
    ], 16));
  }
}), Rc = /* @__PURE__ */ G({
  __name: "BPlaceholderTable",
  props: {
    animation: { default: void 0 },
    cellWidth: { default: 100 },
    columns: { default: 5 },
    footerAnimation: { default: void 0 },
    footerCellWidth: { default: 100 },
    footerColumns: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerCellWidth: { default: 100 },
    headerColumns: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    hideHeader: { type: Boolean, default: !1 },
    rows: { default: 3 },
    showFooter: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BPlaceholderTable"), l = Be(() => e.columns), a = Be(() => e.rows), n = T(() => e.headerColumns ?? NaN), r = T(() => e.footerColumns ?? NaN), u = Be(n), i = Be(r), d = T(() => l.value || 5), c = T(() => a.value || 3), f = T(
      () => e.headerColumns === void 0 ? d.value : u.value
    ), p = T(
      () => e.footerColumns === void 0 ? d.value : i.value
    );
    return (v, m) => (b(), L(Bl, null, {
      default: R(() => [
        s(e).hideHeader ? ne("", !0) : V(v.$slots, "thead", { key: 0 }, () => [
          ae("thead", null, [
            ae("tr", null, [
              (b(!0), O(pe, null, ke(f.value, (B, w) => (b(), O("th", { key: w }, [
                ge(Ue, {
                  size: s(e).headerSize,
                  variant: s(e).headerVariant,
                  animation: s(e).headerAnimation,
                  width: s(e).headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        V(v.$slots, "default", {}, () => [
          ae("tbody", null, [
            (b(!0), O(pe, null, ke(c.value, (B, w) => (b(), O("tr", { key: w }, [
              (b(!0), O(pe, null, ke(d.value, (_, k) => (b(), O("td", { key: k }, [
                ge(Ue, {
                  size: s(e).size,
                  variant: s(e).variant,
                  animation: s(e).animation,
                  width: s(e).cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        s(e).showFooter ? V(v.$slots, "tfoot", { key: 1 }, () => [
          ae("tfoot", null, [
            ae("tr", null, [
              (b(!0), O(pe, null, ke(p.value, (B, w) => (b(), O("th", { key: w }, [
                ge(Ue, {
                  size: s(e).footerSize,
                  variant: s(e).footerVariant,
                  animation: s(e).footerAnimation,
                  width: s(e).footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : ne("", !0)
      ]),
      _: 3
    }));
  }
}), zc = /* @__PURE__ */ G({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = U(t, "BPlaceholderWrapper");
    return (l, a) => s(e).loading ? V(l.$slots, "loading", { key: 0 }) : V(l.$slots, "default", { key: 1 });
  }
}), Mc = /* @__PURE__ */ G({
  __name: "BRow",
  props: {
    tag: { default: "div" },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    noGutters: { type: Boolean, default: !1 },
    alignV: { default: void 0 },
    alignH: { default: void 0 },
    alignContent: { default: void 0 },
    cols: { default: void 0 },
    colsSm: { default: void 0 },
    colsMd: { default: void 0 },
    colsLg: { default: void 0 },
    colsXl: { default: void 0 },
    colsXxl: { default: void 0 }
  },
  setup(t) {
    const e = U(t, "BRow"), l = Xt(() => e.alignH), a = h(
      () => la(
        {
          cols: e.cols,
          colsLg: e.colsLg,
          colsMd: e.colsMd,
          colsSm: e.colsSm,
          colsXl: e.colsXl,
          colsXxl: e.colsXxl
        },
        ["cols", "colsLg", "colsMd", "colsSm", "colsXl", "colsXxl"],
        "cols",
        "row-cols"
      )
    ), n = h(() => [
      a.value,
      {
        [`gx-${e.gutterX}`]: e.gutterX !== void 0,
        [`gy-${e.gutterY}`]: e.gutterY !== void 0,
        "g-0": e.noGutters,
        [`align-items-${e.alignV}`]: e.alignV !== void 0,
        [l.value]: e.alignH !== void 0,
        [`align-content-${e.alignContent}`]: e.alignContent !== void 0
      }
    ]);
    return (r, u) => (b(), L(fe(s(e).tag), {
      class: W(["row", n.value])
    }, {
      default: R(() => [
        V(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Je = (t) => typeof t == "object" && t !== null, Vt = (t) => typeof t == "object" && t !== null && "key" in t, cs = /* @__PURE__ */ G({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BTbody"), l = h(() => ({
      [`thead-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (b(), O("tbody", {
      class: W(l.value)
    }, [
      V(a.$slots, "default")
    ], 2));
  }
}), Hc = ["scope", "colspan", "rowspan", "data-label"], Dc = { key: 0 }, Ot = /* @__PURE__ */ G({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BTd"), l = h(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = T(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (n, r) => (b(), O("td", {
      scope: a.value,
      class: W(l.value),
      colspan: s(e).colspan,
      rowspan: s(e).rowspan,
      "data-label": s(e).stackedHeading
    }, [
      s(e).stackedHeading ? (b(), O("div", Dc, [
        V(n.$slots, "default")
      ])) : V(n.$slots, "default", { key: 1 })
    ], 10, Hc));
  }
}), Za = /* @__PURE__ */ G({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BTfoot"), l = h(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (b(), O("tfoot", {
      class: W(l.value)
    }, [
      V(a.$slots, "default")
    ], 2));
  }
}), jc = ["scope", "colspan", "rowspan", "data-label"], Gc = { key: 0 }, Ja = /* @__PURE__ */ G({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BTh"), l = h(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = T(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (n, r) => (b(), O("th", {
      scope: a.value,
      class: W(l.value),
      colspan: s(e).colspan,
      rowspan: s(e).rowspan,
      "data-label": s(e).stackedHeading
    }, [
      s(e).stackedHeading !== void 0 ? (b(), O("div", Gc, [
        V(n.$slots, "default")
      ])) : V(n.$slots, "default", { key: 1 })
    ], 10, jc));
  }
}), fs = /* @__PURE__ */ G({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BThead"), l = h(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (b(), O("thead", {
      class: W(l.value)
    }, [
      V(a.$slots, "default")
    ], 2));
  }
}), Qe = /* @__PURE__ */ G({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = U(t, "BTr"), l = h(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (b(), O("tr", {
      class: W(l.value)
    }, [
      V(a.$slots, "default")
    ], 2));
  }
}), qc = {
  key: 0,
  class: "b-table-stacked-label"
}, Wc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Uc = { key: 2 }, vs = /* @__PURE__ */ G({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: "There are no records matching your request" },
    emptyText: { default: "There are no records to show" },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: !1 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: !1 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: !1 },
    tbodyClass: { default: void 0 },
    tbodyTrAttrs: { type: [Function, Object], default: void 0 },
    tbodyTrClass: { type: Function, default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    tableAttrs: {},
    tableClass: { default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(t, { emit: o }) {
    const l = U(t, "BTableLite"), a = o, n = (g) => [
      g,
      g._showDetails
    ], r = H(
      new WeakMap(
        l.items.reduce(
          (g, $) => (Je($) && g.push(n($)), g),
          []
        )
      )
    );
    de(
      () => l.items,
      (g) => {
        g.forEach(($) => {
          if (!Je($))
            return;
          const y = n($);
          r.value.set(y[0], y[1]);
        });
      },
      { deep: !0 }
    );
    const u = h(() => [
      l.tableClass,
      {
        [`align-${l.align}`]: l.align !== void 0
      }
    ]), i = h(() => {
      if (!l.fields.length && l.items.length) {
        const [g] = l.items;
        return Je(g) || Array.isArray(g) ? Object.keys(g).map(($) => {
          const y = na($);
          return {
            key: $,
            label: y,
            tdAttr: l.stacked === !0 ? { "data-label": y } : void 0
          };
        }) : [{ key: "", _noHeader: !0 }];
      }
      return l.fields.map((g) => {
        if (Vt(g))
          return {
            ...g,
            tdAttr: l.stacked === !0 ? { "data-label": na(g.key), ...g.tdAttr } : g.tdAttr
          };
        const $ = na(g);
        return {
          key: g,
          label: $,
          tdAttr: l.stacked === !0 ? { "data-label": $ } : void 0
        };
      });
    }), d = T(() => i.value.length), c = h(() => !(i.value.length > 0 && i.value.every((g) => g._noHeader === !0))), f = (g, $, y) => {
      const A = Fe(g, $);
      return y && typeof y == "function" ? y(A, $, g) : y;
    }, p = (g, $, y) => {
      const A = String($.key), S = Fe(g, A);
      return $.thAttr && typeof $.thAttr == "function" ? $.thAttr(S, A, g, y) : $.thAttr;
    }, v = (g, $, y = !1) => {
      a("head-clicked", g.key, g, $, y);
    }, m = (g) => {
      if (Je(g)) {
        const $ = r.value.get(g);
        r.value.set(g, !$), g._showDetails = !$;
      }
    }, B = (g) => [
      g.class,
      g.thClass,
      {
        "b-table-sticky-column": g.stickyColumn
      },
      l.fieldColumnClass ? typeof l.fieldColumnClass == "function" ? l.fieldColumnClass(g) : l.fieldColumnClass : null
    ], w = (g, $) => {
      var A, S;
      const y = Fe($, String(g.key));
      return [
        g.class,
        typeof g.tdClass == "function" ? g.tdClass(y, String(g.key), $) : g.tdClass,
        Je($) && (A = $._cellVariants) != null && A[g.key] ? `table-${(S = $._cellVariants) == null ? void 0 : S[g.key]}` : null,
        {
          "b-table-sticky-column": g.stickyColumn
        }
      ];
    }, _ = (g, $) => l.tbodyTrAttrs ? typeof l.tbodyTrAttrs == "function" ? l.tbodyTrAttrs(g, $) : l.tbodyTrAttrs : null, k = (g, $) => l.tbodyTrClass ? typeof l.tbodyTrClass == "function" ? l.tbodyTrClass(g, $) : l.tbodyTrClass : null;
    return (g, $) => (b(), L(Bl, {
      id: s(l).id,
      bordered: s(l).bordered,
      borderless: s(l).borderless,
      "border-variant": s(l).borderVariant,
      "caption-top": s(l).captionTop,
      dark: s(l).dark,
      fixed: s(l).fixed,
      hover: s(l).hover,
      "no-border-collapse": s(l).noBorderCollapse,
      outlined: s(l).outlined,
      responsive: s(l).responsive,
      small: s(l).small,
      stacked: s(l).stacked,
      "sticky-header": s(l).stickyHeader,
      striped: s(l).striped,
      "table-class": u.value,
      variant: s(l).variant,
      "striped-columns": s(l).stripedColumns
    }, {
      default: R(() => [
        dt(ge(fs, {
          variant: s(l).headVariant,
          class: W(s(l).theadClass)
        }, {
          default: R(() => [
            g.$slots["thead-top"] ? V(g.$slots, "thead-top", { key: 0 }) : ne("", !0),
            ge(Qe, {
              variant: s(l).headRowVariant,
              class: W(s(l).theadTrClass)
            }, {
              default: R(() => [
                (b(!0), O(pe, null, ke(i.value, (y) => (b(), L(Ja, J({
                  key: y.key,
                  scope: "col",
                  class: B(y),
                  title: y.headerTitle,
                  variant: y.variant,
                  abbr: y.headerAbbr,
                  style: y.thStyle,
                  ref_for: !0
                }, p(null, y, "top"), {
                  onClick: (A) => v(y, A)
                }), {
                  default: R(() => [
                    V(g.$slots, g.$slots[`head(${String(y.key)})`] ? `head(${String(y.key)})` : "head()", {
                      label: y.label,
                      column: y.key,
                      field: y,
                      isFoot: !1
                    }, () => [
                      ce(oe(s(sa)(y)), 1)
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "variant", "abbr", "style", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"]),
            g.$slots["thead-sub"] ? (b(), L(Qe, { key: 1 }, {
              default: R(() => [
                (b(!0), O(pe, null, ke(i.value, (y) => (b(), L(Ot, {
                  key: y.key,
                  scope: "col",
                  variant: y.variant,
                  class: W([y.class, y.thClass])
                }, {
                  default: R(() => [
                    V(g.$slots, "thead-sub", J({
                      items: i.value,
                      ref_for: !0
                    }, y), () => [
                      ce(oe(y.label), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["variant", "class"]))), 128))
              ]),
              _: 3
            })) : ne("", !0)
          ]),
          _: 3
        }, 8, ["variant", "class"]), [
          [Kt, c.value]
        ]),
        ge(cs, {
          class: W(s(l).tbodyClass)
        }, {
          default: R(() => [
            V(g.$slots, "custom-body", {
              fields: i.value,
              items: s(l).items,
              columns: i.value.length
            }, () => [
              !s(l).stacked && g.$slots["top-row"] ? (b(), L(Qe, J({
                key: 0,
                class: k(null, "row-top")
              }, _(null, "row-top")), {
                default: R(() => [
                  V(g.$slots, "top-row")
                ]),
                _: 3
              }, 16, ["class"])) : ne("", !0),
              (b(!0), O(pe, null, ke(s(l).items, (y, A) => (b(), O(pe, {
                key: s(l).primaryKey ? s(Fe)(y, s(l).primaryKey) : A
              }, [
                ge(Qe, J({
                  class: k(y, "row"),
                  variant: s(Je)(y) ? y._rowVariant : void 0,
                  ref_for: !0
                }, _(y, "row"), {
                  onClick: (S) => !s(Jt)(S) && a("row-clicked", y, A, S),
                  onDblclick: (S) => !s(Jt)(S) && a("row-dbl-clicked", y, A, S),
                  onMouseenter: (S) => !s(Jt)(S) && a("row-hovered", y, A, S),
                  onMouseleave: (S) => !s(Jt)(S) && a("row-unhovered", y, A, S)
                }), {
                  default: R(() => [
                    (b(!0), O(pe, null, ke(i.value, (S) => {
                      var Y;
                      return b(), L(Ot, J({
                        key: S.key,
                        variant: s(Je)(y) && (Y = y._cellVariants) != null && Y[S.key] ? null : S.variant,
                        class: w(S, y),
                        ref_for: !0
                      }, f(y, String(S.key), S.tdAttr)), {
                        default: R(() => [
                          s(l).stacked && s(l).labelStacked ? (b(), O("label", qc, oe(s(sa)(S)), 1)) : ne("", !0),
                          V(
                            g.$slots,
                            g.$slots[`cell(${String(S.key)})`] ? `cell(${String(S.key)})` : "cell()",
                            {
                              value: s(Ga)(y, String(S.key), S.formatter),
                              unformatted: s(Fe)(y, String(S.key)),
                              index: A,
                              item: y,
                              field: S,
                              items: g.items,
                              toggleDetails: () => {
                                m(y);
                              },
                              detailsShowing: s(Je)(y) ? r.value.get(y) ?? !1 : !1
                            },
                            () => [
                              !g.$slots[`cell(${String(S.key)})`] && !g.$slots["cell()"] ? (b(), O(pe, { key: 0 }, [
                                ce(oe(s(Ga)(y, String(S.key), S.formatter)), 1)
                              ], 64)) : ne("", !0)
                            ]
                          )
                        ]),
                        _: 2
                      }, 1040, ["variant", "class"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1040, ["class", "variant", "onClick", "onDblclick", "onMouseenter", "onMouseleave"]),
                s(Je)(y) && r.value.get(y) === !0 && g.$slots["row-details"] ? (b(), O(pe, { key: 0 }, [
                  ge(Qe, {
                    "aria-hidden": "true",
                    role: "presentation",
                    class: "d-none"
                  }),
                  ge(Qe, J({
                    class: k(y, "row-details"),
                    variant: y._rowVariant,
                    ref_for: !0
                  }, _(y, "row-details")), {
                    default: R(() => [
                      ge(Ot, {
                        colspan: d.value,
                        class: W(g.detailsTdClass)
                      }, {
                        default: R(() => [
                          V(g.$slots, "row-details", {
                            item: y,
                            toggleDetails: () => {
                              m(y);
                            },
                            fields: s(l).fields,
                            index: A
                          })
                        ]),
                        _: 2
                      }, 1032, ["colspan", "class"])
                    ]),
                    _: 2
                  }, 1040, ["class", "variant"])
                ], 64)) : ne("", !0)
              ], 64))), 128)),
              s(l).showEmpty && s(l).items.length === 0 ? (b(), L(Qe, {
                key: 1,
                class: "b-table-empty-slot"
              }, {
                default: R(() => [
                  ge(Ot, { colspan: d.value }, {
                    default: R(() => [
                      V(g.$slots, "empty", {
                        items: s(l).items
                      }, () => [
                        ce(oe(s(l).emptyText), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["colspan"])
                ]),
                _: 3
              })) : ne("", !0),
              !s(l).stacked && g.$slots["bottom-row"] ? (b(), L(Qe, J({
                key: 2,
                class: ["bottom-row", k(null, "row-bottom")]
              }, _(null, "row-bottom")), {
                default: R(() => [
                  V(g.$slots, "bottom-row")
                ]),
                _: 3
              }, 16, ["class"])) : ne("", !0)
            ])
          ]),
          _: 3
        }, 8, ["class"]),
        s(l).footClone ? (b(), L(Za, {
          key: 0,
          variant: s(l).footVariant,
          class: W(s(l).tfootClass)
        }, {
          default: R(() => [
            ge(Qe, {
              variant: s(l).footRowVariant,
              class: W(s(l).tfootTrClass)
            }, {
              default: R(() => [
                (b(!0), O(pe, null, ke(i.value, (y) => (b(), L(Ja, J({
                  key: y.key,
                  scope: "col",
                  class: B(y),
                  title: y.headerTitle,
                  abbr: y.headerAbbr,
                  style: y.thStyle,
                  variant: y.variant,
                  ref_for: !0
                }, p(null, y, "bottom"), {
                  onClick: (A) => v(y, A, !0)
                }), {
                  default: R(() => [
                    ae("div", Wc, [
                      ae("div", null, [
                        V(
                          g.$slots,
                          g.$slots[`foot(${String(y.key)})`] ? `foot(${String(y.key)})` : "foot()",
                          {
                            label: y.label,
                            column: y.key,
                            field: y,
                            isFoot: !0
                          },
                          () => [
                            ce(oe(s(sa)(y)), 1)
                          ]
                        )
                      ])
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "abbr", "style", "variant", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"])
          ]),
          _: 3
        }, 8, ["variant", "class"])) : g.$slots["custom-foot"] ? (b(), L(Za, { key: 1 }, {
          default: R(() => [
            V(g.$slots, "custom-foot", {
              fields: i.value,
              items: s(l).items,
              columns: i.value.length
            })
          ]),
          _: 3
        })) : ne("", !0),
        g.$slots["table-caption"] || s(l).caption ? (b(), O("caption", Uc, [
          V(g.$slots, "table-caption", {}, () => [
            ce(oe(s(l).caption), 1)
          ])
        ])) : ne("", !0)
      ]),
      _: 3
    }, 8, ["id", "bordered", "borderless", "border-variant", "caption-top", "dark", "fixed", "hover", "no-border-collapse", "outlined", "responsive", "small", "stacked", "sticky-header", "striped", "table-class", "variant", "striped-columns"]));
  }
}), Kc = /* @__PURE__ */ ae("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ ae("path", {
    "fill-rule": "evenodd",
    d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
  })
], -1), Xc = /* @__PURE__ */ ae("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-down-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ ae("path", {
    "fill-rule": "evenodd",
    d: "M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"
  })
], -1), Yc = {
  style: { opacity: 0.4 },
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, Zc = /* @__PURE__ */ ae("path", {
  "fill-rule": "evenodd",
  d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
}, null, -1), Jc = [
  Zc
], Qc = { class: "d-flex align-items-center gap-2 mt-5" }, ef = /* @__PURE__ */ G({
  __name: "BTable",
  props: /* @__PURE__ */ be({
    provider: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: Boolean, default: !1 },
    noProviderSorting: { type: Boolean, default: !1 },
    noProviderFiltering: { type: Boolean, default: !1 },
    sortBy: {},
    mustSort: { type: [Boolean, Array], default: !1 },
    selectable: { type: Boolean, default: !1 },
    multisort: { type: Boolean, default: !1 },
    stickySelect: { type: Boolean, default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "multi" },
    selectionVariant: { default: "primary" },
    busy: { type: Boolean },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: Number.POSITIVE_INFINITY },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    noLocalSorting: { type: Boolean, default: !1 },
    noSelectOnClick: { type: Boolean, default: !1 },
    selectedItems: {},
    noSortableIcon: { type: Boolean, default: !1 },
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: void 0 },
    emptyText: { default: void 0 },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: void 0 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: void 0 },
    tbodyClass: { default: void 0 },
    tbodyTrAttrs: {},
    tbodyTrClass: { type: Function, default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    tableAttrs: {}
  }, {
    sortBy: {
      default: void 0
    },
    sortByModifiers: {},
    busy: { type: Boolean, default: !1 },
    busyModifiers: {},
    selectedItems: {
      default: () => []
    },
    selectedItemsModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["filtered", "head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "sorted", "change"], ["update:sortBy", "update:busy", "update:selectedItems"]),
  setup(t, { expose: o, emit: e }) {
    const a = U(t, "BTable"), n = e, r = we(t, "sortBy"), u = we(t, "busy"), i = we(t, "selectedItems"), d = h({
      get: () => /* @__PURE__ */ new Set([...i.value]),
      set: (C) => {
        i.value = [...C];
      }
    }), c = {
      add: (C) => {
        const x = new Set(d.value);
        x.add(C), d.value = x, n("row-selected", C);
      },
      clear: () => {
        d.value.forEach((C) => {
          c.delete(C);
        });
      },
      delete: (C) => {
        const x = new Set(d.value);
        if (a.primaryKey) {
          const E = a.primaryKey;
          i.value.forEach((I, X) => {
            const D = Fe(I, E), M = Fe(C, E);
            D && M && D === M && x.delete(i.value[X]);
          });
        } else
          x.delete(C);
        d.value = x, n("row-unselected", C);
      },
      set: (C) => {
        d.value = new Set(C), d.value.forEach((x) => {
          n("row-unselected", x);
        });
      },
      has: (C) => {
        if (!a.primaryKey)
          return d.value.has(C);
        const x = a.primaryKey;
        for (const E of d.value) {
          const I = Fe(E, x), X = Fe(C, x);
          if (I && X && I === X)
            return !0;
        }
        return !1;
      }
    }, f = H([]), p = Be(() => a.perPage, { method: "parseInt" }), v = Be(() => a.currentPage, { method: "parseInt" }), m = T(() => !!a.filter), B = T(() => a.provider !== void 0), w = T(() => d.value.size > 0), _ = h(
      () => r.value !== void 0 || a.fields.some(
        (C) => typeof C == "object" && C !== null && C.sortable === !0
      )
    ), k = h(
      () => a.fields.map((C) => {
        var I;
        if (!Vt(C)) {
          const X = na(C);
          return {
            key: C,
            label: X,
            tdAttr: a.stacked === !0 ? { "data-label": X } : void 0
          };
        }
        const x = (I = r.value) == null ? void 0 : I.find((X) => C.key === X.key), E = _.value === !1 ? void 0 : x === void 0 ? "none" : x.order === "desc" ? "descending" : x.order === "asc" ? "ascending" : "none";
        return {
          ...C,
          thAttr: {
            "aria-sort": E,
            ...C.thAttr
          }
        };
      })
    ), g = h(() => ({
      "b-table-busy": u.value,
      "b-table-selectable": a.selectable,
      "user-select-none": a.selectable && w.value
    })), $ = h(() => [
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(null, "table-busy") : a.tbodyTrClass : null
    ]), y = (C) => [
      {
        "b-table-sortable-column": _.value && C.sortable
      }
    ], A = (C, x) => [
      {
        [`selected table-${a.selectionVariant}`]: a.selectable && !!C && c.has(C)
      },
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(C, x) : a.tbodyTrClass : null
    ], S = h(() => {
      const C = (I) => {
        var D;
        const X = (D = r.value) == null ? void 0 : D.filter((M) => !!M.order);
        return !X || X.length === 0 ? I : [...I].sort((M, Q) => {
          for (let Z = 0; Z < (X.length ?? 0); Z++) {
            const q = X[Z], se = (ue) => {
              if (!Je(ue))
                return String(ue);
              const me = k.value.find((re) => Vt(re) ? re.key === q.key : !1), le = Fe(ue, q.key);
              if (Vt(me) && me.sortByFormatted) {
                const re = typeof me.sortByFormatted == "function" ? me.sortByFormatted : me.formatter;
                if (re)
                  return Ga(ue, String(me.key), re);
              }
              return typeof le == "object" && le !== null ? JSON.stringify(le) : (le == null ? void 0 : le.toString()) ?? "";
            }, ie = se(M), te = se(Q), ve = q.comparer ? q.comparer(ie, te) : ie.localeCompare(te, void 0, { numeric: !0 });
            if (ve !== 0)
              return q.order === "asc" ? ve : -ve;
          }
          return 0;
        });
      }, x = (I) => I.filter(
        (X) => Je(X) ? Object.entries(X).some(([D, M]) => {
          var q, se, ie;
          return M == null || D[0] === "_" || !((q = a.filterable) != null && q.includes(D)) && ((se = a.filterable) != null && se.length) ? !1 : (() => {
            const te = k.value.find((ve) => Vt(ve) ? ve.key === D : !1);
            if (Vt(te) && te.filterByFormatted) {
              const ve = typeof te.filterByFormatted == "function" ? te.filterByFormatted : te.formatter;
              if (ve)
                return ve(M, String(te.key), X);
            }
            return typeof M == "object" ? JSON.stringify(Object.values(M)) : M.toString();
          })().toLowerCase().includes(((ie = a.filter) == null ? void 0 : ie.toLowerCase()) ?? "");
        }) : !0
      );
      let E = B.value ? f.value : a.items;
      return E = E.map((I) => {
        if (typeof I == "object" && I !== null && Object.keys(I).some((X) => X.includes("."))) {
          let X = {};
          for (const D in I)
            D.includes(".") ? X = ei(X, D, I[D]) : X[D] = I[D];
          return X;
        }
        return I;
      }), (m.value === !0 && !B.value || m.value === !0 && B.value && a.noProviderFiltering) && (E = x(E)), (_.value === !0 && !B.value && !a.noLocalSorting || _.value === !0 && B.value && a.noProviderSorting) && (E = C(E)), E;
    }), Y = h(() => Number.isNaN(p.value) || B.value && !a.noProviderPaging ? S.value : S.value.slice(
      (v.value - 1) * (p.value || Number.POSITIVE_INFINITY),
      v.value * (p.value || Number.POSITIVE_INFINITY)
    ));
    de(Y, (C) => {
      n("change", C);
    });
    const K = (C, x, E = !1, I = !1, X = !1) => {
      if (a.selectable)
        if (a.selectMode === "single" || a.selectMode === "multi") {
          if (E || I)
            return;
          c.has(C) ? c.delete(C) : a.selectMode === "single" ? c.set([C]) : c.add(C);
        } else if (I || X)
          c.has(C) ? c.delete(C) : c.add(C);
        else if (E) {
          const D = [...d.value].pop(), M = a.items.findIndex((se) => se === D), Q = Math.min(M, x), Z = Math.max(M, x), q = a.items.slice(Q, Z + 1);
          c.set(q);
        } else
          c.set([C]);
    }, P = (C, x, E) => {
      a.noSelectOnClick === !1 && K(C, x, E.shiftKey, E.ctrlKey, E.metaKey), n("row-clicked", C, x, E);
    }, j = (C) => {
      var q, se;
      if (!_.value)
        return;
      const x = typeof C == "object" && C !== null ? C.key : C, E = typeof C == "object" && C !== null ? C.sortable : !1;
      if (!(_.value === !0 && E === !0))
        return;
      const I = (ie) => {
        if (ie === "asc")
          return "desc";
        if (ie === void 0 || a.mustSort === !0 || Array.isArray(a.mustSort) && a.mustSort.includes(x))
          return "asc";
      }, X = ((q = r.value) == null ? void 0 : q.findIndex((ie) => ie.key === x)) ?? -1, D = (se = r.value) == null ? void 0 : se[X], M = (
        // If value is new, we default to ascending
        // Otherwise we make a temp copy of the value
        X === -1 || !D ? { key: x, order: "asc" } : { ...D }
      ), Q = () => {
        var te, ve;
        let ie = M;
        if (X === -1)
          r.value = [...r.value ?? [], M];
        else {
          const ue = I(M.order);
          ie = { ...M, order: ue }, r.value = ue ? (te = r.value) == null ? void 0 : te.map((me) => me.key === ie.key ? ie : me) : (ve = r.value) == null ? void 0 : ve.filter((me) => me.key !== ie.key);
        }
        return ie;
      }, Z = () => {
        const ie = {
          ...M,
          order: X === -1 ? M.order : I(M.order)
        };
        return r.value = [ie], ie;
      };
      n("sorted", a.multisort === !0 ? Q() : Z());
    }, F = (C, x, E, I = !1) => {
      n("head-clicked", C, x, E, I), j(x);
    }, N = async () => {
      if (!B.value || a.provider === void 0 || u.value)
        return;
      u.value = !0;
      const C = a.provider({
        currentPage: v.value,
        filter: a.filter,
        sortBy: r.value,
        perPage: p.value
      });
      try {
        const x = C instanceof Promise ? await C : C;
        if (x === void 0)
          return;
        f.value = x;
      } finally {
        u.value = !1;
      }
    }, z = async (C, x, E) => {
      if (x === E)
        return;
      const I = (Q) => {
        var Z;
        return ((Z = a.noProvider) == null ? void 0 : Z.includes(Q)) === !0;
      }, X = (C === "currentPage" || C === "perPage") && (I("paging") || a.noProviderPaging === !0), D = C === "filter" && (I("filtering") || a.noProviderFiltering === !0), M = (C === "sortBy" || C === "sortDesc") && (I("sorting") || a.noProviderSorting === !0);
      X || D || M || (B.value === !0 && await N(), C === "currentPage" || C === "perPage" || n("filtered", [...S.value]));
    };
    return de(
      () => a.filter,
      (C, x) => {
        z("filter", C, x), !(C === x || B.value) && (C || n("filtered", [...S.value]));
      }
    ), de(v, (C, x) => {
      z("currentPage", C, x);
    }), de(p, (C, x) => {
      z("perPage", C, x);
    }), de(
      r,
      (C, x) => {
        z("sortBy", C, x);
      },
      { deep: !0 }
    ), de(
      () => a.provider,
      (C) => {
        if (C === void 0) {
          f.value = [];
          return;
        }
        N();
      }
    ), He(N), o({
      // The row selection methods are really for compat. Users should probably use the v-model though
      clearSelected: () => {
        a.selectable && c.clear();
      },
      refresh: N,
      selectAllRows: () => {
        if (!a.selectable)
          return;
        const C = d.value.size > 0 ? [...d.value] : [];
        d.value = /* @__PURE__ */ new Set([...S.value]), d.value.forEach((x) => {
          C.includes(x) || n("row-selected", x);
        });
      },
      selectRow: (C) => {
        if (!a.selectable)
          return;
        const x = S.value[C];
        !x || c.has(x) || c.add(x);
      },
      unselectRow: (C) => {
        if (!a.selectable)
          return;
        const x = S.value[C];
        !x || !c.has(x) || c.delete(x);
      },
      isRowSelected: (C) => {
        if (!a.selectable)
          return !1;
        const x = S.value[C];
        return c.has(x);
      }
    }), (C, x) => (b(), L(vs, J(s(a), {
      "aria-busy": u.value,
      items: Y.value,
      fields: k.value,
      "table-class": g.value,
      "tbody-tr-class": A,
      "field-column-class": y,
      onHeadClicked: F,
      onRowDblClicked: x[0] || (x[0] = (E, I, X) => {
        n("row-dbl-clicked", E, I, X);
      }),
      onRowClicked: P,
      onRowHovered: x[1] || (x[1] = (E, I, X) => {
        n("row-hovered", E, I, X);
      }),
      onRowUnhovered: x[2] || (x[2] = (E, I, X) => {
        n("row-unhovered", E, I, X);
      })
    }), tl({
      "custom-body": R((E) => [
        u.value ? (b(), L(Qe, {
          key: 0,
          class: W(["b-table-busy-slot", $.value])
        }, {
          default: R(() => [
            ge(Ot, {
              colspan: E.fields.length
            }, {
              default: R(() => [
                V(C.$slots, "table-busy", {}, () => [
                  ge(us, { show: "" }, {
                    overlay: R(() => [
                      ae("div", Qc, [
                        ge(Aa),
                        ae("strong", null, oe(s(a).busyLoadingText), 1)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 2
            }, 1032, ["colspan"])
          ]),
          _: 2
        }, 1032, ["class"])) : ne("", !0)
      ]),
      _: 2
    }, [
      ke(C.$slots, (E, I) => ({
        name: I,
        fn: R((X) => [
          V(C.$slots, I, _e(Se(X)))
        ])
      })),
      ke(k.value, (E) => ({
        name: `head(${String(E.key)})`,
        fn: R((I) => {
          var X, D, M, Q;
          return [
            V(C.$slots, C.$slots[`head(${String(E.key)})`] ? `head(${String(E.key)})` : "head()", _e(Se(I)), () => [
              ce(oe(s(sa)(E)), 1)
            ]),
            _.value && I.field.sortable && s(a).noSortableIcon === !1 ? (b(), O(pe, { key: 0 }, [
              ((D = (X = r.value) == null ? void 0 : X.find((Z) => Z.key === I.field.key)) == null ? void 0 : D.order) === "asc" ? V(
                C.$slots,
                C.$slots[`sortAsc(${String(I.field.key)})`] ? `sortAsc(${String(I.field.key)})` : "sortAsc()",
                _e(J({ key: 0 }, { ...I })),
                () => [
                  Kc
                ]
              ) : ((Q = (M = r.value) == null ? void 0 : M.find((Z) => Z.key === I.field.key)) == null ? void 0 : Q.order) === "desc" ? V(
                C.$slots,
                C.$slots[`sortDesc(${String(I.field.key)})`] ? `sortDesc(${String(I.field.key)})` : "sortDesc()",
                _e(J({ key: 1 }, { ...I })),
                () => [
                  Xc
                ]
              ) : V(
                C.$slots,
                C.$slots[`sortDefault(${String(I.field.key)})`] ? `sortDefault(${String(I.field.key)})` : "sortDefault()",
                _e(J({ key: 2 }, { ...I })),
                () => [
                  (b(), O("svg", Yc, Jc))
                ]
              )
            ], 64)) : ne("", !0)
          ];
        })
      }))
    ]), 1040, ["aria-busy", "items", "fields", "table-class"]));
  }
}), tf = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "BTab",
  props: /* @__PURE__ */ be({
    active: { type: Boolean },
    buttonId: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    lazyOnce: { type: Boolean, default: void 0 },
    noBody: { type: Boolean, default: !1 },
    tag: { default: "div" },
    title: { default: void 0 },
    titleItemClass: { default: void 0 },
    titleLinkAttrs: { default: void 0 },
    titleLinkClass: { default: void 0 }
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: ["update:active"],
  setup(t) {
    const e = U(t, "BTab"), l = De(), a = we(t, "active"), n = Ve(Ko, null), r = Ce(() => e.id, "tabpane"), u = Ce(() => e.buttonId, "tab"), i = H(!1), d = H(null), { onClick: c, ...f } = Lt(), p = h(
      () => ({
        id: r.value,
        buttonId: u.value,
        disabled: e.disabled,
        title: e.title,
        titleComponent: l.title,
        titleItemClass: e.titleItemClass,
        titleLinkAttrs: e.titleLinkAttrs,
        titleLinkClass: e.titleLinkClass,
        onClick: c,
        el: d.value
      })
    );
    He(() => {
      n && (n.registerTab(p), e.active && n.activateTab(r.value));
    }), Cs(() => {
      n && n.unregisterTab(r.value);
    });
    const v = T(() => (n == null ? void 0 : n.activeId.value) === r.value), m = H(v.value), B = T(() => !!(n != null && n.lazy.value || (e.lazyOnce ?? e.lazy))), w = T(() => e.lazyOnce !== void 0), _ = T(() => v.value && !e.disabled), k = T(
      () => _.value || !B.value || B.value && w.value && i.value
    );
    de(v, ($) => {
      if ($) {
        a.value = !0, setTimeout(() => {
          m.value = !0;
        }, 0);
        return;
      }
      m.value = !1, a.value = !1;
    }), de(
      () => e.active,
      ($) => {
        if (n) {
          if (!$) {
            v.value && n.activateTab(void 0);
            return;
          }
          n.activateTab(r.value);
        }
      }
    );
    const g = h(() => [
      {
        active: v.value,
        show: m.value,
        "card-body": (n == null ? void 0 : n.card.value) && e.noBody === !1,
        fade: !(n != null && n.noFade.value)
      },
      m.value ? n == null ? void 0 : n.activeTabClass.value : n == null ? void 0 : n.inactiveTabClass.value,
      n == null ? void 0 : n.tabClass.value
    ]);
    return de(k, ($) => {
      $ && !i.value && (i.value = !0);
    }), ($, y) => (b(), L(fe(s(e).tag), J({
      id: s(r),
      ref_key: "el",
      ref: d,
      class: ["tab-pane", g.value],
      role: "tabpanel",
      "aria-labelledby": s(u)
    }, f), {
      default: R(() => [
        k.value ? V($.$slots, "default", { key: 0 }) : ne("", !0)
      ]),
      _: 3
    }, 16, ["id", "class", "aria-labelledby"]));
  }
}), af = ["aria-orientation"], lf = ["id", "aria-controls", "aria-selected", "onClick"], of = /* @__PURE__ */ G({
  __name: "BTabs",
  props: /* @__PURE__ */ be({
    activeId: {},
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    end: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inactiveNavItemClass: { default: void 0 },
    inactiveTabClass: { default: void 0 },
    justified: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    modelValue: {},
    navClass: { default: void 0 },
    navItemClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    noNavStyle: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "div" },
    tabClass: { default: void 0 },
    vertical: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: -1
    },
    modelModifiers: {},
    activeId: {
      default: void 0
    },
    activeIdModifiers: {}
  }),
  emits: /* @__PURE__ */ be(["activate-tab", "click"], ["update:modelValue", "update:activeId"]),
  setup(t, { emit: o }) {
    const l = U(t, "BTabs"), a = o, n = we(t, "modelValue"), r = we(t, "activeId"), u = va(), i = H([]), d = h(
      () => i.value.map((y) => {
        const A = s(y), S = A.id === r.value;
        return {
          ...A,
          active: S,
          navItemClasses: [
            {
              active: S,
              disabled: A.disabled
            },
            S ? l.activeNavItemClass : l.inactiveNavItemClass,
            l.navItemClass,
            A.titleLinkClass
          ]
        };
      })
    ), c = T(() => !(d != null && d.value && d.value.length > 0)), f = h(() => ({
      "d-flex": l.vertical,
      "align-items-start": l.vertical
    })), p = Xt(() => l.align), v = h(() => ({
      "nav-pills": l.pills,
      "flex-column me-3": l.vertical,
      [p.value]: l.align !== void 0,
      "nav-fill": l.fill,
      "card-header-tabs": l.card,
      "nav-justified": l.justified,
      "nav-tabs": !l.noNavStyle && !l.pills,
      small: l.small
    })), m = (y) => {
      var A;
      if (y !== void 0) {
        const S = (A = d.value[y]) == null ? void 0 : A.id;
        if (y > -1 && y < d.value.length && !d.value[y].disabled && (n.value < 0 || r.value !== S || n.value !== y)) {
          const Y = new ut("activate-tab", { cancelable: !0 });
          a("activate-tab", y, n.value, Y), Y.defaultPrevented || (r.value !== S && (r.value = S), n.value !== y && (n.value = y));
        }
      }
    }, B = (y, A) => {
      var S, Y, K;
      m(A), A >= 0 && !d.value[A].disabled && ((S = d.value[A]) != null && S.onClick) && typeof d.value[A].onClick == "function" && ((K = (Y = d.value[A]).onClick) == null || K.call(Y, y));
    }, w = (y) => {
      var A, S;
      d.value.length <= 0 || (n.value = _(n.value + y, y), (S = document.getElementById((A = d.value[n.value]) == null ? void 0 : A.buttonId)) == null || S.focus());
    }, _ = (y, A) => {
      let S = y, Y = -1, K = -1;
      for (let P = 0; P < d.value.length; P++)
        d.value[P].disabled || (Y === -1 && (Y = P), K = P);
      for (; S >= Y && S <= K && d.value[S].disabled; )
        S += A;
      return S < Y && (S = Y), S > K && (S = K), S;
    };
    de(n, (y, A) => {
      if (y === A || d.value.length <= 0)
        return;
      const S = _(y, y > A ? 1 : -1);
      Ne(() => {
        m(S);
      });
    }), de(r, (y, A) => {
      const S = d.value.findIndex((Y) => Y.id === y);
      if (y !== A && !(d.value.length <= 0)) {
        if (S === -1) {
          m(_(0, 1));
          return;
        }
        m(S);
      }
    });
    const k = (y) => {
      i.value.find((A) => A.value.id === y.value.id) ? i.value[i.value.findIndex((A) => A.value.id === y.value.id)] = y : i.value.push(y), i.value.sort((A, S) => {
        if (!Node || !A.value.el || !S.value.el)
          return 0;
        const Y = A.value.el.compareDocumentPosition(S.value.el);
        return Y & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : Y & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
      });
    }, g = (y) => {
      i.value = i.value.filter((A) => A.value.id !== y);
    };
    de(
      i,
      () => {
        $();
      },
      { deep: !0 }
    );
    const $ = () => {
      var y;
      if (d.value.length === 0) {
        n.value = -1, r.value = void 0;
        return;
      }
      if (n.value >= 0 && !r.value && (r.value = (y = d.value[n.value]) == null ? void 0 : y.id), d.value.find((A) => A.id === r.value)) {
        m(d.value.findIndex((A) => A.id === r.value));
        return;
      }
      m(d.value.map((A) => !A.disabled).indexOf(!0));
    };
    return We(Ko, {
      lazy: T(() => l.lazy),
      card: T(() => l.card),
      noFade: T(() => l.noFade),
      activeTabClass: T(() => l.activeTabClass),
      inactiveTabClass: T(() => l.inactiveTabClass),
      tabClass: T(() => l.tabClass),
      registerTab: k,
      unregisterTab: g,
      activeId: r,
      activateTab: (y) => {
        const A = d.value.findIndex((S) => S.id === y);
        if (y === void 0 || A === -1) {
          m(_(0, 1));
          return;
        }
        m(A);
      }
    }), (y, A) => (b(), L(fe(s(l).tag), {
      id: s(l).id,
      class: W(["tabs", f.value])
    }, {
      default: R(() => [
        ge(s(u).define, null, {
          default: R(() => [
            ae("div", {
              class: W(["tab-content", s(l).contentClass])
            }, [
              V(y.$slots, "default"),
              c.value ? (b(), O("div", {
                key: "bv-empty-tab",
                class: W(["tab-pane active", { "card-body": s(l).card }])
              }, [
                V(y.$slots, "empty")
              ], 2)) : ne("", !0)
            ], 2)
          ]),
          _: 3
        }),
        s(l).end ? (b(), L(s(u).reuse, { key: 0 })) : ne("", !0),
        ae("div", {
          class: W([
            s(l).navWrapperClass,
            { "card-header": s(l).card, "ms-auto": y.vertical && s(l).end }
          ])
        }, [
          ae("ul", {
            class: W(["nav", [v.value, s(l).navClass]]),
            role: "tablist",
            "aria-orientation": s(l).vertical ? "vertical" : "horizontal"
          }, [
            V(y.$slots, "tabs-start"),
            (b(!0), O(pe, null, ke(d.value, (S, Y) => (b(), O("li", {
              key: S.id,
              class: W(["nav-item", S.titleItemClass]),
              role: "presentation"
            }, [
              ae("button", J({
                id: S.buttonId,
                class: ["nav-link", S.navItemClasses],
                role: "tab",
                "aria-controls": S.id,
                "aria-selected": S.active,
                ref_for: !0
              }, S.titleLinkAttrs, {
                onKeydown: [
                  A[0] || (A[0] = Zt(xt((K) => w(-1), ["stop", "prevent"]), ["left"])),
                  A[1] || (A[1] = Zt(xt((K) => w(1), ["stop", "prevent"]), ["right"])),
                  A[2] || (A[2] = Zt(xt((K) => w(-999), ["stop", "prevent"]), ["page-up"])),
                  A[3] || (A[3] = Zt(xt((K) => w(999), ["stop", "prevent"]), ["page-down"]))
                ],
                onClick: xt((K) => B(K, Y), ["stop", "prevent"])
              }), [
                S.titleComponent ? (b(), L(fe(S.titleComponent), { key: 0 })) : (b(), O(pe, { key: 1 }, [
                  ce(oe(S.title), 1)
                ], 64))
              ], 16, lf)
            ], 2))), 128)),
            V(y.$slots, "tabs-end")
          ], 10, af)
        ], 2),
        s(l).end ? ne("", !0) : (b(), L(s(u).reuse, { key: 1 }))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), nf = { id: "__BVID__toaster-container" }, sf = /* @__PURE__ */ G({
  __name: "BToastOrchestrator",
  props: {
    appendToast: { type: Boolean, default: !1 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(t, { expose: o }) {
    const l = U(t, "BToastOrchestrator"), { remove: a, toasts: n, show: r, _setIsAppend: u, leave: i } = kn();
    de(
      () => l.appendToast,
      (c) => {
        u == null || u(c);
      },
      { immediate: !0 }
    );
    const d = (c) => xa(c, ["_modelValue", "_self", "pos"]);
    return o({
      remove: a,
      show: r,
      toasts: n
    }), (c, f) => (b(), L(_t, {
      to: s(l).teleportTo,
      disabled: s(l).teleportDisabled
    }, [
      ae("div", nf, [
        (b(!0), O(pe, null, ke(s(ti), (p, v) => (b(), O("div", {
          key: v,
          class: W([p, "toast-container position-fixed p-3"])
        }, [
          ge(vo, { name: "b-list" }, {
            default: R(() => {
              var m;
              return [
                (b(!0), O(pe, null, ke((m = s(n)) == null ? void 0 : m.filter((B) => B.value.props.pos === v), (B) => (b(), L(fe(B.value.component), J({
                  key: B.value.props._self,
                  ref_for: !0
                }, d(B.value.props), {
                  "model-value": B.value.props._modelValue,
                  "trans-props": { ...B.value.props.transProps, appear: !0 },
                  "onUpdate:modelValue": (w) => {
                    var _;
                    return (_ = s(i)) == null ? void 0 : _(B.value.props._self);
                  },
                  onHide: (w) => {
                    var _;
                    return (_ = s(a)) == null ? void 0 : _(B.value.props._self);
                  }
                }), null, 16, ["model-value", "trans-props", "onUpdate:modelValue", "onHide"]))), 128))
              ];
            }),
            _: 2
          }, 1024)
        ], 2))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), rf = /* @__PURE__ */ G({
  __name: "BTooltip",
  props: /* @__PURE__ */ be({
    interactive: { type: Boolean, default: void 0 },
    boundary: {},
    boundaryPadding: {},
    click: { type: Boolean, default: void 0 },
    closeOnHide: { type: Boolean },
    content: { default: void 0 },
    customClass: { default: void 0 },
    delay: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    html: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: void 0 },
    manual: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: void 0 },
    noFade: { type: Boolean, default: void 0 },
    noFlip: { type: Boolean, default: void 0 },
    noHide: { type: Boolean, default: void 0 },
    noShift: { type: Boolean, default: void 0 },
    noSize: { type: Boolean },
    noninteractive: { type: Boolean, default: void 0 },
    offset: { default: void 0 },
    placement: { default: void 0 },
    persistent: { type: Boolean },
    realtime: { type: Boolean, default: void 0 },
    reference: { default: void 0 },
    strategy: { default: void 0 },
    target: { default: void 0 },
    title: { default: void 0 },
    variant: { default: void 0 },
    teleportDisabled: { default: void 0 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: o }) {
    var u, i, d;
    const l = U(t, "BTooltip"), a = we(t, "modelValue"), n = h(() => {
      const { interactive: c, noninteractive: f, ...p } = l;
      return { noninteractive: f !== void 0 ? f : !c, ...p };
    }), r = H(null);
    return o({
      hide: (u = r.value) == null ? void 0 : u.hide,
      show: (i = r.value) == null ? void 0 : i.show,
      toggle: (d = r.value) == null ? void 0 : d.toggle
    }), (c, f) => (b(), L(dl, J({
      ref_key: "popover",
      ref: r
    }, n.value, {
      modelValue: a.value,
      "onUpdate:modelValue": f[0] || (f[0] = (p) => a.value = p),
      tooltip: ""
    }), tl({ _: 2 }, [
      ke(c.$slots, (p, v) => ({
        name: v,
        fn: R((m) => [
          V(c.$slots, v, _e(Se(m)))
        ])
      }))
    ]), 1040, ["modelValue"]));
  }
}), pf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: Zi,
  BAccordionItem: Qi,
  BAlert: tu,
  BAvatar: iu,
  BAvatarGroup: uu,
  BBadge: Wn,
  BBreadcrumb: fu,
  BBreadcrumbItem: Un,
  BButton: vt,
  BButtonGroup: vu,
  BButtonToolbar: mu,
  BCard: es,
  BCardBody: Jn,
  BCardFooter: Qn,
  BCardGroup: yu,
  BCardHeader: Xn,
  BCardImg: hl,
  BCardSubtitle: Zn,
  BCardText: gu,
  BCardTitle: Yn,
  BCarousel: Su,
  BCarouselSlide: Fu,
  BCloseButton: zt,
  BCol: Dt,
  BCollapse: qn,
  BContainer: Nu,
  BDropdown: ts,
  BDropdownDivider: Eu,
  BDropdownForm: Ru,
  BDropdownGroup: Hu,
  BDropdownHeader: ju,
  BDropdownItem: Gu,
  BDropdownItemButton: Uu,
  BDropdownText: Xu,
  BForm: as,
  BFormCheckbox: ls,
  BFormCheckboxGroup: id,
  BFormDatalist: ed,
  BFormFile: cd,
  BFormFloatingLabel: ld,
  BFormGroup: hd,
  BFormInput: Zl,
  BFormInvalidFeedback: Ua,
  BFormRadio: ns,
  BFormRadioGroup: Td,
  BFormRow: ia,
  BFormSelect: Vd,
  BFormSelectOption: Va,
  BFormSelectOptionGroup: ss,
  BFormSpinbutton: Pd,
  BFormTag: rs,
  BFormTags: Xd,
  BFormText: Ka,
  BFormTextarea: Zd,
  BFormValidFeedback: Xa,
  BImg: gl,
  BInput: Zl,
  BInputGroup: oc,
  BInputGroupText: nc,
  BLink: it,
  BListGroup: sc,
  BListGroupItem: rc,
  BModal: Wa,
  BModalOrchestrator: uc,
  BNav: dc,
  BNavForm: fc,
  BNavItem: pc,
  BNavItemDropdown: bc,
  BNavText: gc,
  BNavbar: hc,
  BNavbarBrand: Bc,
  BNavbarNav: _c,
  BNavbarToggle: Vc,
  BOffcanvas: Oc,
  BOverlay: us,
  BPagination: Ic,
  BPlaceholder: Ue,
  BPlaceholderButton: ds,
  BPlaceholderCard: Ec,
  BPlaceholderTable: Rc,
  BPlaceholderWrapper: zc,
  BPopover: dl,
  BProgress: Sn,
  BProgressBar: Tn,
  BRow: Mc,
  BSpinner: Aa,
  BTab: tf,
  BTable: ef,
  BTableLite: vs,
  BTableSimple: Bl,
  BTabs: of,
  BTbody: cs,
  BTd: Ot,
  BTfoot: Za,
  BTh: Ja,
  BThead: fs,
  BToast: xn,
  BToastOrchestrator: sf,
  BTooltip: rf,
  BTr: Qe,
  BTransition: $a
}, Symbol.toStringTag, { value: "Module" })), mf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: cn,
  useColorMode: ai,
  useModal: di,
  useModalController: _n,
  useScrollspy: Cn,
  useToast: kn
}, Symbol.toStringTag, { value: "Module" })), bf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: po,
  BvEvent: ut,
  BvTriggerableEvent: wt
}, Symbol.toStringTag, { value: "Module" })), yf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ComponentNames: jn,
  ComposableNames: Xi,
  DirectiveNames: Gn
}, Symbol.toStringTag, { value: "Module" })), io = "bootstrap-vue-next", uf = (t) => t.toLowerCase().startsWith("v") ? t.slice(1) : t, gf = (t = {}) => ({
  install(o) {
    (t.breadcrumb ?? !0) && o.use(An), ((t.id ?? !0) || typeof t.id == "object") && o.use(Vn, t), (t.modalController ?? !0) && o.use(zn), (t.modalManager ?? !0) && o.use(Mn), ((t.rtl ?? !0) || typeof t.rtl == "object") && o.use(Hn, t), (t.toast ?? !0) && o.use($n), o.use(Dn, t);
  }
}), hf = ({
  aliases: t = {},
  directives: o = !0,
  components: e = !0
} = {}) => {
  const l = typeof e == "boolean" ? { all: e } : e, a = new Set(Rl(l, jn)), n = typeof o == "boolean" ? { all: o } : o, r = new Set(
    Rl(n, Gn).map(uf)
  );
  return [
    {
      type: "component",
      resolve: (i) => {
        if (a.has(i) || t[i])
          return {
            name: t[i] || i,
            from: io
          };
      }
    },
    {
      type: "directive",
      resolve: (i) => {
        if (r.has(i))
          return {
            name: `v${i}`,
            from: io
          };
      }
    }
  ];
};
export {
  Zi as BAccordion,
  Qi as BAccordionItem,
  tu as BAlert,
  iu as BAvatar,
  uu as BAvatarGroup,
  Wn as BBadge,
  fu as BBreadcrumb,
  Un as BBreadcrumbItem,
  vt as BButton,
  vu as BButtonGroup,
  mu as BButtonToolbar,
  es as BCard,
  Jn as BCardBody,
  Qn as BCardFooter,
  yu as BCardGroup,
  Xn as BCardHeader,
  hl as BCardImg,
  Zn as BCardSubtitle,
  gu as BCardText,
  Yn as BCardTitle,
  Su as BCarousel,
  Fu as BCarouselSlide,
  zt as BCloseButton,
  Dt as BCol,
  qn as BCollapse,
  Nu as BContainer,
  ts as BDropdown,
  Eu as BDropdownDivider,
  Ru as BDropdownForm,
  Hu as BDropdownGroup,
  ju as BDropdownHeader,
  Gu as BDropdownItem,
  Uu as BDropdownItemButton,
  Xu as BDropdownText,
  as as BForm,
  ls as BFormCheckbox,
  id as BFormCheckboxGroup,
  ed as BFormDatalist,
  cd as BFormFile,
  ld as BFormFloatingLabel,
  hd as BFormGroup,
  Zl as BFormInput,
  Ua as BFormInvalidFeedback,
  ns as BFormRadio,
  Td as BFormRadioGroup,
  ia as BFormRow,
  Vd as BFormSelect,
  Va as BFormSelectOption,
  ss as BFormSelectOptionGroup,
  Pd as BFormSpinbutton,
  rs as BFormTag,
  Xd as BFormTags,
  Ka as BFormText,
  Zd as BFormTextarea,
  Xa as BFormValidFeedback,
  gl as BImg,
  Zl as BInput,
  oc as BInputGroup,
  nc as BInputGroupText,
  it as BLink,
  sc as BListGroup,
  rc as BListGroupItem,
  Wa as BModal,
  uc as BModalOrchestrator,
  dc as BNav,
  fc as BNavForm,
  pc as BNavItem,
  bc as BNavItemDropdown,
  gc as BNavText,
  hc as BNavbar,
  Bc as BNavbarBrand,
  _c as BNavbarNav,
  Vc as BNavbarToggle,
  Oc as BOffcanvas,
  us as BOverlay,
  Ic as BPagination,
  Ue as BPlaceholder,
  ds as BPlaceholderButton,
  Ec as BPlaceholderCard,
  Rc as BPlaceholderTable,
  zc as BPlaceholderWrapper,
  dl as BPopover,
  Sn as BProgress,
  Tn as BProgressBar,
  Mc as BRow,
  Aa as BSpinner,
  tf as BTab,
  ef as BTable,
  vs as BTableLite,
  Bl as BTableSimple,
  of as BTabs,
  cs as BTbody,
  Ot as BTd,
  Za as BTfoot,
  Ja as BTh,
  fs as BThead,
  xn as BToast,
  sf as BToastOrchestrator,
  rf as BTooltip,
  Qe as BTr,
  $a as BTransition,
  hf as BootstrapVueNextResolver,
  po as BvCarouselEvent,
  ut as BvEvent,
  wt as BvTriggerableEvent,
  jn as ComponentNames,
  pf as Components,
  Xi as ComposableNames,
  mf as Composables,
  Gn as DirectiveNames,
  vf as Directives,
  ff as Plugins,
  yf as Types,
  bf as Utils,
  An as breadcrumbPlugin,
  gf as createBootstrap,
  Dn as defaultsPlugin,
  Vn as idPlugin,
  zn as modalControllerPlugin,
  Mn as modalManagerPlugin,
  Hn as rtlPlugin,
  $n as toastPlugin,
  cn as useBreadcrumb,
  ai as useColorMode,
  di as useModal,
  _n as useModalController,
  Cn as useScrollspy,
  kn as useToast,
  wc as vBColorMode,
  Ya as vBModal,
  Tc as vBPopover,
  Sc as vBScrollspy,
  Ya as vBToggle,
  xc as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
